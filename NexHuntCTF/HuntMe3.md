Reverse Engineering
## 1. Initial Reconnaissance

We started with basic static analysis using `strings` to see if the flag was stored in plain text.

Bash

```
strings ./HuntMe3 | grep "nexus"
# No output
```

While we found strings like `"CONGRATULATIONS, MASTER HUNTER"` and `"The forest grants you passage eternal"`, the flag itself was not visible.

Next, we used `ltrace` to intercept library calls, hoping for a `strcmp` or `memcmp` against the flag.

Bash

```
ltrace ./HuntMe3
```

**Result:** The trace showed `fgets` reading our input and `strlen` checking the length, but no comparison function was called on our input string. This indicated a custom comparison loop.

## 2. Static Analysis (Decompilation)

We opened the binary in Ghidra and analyzed the `main` function.

1. **Input Reading:** The program reads input into a buffer using `fgets`.
    
2. **Validation Call:** It passes the input to a function `FUN_00401367`.
    
    - If this function returns `0`, we fail.
        
    - If it returns `1`, we get the "CONGRATULATIONS" message.
        

### Analyzing the Check Function (`FUN_00401367`)

Inside the validation function, we identified two critical checks:

1. **Length Check:**
    
    C
    

- ```
    sVar2 = strlen(param_1);
    if (sVar2 == 0x35) { ... } // Length must be 53 characters
    ```
    
- **The Shuffle & XOR Check:** The core logic was inside a loop running 53 times:
    
    C
    

1. ```
    bVar1 = FUN_004012bc(local_c); // Generate a dynamic key byte
    // Logic: Input[ShuffleArray[i]] ^ KeyByte == TargetArray[i]
    if ((byte)(param_1[ShuffleArray[i]] ^ bVar1) != TargetArray[i]) return 0;
    ```
    

This revealed the equation we needed to reverse:

Flag[Shuffle[i]]=Target[i]âŠ•Key(i)

## 3. Dynamic Analysis (GDB)

The `ShuffleArray` and `TargetArray` were located at memory addresses `0x402040` and `0x402080`. Since initialization functions ran before the check, we used GDB to dump these values from memory at runtime.

**GDB Commands used:**

Code snippet

```
break *0x401367   # Break at the validation function
run               # Run the program
x/53bx 0x402040   # Dump 53 bytes of the Shuffle Array
x/53bx 0x402080   # Dump 53 bytes of the Target Array
```

## 4. Reversing the Key Generator

The key byte `bVar1` was generated by `FUN_004012bc`. This function used a complex sequence of additions and bitwise operations, including a helper function `FUN_004012a0`.

Based on common CTF patterns and the context of bitwise operations, we hypothesized `FUN_004012a0` was a **Rotate Left** operation. We re-implemented the logic in Python.

## 5. Solution Script

We wrote a Python script to emulate the key generation, extract the arrays, and reverse the shuffle/XOR operation.

Python

```
# Solver for HuntMe3

# 1. Data dumped from GDB
shuffles = [
    0x2d, 0x2c, 0x32, 0x14, 0x06, 0x25, 0x0f, 0x03, 0x22, 0x07, 0x2f, 0x23, 0x00, 0x31, 0x1c, 0x27,
    0x10, 0x02, 0x30, 0x0a, 0x2a, 0x16, 0x05, 0x12, 0x1d, 0x01, 0x09, 0x17, 0x1b, 0x1f, 0x1a, 0x08,
    0x0c, 0x24, 0x04, 0x20, 0x2e, 0x34, 0x0b, 0x26, 0x0e, 0x33, 0x15, 0x1e, 0x19, 0x29, 0x13, 0x11,
    0x2b, 0x28, 0x21, 0x0d, 0x18
]

targets = [
    0xc7, 0x8e, 0x0b, 0xe5, 0x23, 0x81, 0x18, 0x23, 0x27, 0xed, 0x06, 0xa1, 0x19, 0x30, 0x38, 0xd0,
    0x2e, 0x66, 0xe2, 0x26, 0x6e, 0x23, 0xaa, 0xa1, 0x5d, 0x7d, 0x36, 0xe5, 0x6c, 0x6d, 0x35, 0xa0,
    0x34, 0x0c, 0xf9, 0x84, 0xd7, 0xc9, 0x5e, 0x56, 0xc2, 0xe9, 0x44, 0xe0, 0x77, 0x7b, 0x20, 0x78,
    0x1f, 0xd9, 0x98, 0x85, 0xf5
]

# 2. Helper: Rotate Left (emulating FUN_004012a0)
def rotate_left(val, shift):
    return ((val << shift) | (val >> (32 - shift))) & 0xFFFFFFFF

# 3. Key Generator (emulating FUN_004012bc)
def generate_key(idx):
    local_c = 0x7a8ab05c
    local_10 = 0x362d12d2
    local_14 = 0x1574b128
    
    for local_18 in range(idx + 1):
        local_c = (local_c + 0xe868d9fc) & 0xFFFFFFFF
        local_10 = (local_10 + (local_18 * local_18)) & 0xFFFFFFFF
        local_14 = rotate_left(local_14, local_18 & 7)

    uVar1 = local_c ^ local_10 ^ (local_14 >> (idx & 7))
    uVar1 = (uVar1 & 0xff) ^ ((uVar1 & 0x1f) << 3)
    return (uVar1 ^ (uVar1 >> 5)) & 0xFF

# 4. Decrypting the Flag
flag_list = [''] * 53
for i in range(53):
    key = generate_key(i)
    # Reverse the math: Target XOR Key = Input
    original_char = chr(targets[i] ^ key)
    
    # Un-shuffle the character to its original position
    if shuffles[i] < 53:
        flag_list[shuffles[i]] = original_char

print("".join(flag_list))
```

## 6. The Flag

Running the solver produced the correct flag:

`nexus{thr33_hunt5_c0mpl3t3_th3_f0r3st_gr4nts_p4ss4g3}`
