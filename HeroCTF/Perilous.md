crypto
## 1. Challenge Overview

The challenge involved a Python script (`chall.py`) that implemented a custom encryption service using the `cryptography` library's `hazmat.decrepit.ciphers.algorithms.ARC4` algorithm.

Key features of the script:
- Reads a `FLAG` from `flag.txt`.
- Generates a random `MASK` of the same length as the `FLAG`.
- An `xor` function that handles repeating the shorter byte string.
- An `encrypt` function that takes a hexadecimal key (`k`) and a hexadecimal message (`m`).
- **Crucially, the `encrypt` function prevents key reuse:** it maintains a list `KEYS` of all previously used keys and raises an exception if an attempt is made to encrypt with an already used key (`if k in KEYS: raise Exception("Duplicate key used, aborting")`).
- The encryption process within `encrypt` was:
    1. `m = xor(m, MASK)`
    2. `m = encryptor.update(m)` (RC4 encryption)
    3. `m = xor(m, MASK)`
- The script first encrypts the `FLAG` using a user-provided key, then enters a loop allowing arbitrary key/message encryptions.

## 2. Vulnerability Identification

Upon analyzing the `encrypt` function, the double XOR with `MASK` was a point of interest. Let `KS` be the RC4 keystream generated by the key `k`. The encryption effectively became:
`final_encrypted = ((plaintext_message ^ MASK) ^ KS) ^ MASK`
Due to the properties of XOR (`A ^ B ^ B = A`), this simplifies to:
`final_encrypted = plaintext_message ^ KS`
This means the `MASK` operations effectively cancel each other out, and the encryption is simply a standard RC4 stream cipher encryption (or decryption, as RC4 is symmetric).

The primary constraint was the prevention of key reuse. A typical known-plaintext attack on RC4 involves encrypting a known plaintext with the same key used for the target ciphertext to recover the keystream. Since key reuse was blocked, a direct application of this was not possible through the service's interface.

However, the import path `cryptography.hazmat.decrepit.ciphers.algorithms.ARC4` and the welcome message "Some may call it deprecated, I call it vintage" strongly hinted at inherent weaknesses in the ARC4 algorithm itself, especially with "weak keys" or short keys. RC4 is known for producing biased keystreams or being susceptible to state recovery for certain keys.

The key insight for this CTF was that RC4 is a deterministic stream cipher. For a given key, it will *always* produce the same keystream. If we can choose a key for the `FLAG` encryption, and we know that key, we can *locally* generate the corresponding keystream without needing to reuse the key on the server.

## 3. Attack Strategy (Local Challenge)

1.  **Choose a "Weak" but Valid Key:** Based on `cryptography` library documentation and common RC4 weaknesses, keys between 5 and 256 bytes are generally valid. We chose the simplest valid key: 5 null bytes, represented in hex as `"0000000000"`.

2.  **Extract Encrypted Flag (`C_flag_hex`):**
    *   Interacting directly with `input()` via `run_shell_command` proved difficult.
    *   To ensure correct input, `chall.py` was temporarily modified:
        *   `k = input("flag k: ")` was changed to `k = "0000000000"`.
        *   The `print(encrypt(k, FLAG.hex()))` line was changed to capture and print *only* the hex string for easier parsing.
        *   The `while True` loop was commented out.
    *   The modified script was executed, and the output `C_flag_hex = "967dfb2ed8711c71cf59582b1629ef67"` was captured.
    *   The original `chall.py` was then restored.

3.  **Local Keystream Generation:**
    *   The length of the `FLAG` in bytes was determined from the length of `C_flag_hex` (`FLAG_len_bytes = len(C_flag_hex) // 2`).
    *   A local Python script was used to instantiate `algorithms.ARC4(bytes.fromhex("0000000000"))` and generate a keystream of `FLAG_len_bytes` length by encrypting a block of null bytes (`b'\x00' * FLAG_len_bytes`).

4.  **Decryption:** The captured `C_flag_bytes` was XORed with the locally generated `KS_flag_bytes` to recover the `FLAG_bytes`.

**Local Flag:** `Hero{FAKE_FLAG}`

## 4. Attack Strategy (Remote Challenge)

The same attack strategy was applied to the remote server (`nc crypto.heroctf.fr 9001`).

1.  **Connect and Provide Key:** Used `nc crypto.heroctf.fr 9001` and provided `"0000000000"` when prompted for `flag k:`.
2.  **Capture Remote `C_flag_hex`:** The server responded with the encrypted flag `C_flag_hex = "967dfb2ed8003509d5762d156602a732f77c20d1c3bcd8a3721a230478e66ba99fff076958e2"`.
3.  **Local Decryption:** The captured `C_flag_hex` from the remote server was then decrypted using the same local keystream generation and XOR method as for the local challenge.

## 5. Tools Used

-   `python3`
-   `cryptography` library (for local keystream generation)
-   `netcat` (`nc`) (for interacting with the remote server)

## 6. Final Flag

**Remote Flag:** `Hero{7h3_p3r1l5_0f_r3p3471n6_p4773rn5}`

[[HeroCTF 2025]]

